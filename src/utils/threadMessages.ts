import isPlainObject from 'lodash/isPlainObject';

import type { ThreadMessageDto } from '../autogenerated';

export interface ReasoningChunkEntry {
  reasoningId: string;
  content: string;
  createdAt?: string;
  updatedAt?: string;
  runId?: string;
  threadId?: string;
}

export const STREAMING_REASONING_FLAG = '__streamingReasoning';

const getMessageString = (
  payload: ThreadMessageDto['message'],
  key: string,
): string | undefined => {
  if (!payload || typeof payload !== 'object') {
    return undefined;
  }
  const value = (payload as unknown as Record<string, unknown>)[key];
  return typeof value === 'string' ? value : undefined;
};

export const sortMessagesChronologically = (
  msgs: ThreadMessageDto[],
): ThreadMessageDto[] => {
  if (msgs.length <= 1) return msgs;
  const decorated = msgs.map((msg, i) => ({
    msg,
    ts: new Date(msg.createdAt).getTime(),
    idx: i,
  }));
  decorated.sort((a, b) => a.ts - b.ts || a.idx - b.idx);
  return decorated.map((d) => d.msg);
};

export const extractReasoningEntries = (
  source: unknown,
  context: { threadId?: string; runId?: string } = {},
): ReasoningChunkEntry[] => {
  if (!isPlainObject(source)) {
    return [];
  }

  const entries: ReasoningChunkEntry[] = [];

  Object.entries(source as Record<string, unknown>).forEach(([key, raw]) => {
    if (typeof raw === 'string') {
      entries.push({
        reasoningId: key,
        content: raw,
        threadId: context.threadId,
        runId: context.runId,
      });
      return;
    }

    if (isPlainObject(raw)) {
      const rawObject = raw as Record<string, unknown>;
      const nestedThreadId =
        (typeof rawObject.threadId === 'string'
          ? rawObject.threadId
          : undefined) ??
        context.threadId ??
        (key.includes(':') ? key : undefined);
      const nestedRunId =
        (typeof rawObject.runId === 'string' ? rawObject.runId : undefined) ??
        context.runId ??
        (key.startsWith('run-') ? key : undefined);

      if (typeof rawObject.content === 'string') {
        entries.push({
          reasoningId: key,
          content: rawObject.content,
          createdAt:
            typeof rawObject.createdAt === 'string'
              ? rawObject.createdAt
              : undefined,
          updatedAt:
            typeof rawObject.updatedAt === 'string'
              ? rawObject.updatedAt
              : undefined,
          runId: nestedRunId,
          threadId: nestedThreadId,
        });
        return;
      }

      entries.push(
        ...extractReasoningEntries(rawObject, {
          threadId: nestedThreadId,
          runId: nestedRunId,
        }),
      );
    }
  });

  return entries;
};

export const narrowReasoningContainer = (
  source: unknown,
  keys: (string | undefined)[],
): unknown => {
  if (!isPlainObject(source)) return source;
  let current: unknown = source;
  let narrowed = false;

  keys.forEach((key) => {
    if (!key || !isPlainObject(current)) return;
    const next = (current as Record<string, unknown>)[key];
    if (next !== undefined) {
      current = next;
      narrowed = true;
    }
  });

  return narrowed ? current : source;
};

export const isReasoningMessage = (msg: ThreadMessageDto): boolean =>
  (msg.message?.role as string) === 'reasoning';

export const getReasoningIdentifier = (
  msg: ThreadMessageDto,
): string | undefined => {
  if (!isReasoningMessage(msg)) return undefined;
  const reasoningId = getMessageString(msg.message, 'id');
  if (typeof reasoningId === 'string' && reasoningId.length > 0) {
    return reasoningId;
  }
  const kwargs = msg.message?.additionalKwargs as
    | Record<string, unknown>
    | undefined;
  const fallback =
    (kwargs?.__reasoningId as unknown) ?? (kwargs?.reasoningId as unknown);
  return typeof fallback === 'string' && fallback.length > 0
    ? fallback
    : undefined;
};

export const getMessageRunId = (msg: ThreadMessageDto): string | undefined => {
  const kwargs = msg.message?.additionalKwargs as
    | Record<string, unknown>
    | undefined;
  if (!kwargs) return undefined;
  const runId =
    (kwargs.__runId as unknown) ??
    (kwargs.run_id as unknown) ??
    (kwargs.runId as unknown);
  return typeof runId === 'string' ? runId : undefined;
};

export const isStreamingReasoningMessage = (msg: ThreadMessageDto): boolean => {
  if (!isReasoningMessage(msg)) return false;
  const kwargs = msg.message?.additionalKwargs as
    | Record<string, unknown>
    | undefined;
  if (!kwargs) return false;
  return Boolean(kwargs[STREAMING_REASONING_FLAG]);
};

export const removeStreamingReasoningMessages = (
  msgs: ThreadMessageDto[],
  predicate: (msg: ThreadMessageDto) => boolean,
): ThreadMessageDto[] => {
  if (!predicate) return msgs;
  return msgs.filter((msg) => {
    if (!isStreamingReasoningMessage(msg)) return true;
    return !predicate(msg);
  });
};

/**
 * Normalize message content for comparison.
 * Handles string, array, and nested object formats.
 */
const normalizeMessageContent = (raw: unknown): string | null => {
  if (typeof raw === 'string') {
    const trimmed = raw.trim();
    return trimmed || null;
  }
  if (Array.isArray(raw) && raw.length === 1 && typeof raw[0] === 'string') {
    const trimmed = raw[0].trim();
    return trimmed || null;
  }
  if (raw && typeof raw === 'object') {
    const record = raw as Record<string, unknown>;
    const nested = record.content;
    if (typeof nested === 'string') {
      const trimmed = nested.trim();
      return trimmed || null;
    }
  }
  return null;
};

export const mergeMessagesReplacingStreaming = (
  prev: ThreadMessageDto[],
  incoming: ThreadMessageDto[],
): ThreadMessageDto[] => {
  if (incoming.length === 0) {
    return prev;
  }

  const reasoningIds = new Set(
    incoming
      .map((msg) => getReasoningIdentifier(msg))
      .filter((id): id is string => Boolean(id)),
  );

  const reasoningRunIds = new Set(
    incoming
      .filter((msg) => isReasoningMessage(msg))
      .map((msg) => getMessageRunId(msg))
      .filter((runId): runId is string => Boolean(runId)),
  );

  const cleanedPrev =
    reasoningIds.size > 0 || reasoningRunIds.size > 0
      ? removeStreamingReasoningMessages(prev, (msg) => {
          if (!isStreamingReasoningMessage(msg)) {
            return false;
          }
          const reasoningId = getReasoningIdentifier(msg);
          if (reasoningId && reasoningIds.has(reasoningId)) {
            return true;
          }
          const runId = getMessageRunId(msg);
          if (runId && reasoningRunIds.has(runId)) {
            return true;
          }
          return false;
        })
      : prev;

  // Build a map of optimistic human messages by content for deduplication
  const optimisticHumanByContent = new Map<string, ThreadMessageDto>();
  cleanedPrev.forEach((msg) => {
    const isOptimistic =
      typeof msg.id === 'string' && msg.id.startsWith('optimistic-');
    if (isOptimistic && msg.message?.role === 'human') {
      const content = normalizeMessageContent(msg.message?.content);
      if (content && !optimisticHumanByContent.has(content)) {
        optimisticHumanByContent.set(content, msg);
      }
    }
  });

  const map = new Map<string, ThreadMessageDto>();

  // Add previous messages, but skip optimistic messages that will be replaced
  cleanedPrev.forEach((msg) => {
    const isOptimistic =
      typeof msg.id === 'string' && msg.id.startsWith('optimistic-');

    if (isOptimistic && msg.message?.role === 'human') {
      const content = normalizeMessageContent(msg.message?.content);
      if (content) {
        // Check if any incoming real message has the same content
        const hasMatchingIncoming = incoming.some((incomingMsg) => {
          const isIncomingOptimistic =
            typeof incomingMsg.id === 'string' &&
            incomingMsg.id.startsWith('optimistic-');
          if (isIncomingOptimistic) {
            return false; // Don't match against other optimistic messages
          }
          if (incomingMsg.message?.role === 'human') {
            const incomingContent = normalizeMessageContent(
              incomingMsg.message?.content,
            );
            return incomingContent === content;
          }
          return false;
        });

        if (hasMatchingIncoming) {
          // Skip this optimistic message, it will be replaced by the real one
          return;
        }
      }
    }

    map.set(msg.id, msg);
  });

  // Add incoming messages
  incoming.forEach((msg) => map.set(msg.id, msg));

  return sortMessagesChronologically(Array.from(map.values()));
};

export const buildIdSet = (
  ...values: (string | undefined)[]
): Set<string> | undefined => {
  const filtered = values.filter((value): value is string => Boolean(value));
  return filtered.length > 0 ? new Set(filtered) : undefined;
};

export interface ReasoningUpsertContext {
  externalThreadId?: string;
  runId?: string;
  selectedThreadId?: string;
  nodeId?: string;
}

const buildReasoningThreadMessage = (
  entry: ReasoningChunkEntry,
  existing: ThreadMessageDto | undefined,
  context: ReasoningUpsertContext,
): ThreadMessageDto => {
  const nowIso = new Date().toISOString();
  const existingMessage = existing?.message as
    | (ThreadMessageDto['message'] & {
        additionalKwargs?: Record<string, unknown>;
        content?: string;
      })
    | undefined;
  const existingAdditional =
    (existingMessage?.additionalKwargs as Record<string, unknown>) ?? {};

  const resolvedExternalThreadId =
    context.externalThreadId ??
    entry.threadId ??
    existing?.externalThreadId ??
    context.selectedThreadId ??
    '';

  const createdAt =
    existing?.createdAt ??
    entry.createdAt ??
    (typeof existingAdditional.__createdAt === 'string'
      ? (existingAdditional.__createdAt as string)
      : typeof existingAdditional.created_at === 'string'
        ? (existingAdditional.created_at as string)
        : nowIso);
  const updatedAt = entry.updatedAt ?? existing?.updatedAt ?? nowIso;

  const additionalKwargs: Record<string, unknown> = {
    ...existingAdditional,
    __reasoningId: entry.reasoningId,
    [STREAMING_REASONING_FLAG]: true,
  };

  const resolvedRunId =
    context.runId ??
    entry.runId ??
    (typeof existingAdditional.__runId === 'string'
      ? (existingAdditional.__runId as string)
      : typeof existingAdditional.run_id === 'string'
        ? (existingAdditional.run_id as string)
        : undefined);
  if (resolvedRunId) {
    additionalKwargs.__runId = resolvedRunId;
  }

  if (entry.createdAt) {
    additionalKwargs.__createdAt = entry.createdAt;
  } else if (!additionalKwargs.__createdAt) {
    additionalKwargs.__createdAt = createdAt;
  }

  if (!additionalKwargs.__reasoningId) {
    additionalKwargs.__reasoningId = entry.reasoningId;
  }

  return {
    id: entry.reasoningId,
    threadId: context.selectedThreadId ?? '',
    nodeId: context.nodeId ?? entry.reasoningId,
    externalThreadId: resolvedExternalThreadId,
    createdAt,
    updatedAt,
    message: {
      id: entry.reasoningId,
      role: 'reasoning' as string,
      content: entry.content,
      additionalKwargs,
    } as ThreadMessageDto['message'],
  };
};

export const upsertReasoningEntries = (
  prev: ThreadMessageDto[],
  entries: ReasoningChunkEntry[],
  context: ReasoningUpsertContext,
): ThreadMessageDto[] => {
  if (!entries.length) return prev;

  let hasChanges = false;
  let hasNewEntries = false;
  const byId = new Map<string, ThreadMessageDto>();
  prev.forEach((msg) => {
    byId.set(msg.id, msg);
  });

  entries.forEach((entry) => {
    const existing = byId.get(entry.reasoningId);
    const existingMessage = existing?.message as
      | (ThreadMessageDto['message'] & {
          additionalKwargs?: Record<string, unknown>;
          content?: string;
        })
      | undefined;
    const existingAdditional =
      (existingMessage?.additionalKwargs as Record<string, unknown>) ?? {};
    const isExistingStreaming = Boolean(
      existingAdditional?.[STREAMING_REASONING_FLAG],
    );

    if (existing && !isExistingStreaming) {
      return;
    }

    const existingContent =
      typeof existingMessage?.content === 'string'
        ? existingMessage.content
        : '';

    const nextMessage = buildReasoningThreadMessage(entry, existing, context);

    // If we already have a streaming message for this reasoningId, append
    // new chunk content so we accumulate text as it streams.
    const nextMessageContent =
      typeof nextMessage.message?.content === 'string'
        ? (nextMessage.message.content as string)
        : '';

    if (isExistingStreaming && nextMessageContent.length > 0) {
      const shouldUseIncoming =
        nextMessageContent.startsWith(existingContent) ||
        nextMessageContent.length > existingContent.length;
      const mergedContent = shouldUseIncoming
        ? nextMessageContent
        : `${existingContent}${nextMessageContent}`;
      (nextMessage.message as ThreadMessageDto['message']).content =
        mergedContent.length > existingContent.length
          ? mergedContent
          : nextMessageContent;
    }

    const nextContent = entry.content;
    const nextAdditional =
      (nextMessage.message?.additionalKwargs as Record<string, unknown>) ?? {};
    // Shallow comparison — sufficient because buildReasoningThreadMessage
    // only sets primitive values (strings, booleans) in additionalKwargs.
    const additionalChanged = (() => {
      const existingKeys = Object.keys(existingAdditional);
      const nextKeys = Object.keys(nextAdditional);
      if (existingKeys.length !== nextKeys.length) return true;
      return existingKeys.some(
        (k) => existingAdditional[k] !== nextAdditional[k],
      );
    })();

    if (
      !existing ||
      existingContent !== nextContent ||
      existing?.updatedAt !== nextMessage.updatedAt ||
      additionalChanged ||
      Boolean(
        (
          nextMessage.message?.additionalKwargs as
            | Record<string, unknown>
            | undefined
        )?.[STREAMING_REASONING_FLAG],
      )
    ) {
      hasChanges = true;
      if (!existing) {
        hasNewEntries = true;
      }
    }

    byId.set(entry.reasoningId, nextMessage);
  });

  if (!hasChanges) {
    return prev;
  }

  if (!hasNewEntries) {
    // Only updated existing entries — order unchanged, just replace in-place.
    return prev.map((msg) => byId.get(msg.id) ?? msg);
  }

  return sortMessagesChronologically(Array.from(byId.values()));
};

export const clearStreamingReasoningForContext = (
  prev: ThreadMessageDto[],
  options: {
    targetThreadId?: string;
    selectedThreadId?: string;
    runIds?: Set<string>;
  },
): ThreadMessageDto[] => {
  const {
    targetThreadId,
    selectedThreadId: selectedThreadIdForContext,
    runIds,
  } = options;

  const predicate = (msg: ThreadMessageDto) => {
    const threadMatches = targetThreadId
      ? msg.externalThreadId === targetThreadId ||
        (!msg.externalThreadId && targetThreadId === selectedThreadIdForContext)
      : !msg.externalThreadId ||
        msg.externalThreadId === selectedThreadIdForContext;

    if (!threadMatches) {
      return false;
    }

    if (runIds && runIds.size > 0) {
      const msgRunId = getMessageRunId(msg);
      if (!msgRunId || !runIds.has(msgRunId)) {
        return false;
      }
    }

    return true;
  };

  return removeStreamingReasoningMessages(prev, predicate);
};
