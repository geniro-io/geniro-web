/* tslint:disable */
/* eslint-disable */
/**
 * geniro-api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: none
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from './base';

/**
 *
 * @export
 * @interface AnalyticsByGraphResponseDto
 */
export interface AnalyticsByGraphResponseDto {
  /**
   *
   * @type {Array<AnalyticsByGraphResponseDtoGraphsInner>}
   * @memberof AnalyticsByGraphResponseDto
   */
  'graphs': Array<AnalyticsByGraphResponseDtoGraphsInner>;
}
/**
 *
 * @export
 * @interface AnalyticsByGraphResponseDtoGraphsInner
 */
export interface AnalyticsByGraphResponseDtoGraphsInner {
  /**
   * Total number of threads
   * @type {number}
   * @memberof AnalyticsByGraphResponseDtoGraphsInner
   */
  'totalThreads': number;
  /**
   * Sum of input tokens
   * @type {number}
   * @memberof AnalyticsByGraphResponseDtoGraphsInner
   */
  'inputTokens': number;
  /**
   * Sum of cached input tokens
   * @type {number}
   * @memberof AnalyticsByGraphResponseDtoGraphsInner
   */
  'cachedInputTokens': number;
  /**
   * Sum of output tokens
   * @type {number}
   * @memberof AnalyticsByGraphResponseDtoGraphsInner
   */
  'outputTokens': number;
  /**
   * Sum of reasoning tokens
   * @type {number}
   * @memberof AnalyticsByGraphResponseDtoGraphsInner
   */
  'reasoningTokens': number;
  /**
   * Sum of all tokens
   * @type {number}
   * @memberof AnalyticsByGraphResponseDtoGraphsInner
   */
  'totalTokens': number;
  /**
   * Total cost in USD
   * @type {number}
   * @memberof AnalyticsByGraphResponseDtoGraphsInner
   */
  'totalPrice': number;
  /**
   * Graph ID
   * @type {string}
   * @memberof AnalyticsByGraphResponseDtoGraphsInner
   */
  'graphId': string;
  /**
   * Graph name
   * @type {string}
   * @memberof AnalyticsByGraphResponseDtoGraphsInner
   */
  'graphName': string;
}
/**
 *
 * @export
 * @interface AnalyticsOverviewDto
 */
export interface AnalyticsOverviewDto {
  /**
   * Total number of threads
   * @type {number}
   * @memberof AnalyticsOverviewDto
   */
  'totalThreads': number;
  /**
   * Sum of input tokens
   * @type {number}
   * @memberof AnalyticsOverviewDto
   */
  'inputTokens': number;
  /**
   * Sum of cached input tokens
   * @type {number}
   * @memberof AnalyticsOverviewDto
   */
  'cachedInputTokens': number;
  /**
   * Sum of output tokens
   * @type {number}
   * @memberof AnalyticsOverviewDto
   */
  'outputTokens': number;
  /**
   * Sum of reasoning tokens
   * @type {number}
   * @memberof AnalyticsOverviewDto
   */
  'reasoningTokens': number;
  /**
   * Sum of all tokens
   * @type {number}
   * @memberof AnalyticsOverviewDto
   */
  'totalTokens': number;
  /**
   * Total cost in USD
   * @type {number}
   * @memberof AnalyticsOverviewDto
   */
  'totalPrice': number;
}
/**
 *
 * @export
 * @interface CreateGraphDto
 */
export interface CreateGraphDto {
  /**
   *
   * @type {string}
   * @memberof CreateGraphDto
   */
  'name': string;
  /**
   *
   * @type {string}
   * @memberof CreateGraphDto
   */
  'description'?: string | null;
  /**
   *
   * @type {CreateGraphDtoSchema}
   * @memberof CreateGraphDto
   */
  'schema': CreateGraphDtoSchema;
  /**
   *
   * @type {CreateGraphDtoMetadata}
   * @memberof CreateGraphDto
   */
  'metadata'?: CreateGraphDtoMetadata | null;
  /**
   *
   * @type {boolean}
   * @memberof CreateGraphDto
   */
  'temporary'?: boolean | null;
}
/**
 *
 * @export
 * @interface CreateGraphDtoMetadata
 */
export interface CreateGraphDtoMetadata {
  [key: string]: any;

  /**
   * Node coordinates and names by node ID
   * @type {Array<CreateGraphDtoMetadataNodesInner>}
   * @memberof CreateGraphDtoMetadata
   */
  'nodes'?: Array<CreateGraphDtoMetadataNodesInner>;
  /**
   * Zoom level for graph display
   * @type {number}
   * @memberof CreateGraphDtoMetadata
   */
  'zoom'?: number;
  /**
   * X coordinate
   * @type {number}
   * @memberof CreateGraphDtoMetadata
   */
  'x'?: number;
  /**
   * Y coordinate
   * @type {number}
   * @memberof CreateGraphDtoMetadata
   */
  'y'?: number;
}
/**
 *
 * @export
 * @interface CreateGraphDtoMetadataNodesInner
 */
export interface CreateGraphDtoMetadataNodesInner {
  /**
   *
   * @type {string}
   * @memberof CreateGraphDtoMetadataNodesInner
   */
  'id': string;
  /**
   * X coordinate of the node
   * @type {number}
   * @memberof CreateGraphDtoMetadataNodesInner
   */
  'x'?: number;
  /**
   * Y coordinate of the node
   * @type {number}
   * @memberof CreateGraphDtoMetadataNodesInner
   */
  'y'?: number;
  /**
   * Optional display name for the node
   * @type {string}
   * @memberof CreateGraphDtoMetadataNodesInner
   */
  'name'?: string;
}
/**
 *
 * @export
 * @interface CreateGraphDtoSchema
 */
export interface CreateGraphDtoSchema {
  /**
   *
   * @type {Array<CreateGraphDtoSchemaNodesInner>}
   * @memberof CreateGraphDtoSchema
   */
  'nodes': Array<CreateGraphDtoSchemaNodesInner>;
  /**
   *
   * @type {Array<CreateGraphDtoSchemaEdgesInner>}
   * @memberof CreateGraphDtoSchema
   */
  'edges'?: Array<CreateGraphDtoSchemaEdgesInner>;
}
/**
 *
 * @export
 * @interface CreateGraphDtoSchemaEdgesInner
 */
export interface CreateGraphDtoSchemaEdgesInner {
  /**
   * Source node ID
   * @type {string}
   * @memberof CreateGraphDtoSchemaEdgesInner
   */
  'from': string;
  /**
   * Target node ID
   * @type {string}
   * @memberof CreateGraphDtoSchemaEdgesInner
   */
  'to': string;
  /**
   * Optional edge label
   * @type {string}
   * @memberof CreateGraphDtoSchemaEdgesInner
   */
  'label'?: string;
}
/**
 *
 * @export
 * @interface CreateGraphDtoSchemaNodesInner
 */
export interface CreateGraphDtoSchemaNodesInner {
  /**
   * Unique identifier for this node
   * @type {string}
   * @memberof CreateGraphDtoSchemaNodesInner
   */
  'id': string;
  /**
   * Template id registered in TemplateRegistry
   * @type {string}
   * @memberof CreateGraphDtoSchemaNodesInner
   */
  'template': string;
  /**
   * Template-specific configuration
   * @type {{ [key: string]: any; }}
   * @memberof CreateGraphDtoSchemaNodesInner
   */
  'config': { [key: string]: any };
}
/**
 *
 * @export
 * @interface CreateRepositoryDto
 */
export interface CreateRepositoryDto {
  /**
   * Repository owner
   * @type {string}
   * @memberof CreateRepositoryDto
   */
  'owner': string;
  /**
   * Repository name
   * @type {string}
   * @memberof CreateRepositoryDto
   */
  'repo': string;
  /**
   * HTTPS URL of the repository
   * @type {string}
   * @memberof CreateRepositoryDto
   */
  'url': string;
  /**
   * Git repository host provider
   * @type {string}
   * @memberof CreateRepositoryDto
   */
  'provider'?: CreateRepositoryDtoProviderEnum;
  /**
   * Default branch of the repository (defaults to main)
   * @type {string}
   * @memberof CreateRepositoryDto
   */
  'defaultBranch'?: string;
  /**
   * GitHub personal access token (encrypted at rest, write-only)
   * @type {string}
   * @memberof CreateRepositoryDto
   */
  'token'?: string;
}

export const CreateRepositoryDtoProviderEnum = {
  Github: 'GITHUB',
} as const;

export type CreateRepositoryDtoProviderEnum =
  (typeof CreateRepositoryDtoProviderEnum)[keyof typeof CreateRepositoryDtoProviderEnum];

/**
 *
 * @export
 * @interface ExecuteTriggerDto
 */
export interface ExecuteTriggerDto {
  /**
   * Array of messages to send to the trigger
   * @type {Array<string>}
   * @memberof ExecuteTriggerDto
   */
  'messages': Array<string>;
  /**
   * Optional thread sub-ID that will be used to create the full thread ID.
   * @type {string}
   * @memberof ExecuteTriggerDto
   */
  'threadSubId'?: string;
  /**
   * If true, do not wait for execution to finish (fire-and-forget).
   * @type {boolean}
   * @memberof ExecuteTriggerDto
   */
  'async'?: boolean;
  /**
   * Optional metadata to attach to the thread created by this execution.
   * @type {{ [key: string]: any; }}
   * @memberof ExecuteTriggerDto
   */
  'metadata'?: { [key: string]: any };
}
/**
 *
 * @export
 * @interface ExecuteTriggerResponseDto
 */
export interface ExecuteTriggerResponseDto {
  /**
   * The thread ID used for this execution
   * @type {string}
   * @memberof ExecuteTriggerResponseDto
   */
  'externalThreadId': string;
  /**
   * The checkpoint namespace for this execution
   * @type {string}
   * @memberof ExecuteTriggerResponseDto
   */
  'checkpointNs'?: string;
}
/**
 *
 * @export
 * @interface GetRepoIndexesBranchesParameter
 */
export interface GetRepoIndexesBranchesParameter {}
/**
 *
 * @export
 * @interface GitRepositoryDto
 */
export interface GitRepositoryDto {
  /**
   * Repository ID
   * @type {string}
   * @memberof GitRepositoryDto
   */
  'id': string;
  /**
   * Repository owner (GitHub username or organization)
   * @type {string}
   * @memberof GitRepositoryDto
   */
  'owner': string;
  /**
   * Repository name
   * @type {string}
   * @memberof GitRepositoryDto
   */
  'repo': string;
  /**
   * HTTPS URL of the repository
   * @type {string}
   * @memberof GitRepositoryDto
   */
  'url': string;
  /**
   * Git repository host provider
   * @type {string}
   * @memberof GitRepositoryDto
   */
  'provider': GitRepositoryDtoProviderEnum;
  /**
   * Default branch of the repository (e.g. main, master)
   * @type {string}
   * @memberof GitRepositoryDto
   */
  'defaultBranch': string;
  /**
   * User ID who cloned the repository
   * @type {string}
   * @memberof GitRepositoryDto
   */
  'createdBy': string;
  /**
   *
   * @type {string}
   * @memberof GitRepositoryDto
   */
  'createdAt': string;
  /**
   *
   * @type {string}
   * @memberof GitRepositoryDto
   */
  'updatedAt': string;
}

export const GitRepositoryDtoProviderEnum = {
  Github: 'GITHUB',
} as const;

export type GitRepositoryDtoProviderEnum =
  (typeof GitRepositoryDtoProviderEnum)[keyof typeof GitRepositoryDtoProviderEnum];

/**
 *
 * @export
 * @interface GraphDto
 */
export interface GraphDto {
  /**
   *
   * @type {string}
   * @memberof GraphDto
   */
  'id': string;
  /**
   *
   * @type {string}
   * @memberof GraphDto
   */
  'name': string;
  /**
   *
   * @type {string}
   * @memberof GraphDto
   */
  'description'?: string | null;
  /**
   *
   * @type {string}
   * @memberof GraphDto
   */
  'error'?: string | null;
  /**
   *
   * @type {string}
   * @memberof GraphDto
   */
  'version': string;
  /**
   * Target version after all queued revisions are applied
   * @type {string}
   * @memberof GraphDto
   */
  'targetVersion': string;
  /**
   *
   * @type {CreateGraphDtoSchema}
   * @memberof GraphDto
   */
  'schema': CreateGraphDtoSchema;
  /**
   *
   * @type {string}
   * @memberof GraphDto
   */
  'status': GraphDtoStatusEnum;
  /**
   *
   * @type {CreateGraphDtoMetadata}
   * @memberof GraphDto
   */
  'metadata'?: CreateGraphDtoMetadata | null;
  /**
   * Number of threads currently in running state
   * @type {number}
   * @memberof GraphDto
   */
  'runningThreads'?: number;
  /**
   * Total number of threads for this graph
   * @type {number}
   * @memberof GraphDto
   */
  'totalThreads'?: number;
  /**
   *
   * @type {string}
   * @memberof GraphDto
   */
  'createdAt': string;
  /**
   *
   * @type {string}
   * @memberof GraphDto
   */
  'updatedAt': string;
  /**
   *
   * @type {boolean}
   * @memberof GraphDto
   */
  'temporary'?: boolean | null;
}

export const GraphDtoStatusEnum = {
  Created: 'created',
  Compiling: 'compiling',
  Running: 'running',
  Stopped: 'stopped',
  Error: 'error',
} as const;

export type GraphDtoStatusEnum =
  (typeof GraphDtoStatusEnum)[keyof typeof GraphDtoStatusEnum];

/**
 *
 * @export
 * @interface GraphNodeWithStatusDto
 */
export interface GraphNodeWithStatusDto {
  /**
   * Node ID
   * @type {string}
   * @memberof GraphNodeWithStatusDto
   */
  'id': string;
  /**
   * Display name for node
   * @type {string}
   * @memberof GraphNodeWithStatusDto
   */
  'name': string;
  /**
   * Template identifier
   * @type {string}
   * @memberof GraphNodeWithStatusDto
   */
  'template': string;
  /**
   * Node kind
   * @type {string}
   * @memberof GraphNodeWithStatusDto
   */
  'type': GraphNodeWithStatusDtoTypeEnum;
  /**
   * Current node status
   * @type {string}
   * @memberof GraphNodeWithStatusDto
   */
  'status': GraphNodeWithStatusDtoStatusEnum;
  /**
   *
   * @type {any}
   * @memberof GraphNodeWithStatusDto
   */
  'config': any;
  /**
   *
   * @type {string}
   * @memberof GraphNodeWithStatusDto
   */
  'error'?: string | null;
  /**
   *
   * @type {GraphNodeWithStatusDtoMetadata}
   * @memberof GraphNodeWithStatusDto
   */
  'metadata'?: GraphNodeWithStatusDtoMetadata;
  /**
   * Additional metadata exposed by the node implementation
   * @type {{ [key: string]: any; }}
   * @memberof GraphNodeWithStatusDto
   */
  'additionalNodeMetadata'?: { [key: string]: any };
}

export const GraphNodeWithStatusDtoTypeEnum = {
  Runtime: 'runtime',
  Tool: 'tool',
  SimpleAgent: 'simpleAgent',
  Trigger: 'trigger',
  Resource: 'resource',
  Mcp: 'mcp',
} as const;

export type GraphNodeWithStatusDtoTypeEnum =
  (typeof GraphNodeWithStatusDtoTypeEnum)[keyof typeof GraphNodeWithStatusDtoTypeEnum];
export const GraphNodeWithStatusDtoStatusEnum = {
  Stopped: 'stopped',
  Starting: 'starting',
  Running: 'running',
  Idle: 'idle',
} as const;

export type GraphNodeWithStatusDtoStatusEnum =
  (typeof GraphNodeWithStatusDtoStatusEnum)[keyof typeof GraphNodeWithStatusDtoStatusEnum];

/**
 *
 * @export
 * @interface GraphNodeWithStatusDtoMetadata
 */
export interface GraphNodeWithStatusDtoMetadata {
  /**
   *
   * @type {string}
   * @memberof GraphNodeWithStatusDtoMetadata
   */
  'threadId'?: string;
  /**
   *
   * @type {string}
   * @memberof GraphNodeWithStatusDtoMetadata
   */
  'runId'?: string;
  /**
   *
   * @type {string}
   * @memberof GraphNodeWithStatusDtoMetadata
   */
  'parentThreadId'?: string;
}
/**
 *
 * @export
 * @interface GraphRevisionDto
 */
export interface GraphRevisionDto {
  /**
   *
   * @type {string}
   * @memberof GraphRevisionDto
   */
  'id': string;
  /**
   *
   * @type {string}
   * @memberof GraphRevisionDto
   */
  'graphId': string;
  /**
   * Version the client changes were based on
   * @type {string}
   * @memberof GraphRevisionDto
   */
  'baseVersion': string;
  /**
   * New head version after this revision
   * @type {string}
   * @memberof GraphRevisionDto
   */
  'toVersion': string;
  /**
   * JSON Patch (RFC 6902) operations between old and new schemas
   * @type {Array<UpdateGraphResponseDtoRevisionConfigDiffInner>}
   * @memberof GraphRevisionDto
   */
  'configDiff': Array<UpdateGraphResponseDtoRevisionConfigDiffInner>;
  /**
   *
   * @type {UpdateGraphResponseDtoRevisionClientConfig}
   * @memberof GraphRevisionDto
   */
  'clientConfig': UpdateGraphResponseDtoRevisionClientConfig;
  /**
   *
   * @type {UpdateGraphResponseDtoRevisionNewConfig}
   * @memberof GraphRevisionDto
   */
  'newConfig': UpdateGraphResponseDtoRevisionNewConfig;
  /**
   *
   * @type {string}
   * @memberof GraphRevisionDto
   */
  'status': GraphRevisionDtoStatusEnum;
  /**
   *
   * @type {string}
   * @memberof GraphRevisionDto
   */
  'error'?: string;
  /**
   *
   * @type {string}
   * @memberof GraphRevisionDto
   */
  'createdAt': string;
  /**
   *
   * @type {string}
   * @memberof GraphRevisionDto
   */
  'updatedAt': string;
}

export const GraphRevisionDtoStatusEnum = {
  Pending: 'pending',
  Applying: 'applying',
  Applied: 'applied',
  Failed: 'failed',
} as const;

export type GraphRevisionDtoStatusEnum =
  (typeof GraphRevisionDtoStatusEnum)[keyof typeof GraphRevisionDtoStatusEnum];

/**
 *
 * @export
 * @interface KnowledgeContentSuggestionRequestDto
 */
export interface KnowledgeContentSuggestionRequestDto {
  /**
   * User request describing knowledge content to create or improve
   * @type {string}
   * @memberof KnowledgeContentSuggestionRequestDto
   */
  'userRequest': string;
  /**
   * Optional existing knowledge document title
   * @type {string}
   * @memberof KnowledgeContentSuggestionRequestDto
   */
  'currentTitle'?: string;
  /**
   * Optional existing knowledge document content
   * @type {string}
   * @memberof KnowledgeContentSuggestionRequestDto
   */
  'currentContent'?: string;
  /**
   * Optional existing tags for the knowledge document
   * @type {Array<string>}
   * @memberof KnowledgeContentSuggestionRequestDto
   */
  'currentTags'?: Array<string>;
  /**
   * Optional thread id to continue a previous suggestion conversation
   * @type {string}
   * @memberof KnowledgeContentSuggestionRequestDto
   */
  'threadId'?: string;
  /**
   * Optional LLM model to use for this suggestion
   * @type {string}
   * @memberof KnowledgeContentSuggestionRequestDto
   */
  'model'?: string;
}
/**
 *
 * @export
 * @interface KnowledgeContentSuggestionResponseDto
 */
export interface KnowledgeContentSuggestionResponseDto {
  /**
   * Suggested knowledge document title
   * @type {string}
   * @memberof KnowledgeContentSuggestionResponseDto
   */
  'title': string;
  /**
   * Suggested knowledge document content
   * @type {string}
   * @memberof KnowledgeContentSuggestionResponseDto
   */
  'content': string;
  /**
   * Suggested tags for the knowledge document
   * @type {Array<string>}
   * @memberof KnowledgeContentSuggestionResponseDto
   */
  'tags'?: Array<string>;
  /**
   * Thread id used for this suggestion session
   * @type {string}
   * @memberof KnowledgeContentSuggestionResponseDto
   */
  'threadId': string;
}
/**
 *
 * @export
 * @interface KnowledgeDocCreateDto
 */
export interface KnowledgeDocCreateDto {
  /**
   * Knowledge document title
   * @type {string}
   * @memberof KnowledgeDocCreateDto
   */
  'title': string;
  /**
   * Raw knowledge document content
   * @type {string}
   * @memberof KnowledgeDocCreateDto
   */
  'content': string;
  /**
   *
   * @type {string}
   * @memberof KnowledgeDocCreateDto
   */
  'politic'?: string | null;
  /**
   *
   * @type {Array<string>}
   * @memberof KnowledgeDocCreateDto
   */
  'tags'?: Array<string> | null;
}
/**
 *
 * @export
 * @interface KnowledgeDocDto
 */
export interface KnowledgeDocDto {
  /**
   *
   * @type {string}
   * @memberof KnowledgeDocDto
   */
  'id': string;
  /**
   *
   * @type {number}
   * @memberof KnowledgeDocDto
   */
  'publicId': number;
  /**
   *
   * @type {string}
   * @memberof KnowledgeDocDto
   */
  'content': string;
  /**
   *
   * @type {string}
   * @memberof KnowledgeDocDto
   */
  'title': string;
  /**
   *
   * @type {string}
   * @memberof KnowledgeDocDto
   */
  'summary'?: string | null;
  /**
   *
   * @type {string}
   * @memberof KnowledgeDocDto
   */
  'politic'?: string | null;
  /**
   *
   * @type {string}
   * @memberof KnowledgeDocDto
   */
  'embeddingModel'?: string | null;
  /**
   *
   * @type {Array<string>}
   * @memberof KnowledgeDocDto
   */
  'tags': Array<string>;
  /**
   *
   * @type {string}
   * @memberof KnowledgeDocDto
   */
  'createdAt': string;
  /**
   *
   * @type {string}
   * @memberof KnowledgeDocDto
   */
  'updatedAt': string;
}
/**
 *
 * @export
 * @interface KnowledgeDocUpdateDto
 */
export interface KnowledgeDocUpdateDto {
  /**
   * Knowledge document title
   * @type {string}
   * @memberof KnowledgeDocUpdateDto
   */
  'title'?: string;
  /**
   * Raw knowledge document content
   * @type {string}
   * @memberof KnowledgeDocUpdateDto
   */
  'content'?: string;
  /**
   *
   * @type {string}
   * @memberof KnowledgeDocUpdateDto
   */
  'politic'?: string | null;
  /**
   *
   * @type {Array<string>}
   * @memberof KnowledgeDocUpdateDto
   */
  'tags'?: Array<string> | null;
}
/**
 *
 * @export
 * @interface LinkInstallationResponseDto
 */
export interface LinkInstallationResponseDto {
  /**
   * Whether the installation was successfully linked
   * @type {boolean}
   * @memberof LinkInstallationResponseDto
   */
  'linked': boolean;
  /**
   * GitHub org/user login where the app is installed
   * @type {string}
   * @memberof LinkInstallationResponseDto
   */
  'accountLogin': string;
  /**
   * Account type: Organization or User
   * @type {string}
   * @memberof LinkInstallationResponseDto
   */
  'accountType': string;
}
/**
 *
 * @export
 * @interface ListInstallationsResponseDto
 */
export interface ListInstallationsResponseDto {
  /**
   *
   * @type {Array<ListInstallationsResponseDtoInstallationsInner>}
   * @memberof ListInstallationsResponseDto
   */
  'installations': Array<ListInstallationsResponseDtoInstallationsInner>;
}
/**
 *
 * @export
 * @interface ListInstallationsResponseDtoInstallationsInner
 */
export interface ListInstallationsResponseDtoInstallationsInner {
  /**
   * Installation record ID
   * @type {string}
   * @memberof ListInstallationsResponseDtoInstallationsInner
   */
  'id': string;
  /**
   * GitHub installation ID
   * @type {number}
   * @memberof ListInstallationsResponseDtoInstallationsInner
   */
  'installationId': number;
  /**
   * GitHub org/user login
   * @type {string}
   * @memberof ListInstallationsResponseDtoInstallationsInner
   */
  'accountLogin': string;
  /**
   * Account type: Organization or User
   * @type {string}
   * @memberof ListInstallationsResponseDtoInstallationsInner
   */
  'accountType': string;
  /**
   * Whether the installation is active
   * @type {boolean}
   * @memberof ListInstallationsResponseDtoInstallationsInner
   */
  'isActive': boolean;
  /**
   *
   * @type {string}
   * @memberof ListInstallationsResponseDtoInstallationsInner
   */
  'createdAt': string;
}
/**
 *
 * @export
 * @interface LiteLlmModelDto
 */
export interface LiteLlmModelDto {
  /**
   * Model identifier
   * @type {string}
   * @memberof LiteLlmModelDto
   */
  'id': string;
  /**
   * Owner of the model
   * @type {string}
   * @memberof LiteLlmModelDto
   */
  'ownedBy': string;
}
/**
 *
 * @export
 * @interface OAuthLinkRequestDto
 */
export interface OAuthLinkRequestDto {
  /**
   * GitHub OAuth authorization code
   * @type {string}
   * @memberof OAuthLinkRequestDto
   */
  'code': string;
}
/**
 *
 * @export
 * @interface RepoIndexDto
 */
export interface RepoIndexDto {
  /**
   * Index ID
   * @type {string}
   * @memberof RepoIndexDto
   */
  'id': string;
  /**
   * Repository ID
   * @type {string}
   * @memberof RepoIndexDto
   */
  'repositoryId': string;
  /**
   * Repository URL
   * @type {string}
   * @memberof RepoIndexDto
   */
  'repoUrl': string;
  /**
   * Git branch name this index covers
   * @type {string}
   * @memberof RepoIndexDto
   */
  'branch': string;
  /**
   * Indexing status
   * @type {string}
   * @memberof RepoIndexDto
   */
  'status': RepoIndexDtoStatusEnum;
  /**
   * Qdrant collection name
   * @type {string}
   * @memberof RepoIndexDto
   */
  'qdrantCollection': string;
  /**
   *
   * @type {string}
   * @memberof RepoIndexDto
   */
  'lastIndexedCommit': string | null;
  /**
   *
   * @type {string}
   * @memberof RepoIndexDto
   */
  'embeddingModel': string | null;
  /**
   *
   * @type {number}
   * @memberof RepoIndexDto
   */
  'vectorSize': number | null;
  /**
   *
   * @type {string}
   * @memberof RepoIndexDto
   */
  'chunkingSignatureHash': string | null;
  /**
   * Estimated token count
   * @type {number}
   * @memberof RepoIndexDto
   */
  'estimatedTokens': number;
  /**
   * Actual indexed tokens
   * @type {number}
   * @memberof RepoIndexDto
   */
  'indexedTokens': number;
  /**
   *
   * @type {string}
   * @memberof RepoIndexDto
   */
  'errorMessage': string | null;
  /**
   *
   * @type {string}
   * @memberof RepoIndexDto
   */
  'createdAt': string;
  /**
   *
   * @type {string}
   * @memberof RepoIndexDto
   */
  'updatedAt': string;
}

export const RepoIndexDtoStatusEnum = {
  Pending: 'pending',
  InProgress: 'in_progress',
  Completed: 'completed',
  Failed: 'failed',
} as const;

export type RepoIndexDtoStatusEnum =
  (typeof RepoIndexDtoStatusEnum)[keyof typeof RepoIndexDtoStatusEnum];

/**
 *
 * @export
 * @interface RuntimeInstanceDto
 */
export interface RuntimeInstanceDto {
  /**
   * Runtime instance ID
   * @type {string}
   * @memberof RuntimeInstanceDto
   */
  'id': string;
  /**
   * Graph ID
   * @type {string}
   * @memberof RuntimeInstanceDto
   */
  'graphId': string;
  /**
   * Node ID
   * @type {string}
   * @memberof RuntimeInstanceDto
   */
  'nodeId': string;
  /**
   * External thread ID (graphId:threadUUID)
   * @type {string}
   * @memberof RuntimeInstanceDto
   */
  'externalThreadId': string;
  /**
   * Runtime type
   * @type {string}
   * @memberof RuntimeInstanceDto
   */
  'type': RuntimeInstanceDtoTypeEnum;
  /**
   * Runtime instance status
   * @type {string}
   * @memberof RuntimeInstanceDto
   */
  'status': RuntimeInstanceDtoStatusEnum;
  /**
   * Container name
   * @type {string}
   * @memberof RuntimeInstanceDto
   */
  'containerName': string;
  /**
   * Last used timestamp
   * @type {string}
   * @memberof RuntimeInstanceDto
   */
  'lastUsedAt': string;
  /**
   * Creation timestamp
   * @type {string}
   * @memberof RuntimeInstanceDto
   */
  'createdAt': string;
  /**
   * Last update timestamp
   * @type {string}
   * @memberof RuntimeInstanceDto
   */
  'updatedAt': string;
}

export const RuntimeInstanceDtoTypeEnum = {
  Docker: 'Docker',
  Daytona: 'Daytona',
} as const;

export type RuntimeInstanceDtoTypeEnum =
  (typeof RuntimeInstanceDtoTypeEnum)[keyof typeof RuntimeInstanceDtoTypeEnum];
export const RuntimeInstanceDtoStatusEnum = {
  Starting: 'Starting',
  Running: 'Running',
  Stopping: 'Stopping',
  Stopped: 'Stopped',
  Failed: 'Failed',
} as const;

export type RuntimeInstanceDtoStatusEnum =
  (typeof RuntimeInstanceDtoStatusEnum)[keyof typeof RuntimeInstanceDtoStatusEnum];

/**
 *
 * @export
 * @interface SetThreadMetadataDto
 */
export interface SetThreadMetadataDto {
  /**
   * Thread metadata to set (replaces existing metadata)
   * @type {{ [key: string]: any; }}
   * @memberof SetThreadMetadataDto
   */
  'metadata': { [key: string]: any };
}
/**
 *
 * @export
 * @interface SetupInfoResponseDto
 */
export interface SetupInfoResponseDto {
  /**
   * URL to redirect the user to for GitHub App installation
   * @type {string}
   * @memberof SetupInfoResponseDto
   */
  'installUrl': string;
  /**
   * Whether the GitHub App is fully configured
   * @type {boolean}
   * @memberof SetupInfoResponseDto
   */
  'configured': boolean;
  /**
   * Path the user must set as \"Setup URL\" in their GitHub App settings (append to their domain)
   * @type {string}
   * @memberof SetupInfoResponseDto
   */
  'callbackPath': string;
}
/**
 *
 * @export
 * @interface SuggestAgentInstructionsDto
 */
export interface SuggestAgentInstructionsDto {
  /**
   * User request describing how to adjust agent instructions
   * @type {string}
   * @memberof SuggestAgentInstructionsDto
   */
  'userRequest': string;
  /**
   * Optional thread id to continue a previous suggestion conversation
   * @type {string}
   * @memberof SuggestAgentInstructionsDto
   */
  'threadId'?: string;
  /**
   * Optional LLM model to use for this suggestion
   * @type {string}
   * @memberof SuggestAgentInstructionsDto
   */
  'model'?: string;
}
/**
 *
 * @export
 * @interface SuggestAgentInstructionsResponseDto
 */
export interface SuggestAgentInstructionsResponseDto {
  /**
   * Updated agent instructions generated by the LLM
   * @type {string}
   * @memberof SuggestAgentInstructionsResponseDto
   */
  'instructions': string;
  /**
   * Thread id used for this suggestion session
   * @type {string}
   * @memberof SuggestAgentInstructionsResponseDto
   */
  'threadId': string;
}
/**
 *
 * @export
 * @interface SuggestGraphInstructionsDto
 */
export interface SuggestGraphInstructionsDto {
  /**
   * User request describing how to adjust agent instructions
   * @type {string}
   * @memberof SuggestGraphInstructionsDto
   */
  'userRequest': string;
  /**
   * Optional LLM model to use for this suggestion
   * @type {string}
   * @memberof SuggestGraphInstructionsDto
   */
  'model'?: string;
}
/**
 *
 * @export
 * @interface SuggestGraphInstructionsResponseDto
 */
export interface SuggestGraphInstructionsResponseDto {
  /**
   * Only agents with changed instructions are returned
   * @type {Array<SuggestGraphInstructionsResponseDtoUpdatesInner>}
   * @memberof SuggestGraphInstructionsResponseDto
   */
  'updates': Array<SuggestGraphInstructionsResponseDtoUpdatesInner>;
}
/**
 *
 * @export
 * @interface SuggestGraphInstructionsResponseDtoUpdatesInner
 */
export interface SuggestGraphInstructionsResponseDtoUpdatesInner {
  /**
   * Agent node id
   * @type {string}
   * @memberof SuggestGraphInstructionsResponseDtoUpdatesInner
   */
  'nodeId': string;
  /**
   * Agent display name
   * @type {string}
   * @memberof SuggestGraphInstructionsResponseDtoUpdatesInner
   */
  'name'?: string;
  /**
   * Updated agent instructions generated by the LLM
   * @type {string}
   * @memberof SuggestGraphInstructionsResponseDtoUpdatesInner
   */
  'instructions': string;
}
/**
 *
 * @export
 * @interface SystemSettingsResponseDto
 */
export interface SystemSettingsResponseDto {
  /**
   * Whether the GitHub App integration is configured and available
   * @type {boolean}
   * @memberof SystemSettingsResponseDto
   */
  'githubAppEnabled': boolean;
}
/**
 *
 * @export
 * @interface TemplateDto
 */
export interface TemplateDto {
  /**
   *
   * @type {string}
   * @memberof TemplateDto
   */
  'id': string;
  /**
   *
   * @type {string}
   * @memberof TemplateDto
   */
  'name': string;
  /**
   *
   * @type {string}
   * @memberof TemplateDto
   */
  'description': string;
  /**
   *
   * @type {string}
   * @memberof TemplateDto
   */
  'kind': TemplateDtoKindEnum;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof TemplateDto
   */
  'schema': { [key: string]: any };
  /**
   *
   * @type {Array<TemplateDtoInputsInner>}
   * @memberof TemplateDto
   */
  'inputs'?: Array<TemplateDtoInputsInner>;
  /**
   *
   * @type {Array<TemplateDtoInputsInner>}
   * @memberof TemplateDto
   */
  'outputs'?: Array<TemplateDtoInputsInner>;
}

export const TemplateDtoKindEnum = {
  Runtime: 'runtime',
  Tool: 'tool',
  SimpleAgent: 'simpleAgent',
  Trigger: 'trigger',
  Resource: 'resource',
  Mcp: 'mcp',
} as const;

export type TemplateDtoKindEnum =
  (typeof TemplateDtoKindEnum)[keyof typeof TemplateDtoKindEnum];

/**
 * @type TemplateDtoInputsInner
 * @export
 */
export type TemplateDtoInputsInner =
  | TemplateDtoInputsInnerOneOf
  | TemplateDtoInputsInnerOneOf1;

/**
 *
 * @export
 * @interface TemplateDtoInputsInnerOneOf
 */
export interface TemplateDtoInputsInnerOneOf {
  /**
   *
   * @type {string}
   * @memberof TemplateDtoInputsInnerOneOf
   */
  'type': TemplateDtoInputsInnerOneOfTypeEnum;
  /**
   *
   * @type {string}
   * @memberof TemplateDtoInputsInnerOneOf
   */
  'value': TemplateDtoInputsInnerOneOfValueEnum;
  /**
   *
   * @type {boolean}
   * @memberof TemplateDtoInputsInnerOneOf
   */
  'required'?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof TemplateDtoInputsInnerOneOf
   */
  'multiple': boolean;
}

export const TemplateDtoInputsInnerOneOfTypeEnum = {
  Kind: 'kind',
} as const;

export type TemplateDtoInputsInnerOneOfTypeEnum =
  (typeof TemplateDtoInputsInnerOneOfTypeEnum)[keyof typeof TemplateDtoInputsInnerOneOfTypeEnum];
export const TemplateDtoInputsInnerOneOfValueEnum = {
  Runtime: 'runtime',
  Tool: 'tool',
  SimpleAgent: 'simpleAgent',
  Trigger: 'trigger',
  Resource: 'resource',
  Mcp: 'mcp',
} as const;

export type TemplateDtoInputsInnerOneOfValueEnum =
  (typeof TemplateDtoInputsInnerOneOfValueEnum)[keyof typeof TemplateDtoInputsInnerOneOfValueEnum];

/**
 *
 * @export
 * @interface TemplateDtoInputsInnerOneOf1
 */
export interface TemplateDtoInputsInnerOneOf1 {
  /**
   *
   * @type {string}
   * @memberof TemplateDtoInputsInnerOneOf1
   */
  'type': TemplateDtoInputsInnerOneOf1TypeEnum;
  /**
   *
   * @type {string}
   * @memberof TemplateDtoInputsInnerOneOf1
   */
  'value': string;
  /**
   *
   * @type {boolean}
   * @memberof TemplateDtoInputsInnerOneOf1
   */
  'required'?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof TemplateDtoInputsInnerOneOf1
   */
  'multiple': boolean;
}

export const TemplateDtoInputsInnerOneOf1TypeEnum = {
  Template: 'template',
} as const;

export type TemplateDtoInputsInnerOneOf1TypeEnum =
  (typeof TemplateDtoInputsInnerOneOf1TypeEnum)[keyof typeof TemplateDtoInputsInnerOneOf1TypeEnum];

/**
 *
 * @export
 * @interface ThreadAnalysisRequestDto
 */
export interface ThreadAnalysisRequestDto {
  /**
   * Optional user-provided input to guide the analysis
   * @type {string}
   * @memberof ThreadAnalysisRequestDto
   */
  'userInput'?: string;
  /**
   * Optional LLM conversation id to continue the existing suggestion thread
   * @type {string}
   * @memberof ThreadAnalysisRequestDto
   */
  'threadId'?: string;
  /**
   * Optional LLM model to use for this analysis
   * @type {string}
   * @memberof ThreadAnalysisRequestDto
   */
  'model'?: string;
}
/**
 *
 * @export
 * @interface ThreadAnalysisResponseDto
 */
export interface ThreadAnalysisResponseDto {
  /**
   * LLM-generated analysis and improvement suggestions
   * @type {string}
   * @memberof ThreadAnalysisResponseDto
   */
  'analysis': string;
  /**
   * Identifier of the LLM conversation used for the analysis
   * @type {string}
   * @memberof ThreadAnalysisResponseDto
   */
  'conversationId': string;
}
/**
 *
 * @export
 * @interface ThreadDto
 */
export interface ThreadDto {
  /**
   * Thread ID
   * @type {string}
   * @memberof ThreadDto
   */
  'id': string;
  /**
   * Graph ID
   * @type {string}
   * @memberof ThreadDto
   */
  'graphId': string;
  /**
   * External thread ID from LangChain
   * @type {string}
   * @memberof ThreadDto
   */
  'externalThreadId': string;
  /**
   *
   * @type {string}
   * @memberof ThreadDto
   */
  'lastRunId'?: string | null;
  /**
   *
   * @type {string}
   * @memberof ThreadDto
   */
  'createdAt': string;
  /**
   *
   * @type {string}
   * @memberof ThreadDto
   */
  'updatedAt': string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof ThreadDto
   */
  'metadata'?: { [key: string]: any } | null;
  /**
   *
   * @type {string}
   * @memberof ThreadDto
   */
  'source'?: string | null;
  /**
   *
   * @type {string}
   * @memberof ThreadDto
   */
  'name'?: string | null;
  /**
   * Thread execution status
   * @type {string}
   * @memberof ThreadDto
   */
  'status': ThreadDtoStatusEnum;
}

export const ThreadDtoStatusEnum = {
  Running: 'running',
  Done: 'done',
  NeedMoreInfo: 'need_more_info',
  Stopped: 'stopped',
} as const;

export type ThreadDtoStatusEnum =
  (typeof ThreadDtoStatusEnum)[keyof typeof ThreadDtoStatusEnum];

/**
 *
 * @export
 * @interface ThreadMessageDto
 */
export interface ThreadMessageDto {
  /**
   *
   * @type {string}
   * @memberof ThreadMessageDto
   */
  'id': string;
  /**
   *
   * @type {string}
   * @memberof ThreadMessageDto
   */
  'threadId': string;
  /**
   *
   * @type {string}
   * @memberof ThreadMessageDto
   */
  'nodeId': string;
  /**
   *
   * @type {string}
   * @memberof ThreadMessageDto
   */
  'externalThreadId': string;
  /**
   *
   * @type {string}
   * @memberof ThreadMessageDto
   */
  'createdAt': string;
  /**
   *
   * @type {string}
   * @memberof ThreadMessageDto
   */
  'updatedAt': string;
  /**
   *
   * @type {ThreadMessageDtoMessage}
   * @memberof ThreadMessageDto
   */
  'message': ThreadMessageDtoMessage;
  /**
   *
   * @type {ThreadMessageDtoRequestTokenUsage}
   * @memberof ThreadMessageDto
   */
  'requestTokenUsage'?: ThreadMessageDtoRequestTokenUsage | null;
  /**
   *
   * @type {ThreadMessageDtoRequestTokenUsage}
   * @memberof ThreadMessageDto
   */
  'toolTokenUsage'?: ThreadMessageDtoRequestTokenUsage | null;
}
/**
 * @type ThreadMessageDtoMessage
 * @export
 */
export type ThreadMessageDtoMessage =
  | ThreadMessageDtoMessageOneOf
  | ThreadMessageDtoMessageOneOf1
  | ThreadMessageDtoMessageOneOf2
  | ThreadMessageDtoMessageOneOf3
  | ThreadMessageDtoMessageOneOf4;

/**
 *
 * @export
 * @interface ThreadMessageDtoMessageOneOf
 */
export interface ThreadMessageDtoMessageOneOf {
  /**
   * Message role
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf
   */
  'role': ThreadMessageDtoMessageOneOfRoleEnum;
  /**
   * Message content
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf
   */
  'content': string;
  /**
   *
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf
   */
  'runId'?: string | null;
  /**
   * Additional message metadata
   * @type {{ [key: string]: any; }}
   * @memberof ThreadMessageDtoMessageOneOf
   */
  'additionalKwargs'?: { [key: string]: any };
}

export const ThreadMessageDtoMessageOneOfRoleEnum = {
  Human: 'human',
} as const;

export type ThreadMessageDtoMessageOneOfRoleEnum =
  (typeof ThreadMessageDtoMessageOneOfRoleEnum)[keyof typeof ThreadMessageDtoMessageOneOfRoleEnum];

/**
 *
 * @export
 * @interface ThreadMessageDtoMessageOneOf1
 */
export interface ThreadMessageDtoMessageOneOf1 {
  /**
   * Message role
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf1
   */
  'role': ThreadMessageDtoMessageOneOf1RoleEnum;
  /**
   * Message content
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf1
   */
  'content': string;
  /**
   * Message ID
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf1
   */
  'id'?: string;
  /**
   *
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf1
   */
  'runId'?: string | null;
  /**
   *
   * @type {any}
   * @memberof ThreadMessageDtoMessageOneOf1
   */
  'rawContent'?: any;
  /**
   * Tool calls in the message
   * @type {Array<ThreadMessageDtoMessageOneOf1ToolCallsInner>}
   * @memberof ThreadMessageDtoMessageOneOf1
   */
  'toolCalls'?: Array<ThreadMessageDtoMessageOneOf1ToolCallsInner>;
  /**
   * Additional message metadata
   * @type {{ [key: string]: any; }}
   * @memberof ThreadMessageDtoMessageOneOf1
   */
  'additionalKwargs'?: { [key: string]: any };
}

export const ThreadMessageDtoMessageOneOf1RoleEnum = {
  Ai: 'ai',
} as const;

export type ThreadMessageDtoMessageOneOf1RoleEnum =
  (typeof ThreadMessageDtoMessageOneOf1RoleEnum)[keyof typeof ThreadMessageDtoMessageOneOf1RoleEnum];

/**
 *
 * @export
 * @interface ThreadMessageDtoMessageOneOf1ToolCallsInner
 */
export interface ThreadMessageDtoMessageOneOf1ToolCallsInner {
  /**
   * Tool name
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf1ToolCallsInner
   */
  'name': string;
  /**
   * Tool arguments
   * @type {{ [key: string]: any; }}
   * @memberof ThreadMessageDtoMessageOneOf1ToolCallsInner
   */
  'args': { [key: string]: any };
  /**
   * Tool call type
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf1ToolCallsInner
   */
  'type': string;
  /**
   * Tool call ID
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf1ToolCallsInner
   */
  'id': string;
  /**
   * Optional human-readable tool call title
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf1ToolCallsInner
   */
  'title'?: string;
}
/**
 *
 * @export
 * @interface ThreadMessageDtoMessageOneOf2
 */
export interface ThreadMessageDtoMessageOneOf2 {
  /**
   * Message ID
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf2
   */
  'id'?: string;
  /**
   * Message role
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf2
   */
  'role': ThreadMessageDtoMessageOneOf2RoleEnum;
  /**
   * Reasoning trace emitted by the model
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf2
   */
  'content': string;
  /**
   *
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf2
   */
  'runId'?: string | null;
  /**
   * Additional message metadata
   * @type {{ [key: string]: any; }}
   * @memberof ThreadMessageDtoMessageOneOf2
   */
  'additionalKwargs'?: { [key: string]: any };
}

export const ThreadMessageDtoMessageOneOf2RoleEnum = {
  Reasoning: 'reasoning',
} as const;

export type ThreadMessageDtoMessageOneOf2RoleEnum =
  (typeof ThreadMessageDtoMessageOneOf2RoleEnum)[keyof typeof ThreadMessageDtoMessageOneOf2RoleEnum];

/**
 *
 * @export
 * @interface ThreadMessageDtoMessageOneOf3
 */
export interface ThreadMessageDtoMessageOneOf3 {
  /**
   * Message role
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf3
   */
  'role': ThreadMessageDtoMessageOneOf3RoleEnum;
  /**
   * Message content
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf3
   */
  'content': string;
  /**
   *
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf3
   */
  'runId'?: string | null;
  /**
   * Additional message metadata
   * @type {{ [key: string]: any; }}
   * @memberof ThreadMessageDtoMessageOneOf3
   */
  'additionalKwargs'?: { [key: string]: any };
}

export const ThreadMessageDtoMessageOneOf3RoleEnum = {
  System: 'system',
} as const;

export type ThreadMessageDtoMessageOneOf3RoleEnum =
  (typeof ThreadMessageDtoMessageOneOf3RoleEnum)[keyof typeof ThreadMessageDtoMessageOneOf3RoleEnum];

/**
 *
 * @export
 * @interface ThreadMessageDtoMessageOneOf4
 */
export interface ThreadMessageDtoMessageOneOf4 {
  /**
   * Message role
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf4
   */
  'role': ThreadMessageDtoMessageOneOf4RoleEnum;
  /**
   * Tool name
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf4
   */
  'name': string;
  /**
   * Parsed tool result as JSON
   * @type {{ [key: string]: any; }}
   * @memberof ThreadMessageDtoMessageOneOf4
   */
  'content': { [key: string]: any };
  /**
   * Tool call ID
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf4
   */
  'toolCallId': string;
  /**
   *
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf4
   */
  'runId'?: string | null;
  /**
   * Optional human-readable tool call title
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf4
   */
  'title'?: string;
  /**
   * Additional message metadata
   * @type {{ [key: string]: any; }}
   * @memberof ThreadMessageDtoMessageOneOf4
   */
  'additionalKwargs'?: { [key: string]: any };
}

export const ThreadMessageDtoMessageOneOf4RoleEnum = {
  Tool: 'tool',
} as const;

export type ThreadMessageDtoMessageOneOf4RoleEnum =
  (typeof ThreadMessageDtoMessageOneOf4RoleEnum)[keyof typeof ThreadMessageDtoMessageOneOf4RoleEnum];

/**
 *
 * @export
 * @interface ThreadMessageDtoRequestTokenUsage
 */
export interface ThreadMessageDtoRequestTokenUsage {
  /**
   * Input tokens
   * @type {number}
   * @memberof ThreadMessageDtoRequestTokenUsage
   */
  'inputTokens': number;
  /**
   * Cached input tokens
   * @type {number}
   * @memberof ThreadMessageDtoRequestTokenUsage
   */
  'cachedInputTokens'?: number;
  /**
   * Output tokens
   * @type {number}
   * @memberof ThreadMessageDtoRequestTokenUsage
   */
  'outputTokens': number;
  /**
   * Reasoning tokens
   * @type {number}
   * @memberof ThreadMessageDtoRequestTokenUsage
   */
  'reasoningTokens'?: number;
  /**
   * Total tokens
   * @type {number}
   * @memberof ThreadMessageDtoRequestTokenUsage
   */
  'totalTokens': number;
  /**
   * Total price in USD
   * @type {number}
   * @memberof ThreadMessageDtoRequestTokenUsage
   */
  'totalPrice'?: number;
  /**
   * Current context size in tokens (snapshot, not additive)
   * @type {number}
   * @memberof ThreadMessageDtoRequestTokenUsage
   */
  'currentContext'?: number;
}
/**
 *
 * @export
 * @interface ThreadUsageStatisticsDto
 */
export interface ThreadUsageStatisticsDto {
  /**
   *
   * @type {ThreadUsageStatisticsDtoTotal}
   * @memberof ThreadUsageStatisticsDto
   */
  'total': ThreadUsageStatisticsDtoTotal;
  /**
   * Total number of requests (messages with requestTokenUsage)
   * @type {number}
   * @memberof ThreadUsageStatisticsDto
   */
  'requests': number;
  /**
   * Usage statistics breakdown by node ID
   * @type {{ [key: string]: ThreadUsageStatisticsDtoByNodeValue; }}
   * @memberof ThreadUsageStatisticsDto
   */
  'byNode': { [key: string]: ThreadUsageStatisticsDtoByNodeValue };
  /**
   * Usage statistics breakdown by tool name
   * @type {Array<ThreadUsageStatisticsDtoSchema0>}
   * @memberof ThreadUsageStatisticsDto
   */
  'byTool': Array<ThreadUsageStatisticsDtoSchema0>;
  /**
   *
   * @type {ThreadUsageStatisticsDtoToolsAggregate}
   * @memberof ThreadUsageStatisticsDto
   */
  'toolsAggregate': ThreadUsageStatisticsDtoToolsAggregate;
  /**
   * Number of user (human) messages in the thread
   * @type {number}
   * @memberof ThreadUsageStatisticsDto
   */
  'userMessageCount': number;
}
/**
 *
 * @export
 * @interface ThreadUsageStatisticsDtoByNodeValue
 */
export interface ThreadUsageStatisticsDtoByNodeValue {
  /**
   * Input tokens
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoByNodeValue
   */
  'inputTokens': number;
  /**
   * Cached input tokens
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoByNodeValue
   */
  'cachedInputTokens'?: number;
  /**
   * Output tokens
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoByNodeValue
   */
  'outputTokens': number;
  /**
   * Reasoning tokens
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoByNodeValue
   */
  'reasoningTokens'?: number;
  /**
   * Total tokens
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoByNodeValue
   */
  'totalTokens': number;
  /**
   * Total price in USD
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoByNodeValue
   */
  'totalPrice'?: number;
  /**
   * Current context size in tokens (snapshot, not additive)
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoByNodeValue
   */
  'currentContext'?: number;
}
/**
 *
 * @export
 * @interface ThreadUsageStatisticsDtoSchema0
 */
export interface ThreadUsageStatisticsDtoSchema0 {
  /**
   * Tool name
   * @type {string}
   * @memberof ThreadUsageStatisticsDtoSchema0
   */
  'toolName': string;
  /**
   * Total tokens from LLM requests related to this tool
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoSchema0
   */
  'totalTokens': number;
  /**
   * Total price from LLM requests related to this tool in USD
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoSchema0
   */
  'totalPrice'?: number;
  /**
   * Number of times this tool was called
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoSchema0
   */
  'callCount': number;
  /**
   * Tool\'s own execution token cost (e.g. subagent aggregate tokens)
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoSchema0
   */
  'toolTokens'?: number;
  /**
   * Tool\'s own execution price in USD
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoSchema0
   */
  'toolPrice'?: number;
  /**
   * Sub-tool calls made within this tool (e.g. tools called by a subagent)
   * @type {Array<ThreadUsageStatisticsDtoSchema0>}
   * @memberof ThreadUsageStatisticsDtoSchema0
   */
  'subCalls'?: Array<ThreadUsageStatisticsDtoSchema0>;
}
/**
 * Aggregated statistics for all tool-related LLM requests
 * @export
 * @interface ThreadUsageStatisticsDtoToolsAggregate
 */
export interface ThreadUsageStatisticsDtoToolsAggregate {
  /**
   * Input tokens
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoToolsAggregate
   */
  'inputTokens': number;
  /**
   * Cached input tokens
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoToolsAggregate
   */
  'cachedInputTokens'?: number;
  /**
   * Output tokens
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoToolsAggregate
   */
  'outputTokens': number;
  /**
   * Reasoning tokens
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoToolsAggregate
   */
  'reasoningTokens'?: number;
  /**
   * Total tokens
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoToolsAggregate
   */
  'totalTokens': number;
  /**
   * Total price in USD
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoToolsAggregate
   */
  'totalPrice'?: number;
  /**
   * Current context size in tokens (snapshot, not additive)
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoToolsAggregate
   */
  'currentContext'?: number;
  /**
   * Number of requests (messages with requestTokenUsage)
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoToolsAggregate
   */
  'requestCount': number;
}
/**
 * Total usage statistics for the entire thread
 * @export
 * @interface ThreadUsageStatisticsDtoTotal
 */
export interface ThreadUsageStatisticsDtoTotal {
  /**
   * Input tokens
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoTotal
   */
  'inputTokens': number;
  /**
   * Cached input tokens
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoTotal
   */
  'cachedInputTokens'?: number;
  /**
   * Output tokens
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoTotal
   */
  'outputTokens': number;
  /**
   * Reasoning tokens
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoTotal
   */
  'reasoningTokens'?: number;
  /**
   * Total tokens
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoTotal
   */
  'totalTokens': number;
  /**
   * Total price in USD
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoTotal
   */
  'totalPrice'?: number;
  /**
   * Current context size in tokens (snapshot, not additive)
   * @type {number}
   * @memberof ThreadUsageStatisticsDtoTotal
   */
  'currentContext'?: number;
}
/**
 *
 * @export
 * @interface TriggerReindexDto
 */
export interface TriggerReindexDto {
  /**
   * Repository ID to reindex
   * @type {string}
   * @memberof TriggerReindexDto
   */
  'repositoryId': string;
  /**
   * Branch to reindex. Defaults to the repository default branch (main).
   * @type {string}
   * @memberof TriggerReindexDto
   */
  'branch'?: string;
}
/**
 *
 * @export
 * @interface TriggerReindexResponseDto
 */
export interface TriggerReindexResponseDto {
  /**
   *
   * @type {TriggerReindexResponseDtoRepoIndex}
   * @memberof TriggerReindexResponseDto
   */
  'repoIndex': TriggerReindexResponseDtoRepoIndex;
  /**
   * Human-readable status message
   * @type {string}
   * @memberof TriggerReindexResponseDto
   */
  'message': string;
}
/**
 *
 * @export
 * @interface TriggerReindexResponseDtoRepoIndex
 */
export interface TriggerReindexResponseDtoRepoIndex {
  /**
   * Index ID
   * @type {string}
   * @memberof TriggerReindexResponseDtoRepoIndex
   */
  'id': string;
  /**
   * Repository ID
   * @type {string}
   * @memberof TriggerReindexResponseDtoRepoIndex
   */
  'repositoryId': string;
  /**
   * Repository URL
   * @type {string}
   * @memberof TriggerReindexResponseDtoRepoIndex
   */
  'repoUrl': string;
  /**
   * Git branch name this index covers
   * @type {string}
   * @memberof TriggerReindexResponseDtoRepoIndex
   */
  'branch': string;
  /**
   * Indexing status
   * @type {string}
   * @memberof TriggerReindexResponseDtoRepoIndex
   */
  'status': TriggerReindexResponseDtoRepoIndexStatusEnum;
  /**
   * Qdrant collection name
   * @type {string}
   * @memberof TriggerReindexResponseDtoRepoIndex
   */
  'qdrantCollection': string;
  /**
   *
   * @type {string}
   * @memberof TriggerReindexResponseDtoRepoIndex
   */
  'lastIndexedCommit': string | null;
  /**
   *
   * @type {string}
   * @memberof TriggerReindexResponseDtoRepoIndex
   */
  'embeddingModel': string | null;
  /**
   *
   * @type {number}
   * @memberof TriggerReindexResponseDtoRepoIndex
   */
  'vectorSize': number | null;
  /**
   *
   * @type {string}
   * @memberof TriggerReindexResponseDtoRepoIndex
   */
  'chunkingSignatureHash': string | null;
  /**
   * Estimated token count
   * @type {number}
   * @memberof TriggerReindexResponseDtoRepoIndex
   */
  'estimatedTokens': number;
  /**
   * Actual indexed tokens
   * @type {number}
   * @memberof TriggerReindexResponseDtoRepoIndex
   */
  'indexedTokens': number;
  /**
   *
   * @type {string}
   * @memberof TriggerReindexResponseDtoRepoIndex
   */
  'errorMessage': string | null;
  /**
   *
   * @type {string}
   * @memberof TriggerReindexResponseDtoRepoIndex
   */
  'createdAt': string;
  /**
   *
   * @type {string}
   * @memberof TriggerReindexResponseDtoRepoIndex
   */
  'updatedAt': string;
}

export const TriggerReindexResponseDtoRepoIndexStatusEnum = {
  Pending: 'pending',
  InProgress: 'in_progress',
  Completed: 'completed',
  Failed: 'failed',
} as const;

export type TriggerReindexResponseDtoRepoIndexStatusEnum =
  (typeof TriggerReindexResponseDtoRepoIndexStatusEnum)[keyof typeof TriggerReindexResponseDtoRepoIndexStatusEnum];

/**
 *
 * @export
 * @interface UnlinkInstallationResponseDto
 */
export interface UnlinkInstallationResponseDto {
  /**
   * Whether the installation was successfully unlinked
   * @type {boolean}
   * @memberof UnlinkInstallationResponseDto
   */
  'unlinked': boolean;
}
/**
 *
 * @export
 * @interface UpdateGraphDto
 */
export interface UpdateGraphDto {
  [key: string]: any;

  /**
   *
   * @type {string}
   * @memberof UpdateGraphDto
   */
  'name'?: string;
  /**
   *
   * @type {UpdateGraphDtoDescription}
   * @memberof UpdateGraphDto
   */
  'description'?: UpdateGraphDtoDescription;
  /**
   *
   * @type {UpdateGraphDtoSchema}
   * @memberof UpdateGraphDto
   */
  'schema'?: UpdateGraphDtoSchema;
  /**
   *
   * @type {UpdateGraphDtoMetadata}
   * @memberof UpdateGraphDto
   */
  'metadata'?: UpdateGraphDtoMetadata;
  /**
   *
   * @type {UpdateGraphDtoTemporary}
   * @memberof UpdateGraphDto
   */
  'temporary'?: UpdateGraphDtoTemporary;
  /**
   * Current version of the graph (for optimistic locking and 3-way merge base)
   * @type {string}
   * @memberof UpdateGraphDto
   */
  'currentVersion': string;
}
/**
 *
 * @export
 * @interface UpdateGraphDtoDescription
 */
export interface UpdateGraphDtoDescription {}
/**
 *
 * @export
 * @interface UpdateGraphDtoMetadata
 */
export interface UpdateGraphDtoMetadata {
  /**
   * Node coordinates and names by node ID
   * @type {Array<CreateGraphDtoMetadataNodesInner>}
   * @memberof UpdateGraphDtoMetadata
   */
  'nodes'?: Array<CreateGraphDtoMetadataNodesInner>;
  /**
   * Zoom level for graph display
   * @type {number}
   * @memberof UpdateGraphDtoMetadata
   */
  'zoom'?: number;
  /**
   * X coordinate
   * @type {number}
   * @memberof UpdateGraphDtoMetadata
   */
  'x'?: number;
  /**
   * Y coordinate
   * @type {number}
   * @memberof UpdateGraphDtoMetadata
   */
  'y'?: number;
}
/**
 *
 * @export
 * @interface UpdateGraphDtoMetadataAnyOf
 */
export interface UpdateGraphDtoMetadataAnyOf {
  [key: string]: any;

  /**
   * Node coordinates and names by node ID
   * @type {Array<CreateGraphDtoMetadataNodesInner>}
   * @memberof UpdateGraphDtoMetadataAnyOf
   */
  'nodes'?: Array<CreateGraphDtoMetadataNodesInner>;
  /**
   * Zoom level for graph display
   * @type {number}
   * @memberof UpdateGraphDtoMetadataAnyOf
   */
  'zoom'?: number;
  /**
   * X coordinate
   * @type {number}
   * @memberof UpdateGraphDtoMetadataAnyOf
   */
  'x'?: number;
  /**
   * Y coordinate
   * @type {number}
   * @memberof UpdateGraphDtoMetadataAnyOf
   */
  'y'?: number;
}
/**
 *
 * @export
 * @interface UpdateGraphDtoSchema
 */
export interface UpdateGraphDtoSchema {
  /**
   *
   * @type {Array<UpdateGraphDtoSchemaNodesInner>}
   * @memberof UpdateGraphDtoSchema
   */
  'nodes': Array<UpdateGraphDtoSchemaNodesInner>;
  /**
   *
   * @type {Array<UpdateGraphDtoSchemaEdgesInner>}
   * @memberof UpdateGraphDtoSchema
   */
  'edges'?: Array<UpdateGraphDtoSchemaEdgesInner>;
}
/**
 *
 * @export
 * @interface UpdateGraphDtoSchemaEdgesInner
 */
export interface UpdateGraphDtoSchemaEdgesInner {
  /**
   * Source node ID
   * @type {string}
   * @memberof UpdateGraphDtoSchemaEdgesInner
   */
  'from': string;
  /**
   * Target node ID
   * @type {string}
   * @memberof UpdateGraphDtoSchemaEdgesInner
   */
  'to': string;
  /**
   * Optional edge label
   * @type {string}
   * @memberof UpdateGraphDtoSchemaEdgesInner
   */
  'label'?: string;
}
/**
 *
 * @export
 * @interface UpdateGraphDtoSchemaNodesInner
 */
export interface UpdateGraphDtoSchemaNodesInner {
  /**
   * Unique identifier for this node
   * @type {string}
   * @memberof UpdateGraphDtoSchemaNodesInner
   */
  'id': string;
  /**
   * Template id registered in TemplateRegistry
   * @type {string}
   * @memberof UpdateGraphDtoSchemaNodesInner
   */
  'template': string;
  /**
   * Template-specific configuration
   * @type {{ [key: string]: any; }}
   * @memberof UpdateGraphDtoSchemaNodesInner
   */
  'config': { [key: string]: any };
}
/**
 * If true, graph will be deleted instead of restored after server restart
 * @export
 * @interface UpdateGraphDtoTemporary
 */
export interface UpdateGraphDtoTemporary {}
/**
 *
 * @export
 * @interface UpdateGraphResponseDto
 */
export interface UpdateGraphResponseDto {
  /**
   *
   * @type {UpdateGraphResponseDtoGraph}
   * @memberof UpdateGraphResponseDto
   */
  'graph': UpdateGraphResponseDtoGraph;
  /**
   *
   * @type {UpdateGraphResponseDtoRevision}
   * @memberof UpdateGraphResponseDto
   */
  'revision'?: UpdateGraphResponseDtoRevision | null;
}
/**
 * Updated graph
 * @export
 * @interface UpdateGraphResponseDtoGraph
 */
export interface UpdateGraphResponseDtoGraph {
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoGraph
   */
  'id': string;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoGraph
   */
  'name': string;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoGraph
   */
  'description'?: string | null;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoGraph
   */
  'error'?: string | null;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoGraph
   */
  'version': string;
  /**
   * Target version after all queued revisions are applied
   * @type {string}
   * @memberof UpdateGraphResponseDtoGraph
   */
  'targetVersion': string;
  /**
   *
   * @type {CreateGraphDtoSchema}
   * @memberof UpdateGraphResponseDtoGraph
   */
  'schema': CreateGraphDtoSchema;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoGraph
   */
  'status': UpdateGraphResponseDtoGraphStatusEnum;
  /**
   *
   * @type {CreateGraphDtoMetadata}
   * @memberof UpdateGraphResponseDtoGraph
   */
  'metadata'?: CreateGraphDtoMetadata | null;
  /**
   * Number of threads currently in running state
   * @type {number}
   * @memberof UpdateGraphResponseDtoGraph
   */
  'runningThreads'?: number;
  /**
   * Total number of threads for this graph
   * @type {number}
   * @memberof UpdateGraphResponseDtoGraph
   */
  'totalThreads'?: number;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoGraph
   */
  'createdAt': string;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoGraph
   */
  'updatedAt': string;
  /**
   *
   * @type {boolean}
   * @memberof UpdateGraphResponseDtoGraph
   */
  'temporary'?: boolean | null;
}

export const UpdateGraphResponseDtoGraphStatusEnum = {
  Created: 'created',
  Compiling: 'compiling',
  Running: 'running',
  Stopped: 'stopped',
  Error: 'error',
} as const;

export type UpdateGraphResponseDtoGraphStatusEnum =
  (typeof UpdateGraphResponseDtoGraphStatusEnum)[keyof typeof UpdateGraphResponseDtoGraphStatusEnum];

/**
 *
 * @export
 * @interface UpdateGraphResponseDtoRevision
 */
export interface UpdateGraphResponseDtoRevision {
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevision
   */
  'id': string;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevision
   */
  'graphId': string;
  /**
   * Version the client changes were based on
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevision
   */
  'baseVersion': string;
  /**
   * New head version after this revision
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevision
   */
  'toVersion': string;
  /**
   * JSON Patch (RFC 6902) operations between old and new schemas
   * @type {Array<UpdateGraphResponseDtoRevisionConfigDiffInner>}
   * @memberof UpdateGraphResponseDtoRevision
   */
  'configDiff': Array<UpdateGraphResponseDtoRevisionConfigDiffInner>;
  /**
   *
   * @type {UpdateGraphResponseDtoRevisionClientConfig}
   * @memberof UpdateGraphResponseDtoRevision
   */
  'clientConfig': UpdateGraphResponseDtoRevisionClientConfig;
  /**
   *
   * @type {UpdateGraphResponseDtoRevisionNewConfig}
   * @memberof UpdateGraphResponseDtoRevision
   */
  'newConfig': UpdateGraphResponseDtoRevisionNewConfig;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevision
   */
  'status': UpdateGraphResponseDtoRevisionStatusEnum;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevision
   */
  'error'?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevision
   */
  'createdAt': string;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevision
   */
  'updatedAt': string;
}

export const UpdateGraphResponseDtoRevisionStatusEnum = {
  Pending: 'pending',
  Applying: 'applying',
  Applied: 'applied',
  Failed: 'failed',
} as const;

export type UpdateGraphResponseDtoRevisionStatusEnum =
  (typeof UpdateGraphResponseDtoRevisionStatusEnum)[keyof typeof UpdateGraphResponseDtoRevisionStatusEnum];

/**
 * Config submitted by the client
 * @export
 * @interface UpdateGraphResponseDtoRevisionClientConfig
 */
export interface UpdateGraphResponseDtoRevisionClientConfig {
  /**
   *
   * @type {CreateGraphDtoSchema}
   * @memberof UpdateGraphResponseDtoRevisionClientConfig
   */
  'schema': CreateGraphDtoSchema;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionClientConfig
   */
  'name': string;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionClientConfig
   */
  'description': string | null;
  /**
   *
   * @type {boolean}
   * @memberof UpdateGraphResponseDtoRevisionClientConfig
   */
  'temporary': boolean;
}
/**
 * @type UpdateGraphResponseDtoRevisionConfigDiffInner
 * @export
 */
export type UpdateGraphResponseDtoRevisionConfigDiffInner =
  | UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf
  | UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf1
  | UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf2
  | UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf3
  | UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf4
  | UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf5;

/**
 *
 * @export
 * @interface UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf
 */
export interface UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf {
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf
   */
  'op': UpdateGraphResponseDtoRevisionConfigDiffInnerOneOfOpEnum;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf
   */
  'path': string;
  /**
   *
   * @type {any}
   * @memberof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf
   */
  'value': any;
}

export const UpdateGraphResponseDtoRevisionConfigDiffInnerOneOfOpEnum = {
  Add: 'add',
} as const;

export type UpdateGraphResponseDtoRevisionConfigDiffInnerOneOfOpEnum =
  (typeof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOfOpEnum)[keyof typeof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOfOpEnum];

/**
 *
 * @export
 * @interface UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf1
 */
export interface UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf1 {
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf1
   */
  'op': UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf1OpEnum;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf1
   */
  'path': string;
}

export const UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf1OpEnum = {
  Remove: 'remove',
} as const;

export type UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf1OpEnum =
  (typeof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf1OpEnum)[keyof typeof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf1OpEnum];

/**
 *
 * @export
 * @interface UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf2
 */
export interface UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf2 {
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf2
   */
  'op': UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf2OpEnum;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf2
   */
  'path': string;
  /**
   *
   * @type {any}
   * @memberof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf2
   */
  'value': any;
}

export const UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf2OpEnum = {
  Replace: 'replace',
} as const;

export type UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf2OpEnum =
  (typeof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf2OpEnum)[keyof typeof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf2OpEnum];

/**
 *
 * @export
 * @interface UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf3
 */
export interface UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf3 {
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf3
   */
  'op': UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf3OpEnum;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf3
   */
  'from': string;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf3
   */
  'path': string;
}

export const UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf3OpEnum = {
  Move: 'move',
} as const;

export type UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf3OpEnum =
  (typeof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf3OpEnum)[keyof typeof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf3OpEnum];

/**
 *
 * @export
 * @interface UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf4
 */
export interface UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf4 {
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf4
   */
  'op': UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf4OpEnum;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf4
   */
  'from': string;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf4
   */
  'path': string;
}

export const UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf4OpEnum = {
  Copy: 'copy',
} as const;

export type UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf4OpEnum =
  (typeof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf4OpEnum)[keyof typeof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf4OpEnum];

/**
 *
 * @export
 * @interface UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf5
 */
export interface UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf5 {
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf5
   */
  'op': UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf5OpEnum;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf5
   */
  'path': string;
  /**
   *
   * @type {any}
   * @memberof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf5
   */
  'value': any;
}

export const UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf5OpEnum = {
  Test: 'test',
} as const;

export type UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf5OpEnum =
  (typeof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf5OpEnum)[keyof typeof UpdateGraphResponseDtoRevisionConfigDiffInnerOneOf5OpEnum];

/**
 * Merged config result
 * @export
 * @interface UpdateGraphResponseDtoRevisionNewConfig
 */
export interface UpdateGraphResponseDtoRevisionNewConfig {
  /**
   *
   * @type {CreateGraphDtoSchema}
   * @memberof UpdateGraphResponseDtoRevisionNewConfig
   */
  'schema': CreateGraphDtoSchema;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionNewConfig
   */
  'name': string;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionNewConfig
   */
  'description': string | null;
  /**
   *
   * @type {boolean}
   * @memberof UpdateGraphResponseDtoRevisionNewConfig
   */
  'temporary': boolean;
}
/**
 *
 * @export
 * @interface UpdateRepositoryDto
 */
export interface UpdateRepositoryDto {
  /**
   * HTTPS URL of the repository
   * @type {string}
   * @memberof UpdateRepositoryDto
   */
  'url'?: string;
  /**
   * Default branch of the repository
   * @type {string}
   * @memberof UpdateRepositoryDto
   */
  'defaultBranch'?: string;
  /**
   * GitHub personal access token (encrypted at rest, write-only)
   * @type {string}
   * @memberof UpdateRepositoryDto
   */
  'token'?: string;
}

/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
export const AnalyticsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} [dateFrom] Include threads created on or after this ISO 8601 datetime
     * @param {string} [dateTo] Include threads created before this ISO 8601 datetime
     * @param {string} [graphId] Filter to a specific graph
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByGraph: async (
      dateFrom?: string,
      dateTo?: string,
      graphId?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/analytics/by-graph`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (dateFrom !== undefined) {
        localVarQueryParameter['dateFrom'] =
          (dateFrom as any) instanceof Date
            ? (dateFrom as any).toISOString()
            : dateFrom;
      }

      if (dateTo !== undefined) {
        localVarQueryParameter['dateTo'] =
          (dateTo as any) instanceof Date
            ? (dateTo as any).toISOString()
            : dateTo;
      }

      if (graphId !== undefined) {
        localVarQueryParameter['graphId'] = graphId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [dateFrom] Include threads created on or after this ISO 8601 datetime
     * @param {string} [dateTo] Include threads created before this ISO 8601 datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOverview: async (
      dateFrom?: string,
      dateTo?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/analytics/overview`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (dateFrom !== undefined) {
        localVarQueryParameter['dateFrom'] =
          (dateFrom as any) instanceof Date
            ? (dateFrom as any).toISOString()
            : dateFrom;
      }

      if (dateTo !== undefined) {
        localVarQueryParameter['dateTo'] =
          (dateTo as any) instanceof Date
            ? (dateTo as any).toISOString()
            : dateTo;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export const AnalyticsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    AnalyticsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} [dateFrom] Include threads created on or after this ISO 8601 datetime
     * @param {string} [dateTo] Include threads created before this ISO 8601 datetime
     * @param {string} [graphId] Filter to a specific graph
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getByGraph(
      dateFrom?: string,
      dateTo?: string,
      graphId?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<AnalyticsByGraphResponseDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getByGraph(
        dateFrom,
        dateTo,
        graphId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AnalyticsApi.getByGraph']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} [dateFrom] Include threads created on or after this ISO 8601 datetime
     * @param {string} [dateTo] Include threads created before this ISO 8601 datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOverview(
      dateFrom?: string,
      dateTo?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<AnalyticsOverviewDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getOverview(
        dateFrom,
        dateTo,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AnalyticsApi.getOverview']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AnalyticsApi - factory interface
 * @export
 */
export const AnalyticsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AnalyticsApiFp(configuration);
  return {
    /**
     *
     * @param {string} [dateFrom] Include threads created on or after this ISO 8601 datetime
     * @param {string} [dateTo] Include threads created before this ISO 8601 datetime
     * @param {string} [graphId] Filter to a specific graph
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByGraph(
      dateFrom?: string,
      dateTo?: string,
      graphId?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AnalyticsByGraphResponseDto> {
      return localVarFp
        .getByGraph(dateFrom, dateTo, graphId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [dateFrom] Include threads created on or after this ISO 8601 datetime
     * @param {string} [dateTo] Include threads created before this ISO 8601 datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOverview(
      dateFrom?: string,
      dateTo?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AnalyticsOverviewDto> {
      return localVarFp
        .getOverview(dateFrom, dateTo, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI {
  /**
   *
   * @param {string} [dateFrom] Include threads created on or after this ISO 8601 datetime
   * @param {string} [dateTo] Include threads created before this ISO 8601 datetime
   * @param {string} [graphId] Filter to a specific graph
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AnalyticsApi
   */
  public getByGraph(
    dateFrom?: string,
    dateTo?: string,
    graphId?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return AnalyticsApiFp(this.configuration)
      .getByGraph(dateFrom, dateTo, graphId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [dateFrom] Include threads created on or after this ISO 8601 datetime
   * @param {string} [dateTo] Include threads created before this ISO 8601 datetime
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AnalyticsApi
   */
  public getOverview(
    dateFrom?: string,
    dateTo?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return AnalyticsApiFp(this.configuration)
      .getOverview(dateFrom, dateTo, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * GitRepositoriesApi - axios parameter creator
 * @export
 */
export const GitRepositoriesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {CreateRepositoryDto} createRepositoryDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository: async (
      createRepositoryDto: CreateRepositoryDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createRepositoryDto' is not null or undefined
      assertParamExists(
        'createRepository',
        'createRepositoryDto',
        createRepositoryDto,
      );
      const localVarPath = `/api/v1/git-repositories`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createRepositoryDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRepository: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteRepository', 'id', id);
      const localVarPath = `/api/v1/git-repositories/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepoIndexByRepositoryId: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getRepoIndexByRepositoryId', 'id', id);
      const localVarPath = `/api/v1/git-repositories/{id}/index`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [repositoryId] Filter by repository ID
     * @param {string} [branch] Filter by single branch name
     * @param {GetRepoIndexesBranchesParameter} [branches] Filter by multiple branch names (comma-separated or repeated query param)
     * @param {GetRepoIndexesStatusEnum} [status] Filter by status
     * @param {number} [limit] Maximum number of indexes to return
     * @param {number} [offset] Number of indexes to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepoIndexes: async (
      repositoryId?: string,
      branch?: string,
      branches?: GetRepoIndexesBranchesParameter,
      status?: GetRepoIndexesStatusEnum,
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/git-repositories/indexes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (repositoryId !== undefined) {
        localVarQueryParameter['repositoryId'] = repositoryId;
      }

      if (branch !== undefined) {
        localVarQueryParameter['branch'] = branch;
      }

      if (branches !== undefined) {
        for (const [key, value] of Object.entries(branches)) {
          localVarQueryParameter[key] = value;
        }
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [owner] Filter by repository owner
     * @param {string} [repo] Filter by repository name
     * @param {GetRepositoriesProviderEnum} [provider] Filter by host provider
     * @param {number} [limit] Maximum number of repositories to return
     * @param {number} [offset] Number of repositories to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepositories: async (
      owner?: string,
      repo?: string,
      provider?: GetRepositoriesProviderEnum,
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/git-repositories`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (owner !== undefined) {
        localVarQueryParameter['owner'] = owner;
      }

      if (repo !== undefined) {
        localVarQueryParameter['repo'] = repo;
      }

      if (provider !== undefined) {
        localVarQueryParameter['provider'] = provider;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepositoryById: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getRepositoryById', 'id', id);
      const localVarPath = `/api/v1/git-repositories/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {TriggerReindexDto} triggerReindexDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    triggerReindex: async (
      triggerReindexDto: TriggerReindexDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'triggerReindexDto' is not null or undefined
      assertParamExists(
        'triggerReindex',
        'triggerReindexDto',
        triggerReindexDto,
      );
      const localVarPath = `/api/v1/git-repositories/reindex`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        triggerReindexDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {UpdateRepositoryDto} updateRepositoryDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository: async (
      id: string,
      updateRepositoryDto: UpdateRepositoryDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateRepository', 'id', id);
      // verify required parameter 'updateRepositoryDto' is not null or undefined
      assertParamExists(
        'updateRepository',
        'updateRepositoryDto',
        updateRepositoryDto,
      );
      const localVarPath = `/api/v1/git-repositories/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateRepositoryDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GitRepositoriesApi - functional programming interface
 * @export
 */
export const GitRepositoriesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    GitRepositoriesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CreateRepositoryDto} createRepositoryDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository(
      createRepositoryDto: CreateRepositoryDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GitRepositoryDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createRepository(
          createRepositoryDto,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GitRepositoriesApi.createRepository']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRepository(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteRepository(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GitRepositoriesApi.deleteRepository']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRepoIndexByRepositoryId(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRepoIndexByRepositoryId(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GitRepositoriesApi.getRepoIndexByRepositoryId']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} [repositoryId] Filter by repository ID
     * @param {string} [branch] Filter by single branch name
     * @param {GetRepoIndexesBranchesParameter} [branches] Filter by multiple branch names (comma-separated or repeated query param)
     * @param {GetRepoIndexesStatusEnum} [status] Filter by status
     * @param {number} [limit] Maximum number of indexes to return
     * @param {number} [offset] Number of indexes to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRepoIndexes(
      repositoryId?: string,
      branch?: string,
      branches?: GetRepoIndexesBranchesParameter,
      status?: GetRepoIndexesStatusEnum,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<RepoIndexDto>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRepoIndexes(
        repositoryId,
        branch,
        branches,
        status,
        limit,
        offset,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GitRepositoriesApi.getRepoIndexes']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} [owner] Filter by repository owner
     * @param {string} [repo] Filter by repository name
     * @param {GetRepositoriesProviderEnum} [provider] Filter by host provider
     * @param {number} [limit] Maximum number of repositories to return
     * @param {number} [offset] Number of repositories to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRepositories(
      owner?: string,
      repo?: string,
      provider?: GetRepositoriesProviderEnum,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<GitRepositoryDto>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositories(
        owner,
        repo,
        provider,
        limit,
        offset,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GitRepositoriesApi.getRepositories']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRepositoryById(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GitRepositoryDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRepositoryById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GitRepositoriesApi.getRepositoryById']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {TriggerReindexDto} triggerReindexDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async triggerReindex(
      triggerReindexDto: TriggerReindexDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<TriggerReindexResponseDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.triggerReindex(
        triggerReindexDto,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GitRepositoriesApi.triggerReindex']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {UpdateRepositoryDto} updateRepositoryDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository(
      id: string,
      updateRepositoryDto: UpdateRepositoryDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GitRepositoryDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateRepository(
          id,
          updateRepositoryDto,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GitRepositoriesApi.updateRepository']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * GitRepositoriesApi - factory interface
 * @export
 */
export const GitRepositoriesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = GitRepositoriesApiFp(configuration);
  return {
    /**
     *
     * @param {CreateRepositoryDto} createRepositoryDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository(
      createRepositoryDto: CreateRepositoryDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GitRepositoryDto> {
      return localVarFp
        .createRepository(createRepositoryDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRepository(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteRepository(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepoIndexByRepositoryId(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<object> {
      return localVarFp
        .getRepoIndexByRepositoryId(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [repositoryId] Filter by repository ID
     * @param {string} [branch] Filter by single branch name
     * @param {GetRepoIndexesBranchesParameter} [branches] Filter by multiple branch names (comma-separated or repeated query param)
     * @param {GetRepoIndexesStatusEnum} [status] Filter by status
     * @param {number} [limit] Maximum number of indexes to return
     * @param {number} [offset] Number of indexes to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepoIndexes(
      repositoryId?: string,
      branch?: string,
      branches?: GetRepoIndexesBranchesParameter,
      status?: GetRepoIndexesStatusEnum,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<RepoIndexDto>> {
      return localVarFp
        .getRepoIndexes(
          repositoryId,
          branch,
          branches,
          status,
          limit,
          offset,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [owner] Filter by repository owner
     * @param {string} [repo] Filter by repository name
     * @param {GetRepositoriesProviderEnum} [provider] Filter by host provider
     * @param {number} [limit] Maximum number of repositories to return
     * @param {number} [offset] Number of repositories to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepositories(
      owner?: string,
      repo?: string,
      provider?: GetRepositoriesProviderEnum,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<GitRepositoryDto>> {
      return localVarFp
        .getRepositories(owner, repo, provider, limit, offset, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepositoryById(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GitRepositoryDto> {
      return localVarFp
        .getRepositoryById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {TriggerReindexDto} triggerReindexDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    triggerReindex(
      triggerReindexDto: TriggerReindexDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<TriggerReindexResponseDto> {
      return localVarFp
        .triggerReindex(triggerReindexDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {UpdateRepositoryDto} updateRepositoryDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository(
      id: string,
      updateRepositoryDto: UpdateRepositoryDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GitRepositoryDto> {
      return localVarFp
        .updateRepository(id, updateRepositoryDto, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * GitRepositoriesApi - object-oriented interface
 * @export
 * @class GitRepositoriesApi
 * @extends {BaseAPI}
 */
export class GitRepositoriesApi extends BaseAPI {
  /**
   *
   * @param {CreateRepositoryDto} createRepositoryDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GitRepositoriesApi
   */
  public createRepository(
    createRepositoryDto: CreateRepositoryDto,
    options?: RawAxiosRequestConfig,
  ) {
    return GitRepositoriesApiFp(this.configuration)
      .createRepository(createRepositoryDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GitRepositoriesApi
   */
  public deleteRepository(id: string, options?: RawAxiosRequestConfig) {
    return GitRepositoriesApiFp(this.configuration)
      .deleteRepository(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GitRepositoriesApi
   */
  public getRepoIndexByRepositoryId(
    id: string,
    options?: RawAxiosRequestConfig,
  ) {
    return GitRepositoriesApiFp(this.configuration)
      .getRepoIndexByRepositoryId(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [repositoryId] Filter by repository ID
   * @param {string} [branch] Filter by single branch name
   * @param {GetRepoIndexesBranchesParameter} [branches] Filter by multiple branch names (comma-separated or repeated query param)
   * @param {GetRepoIndexesStatusEnum} [status] Filter by status
   * @param {number} [limit] Maximum number of indexes to return
   * @param {number} [offset] Number of indexes to skip
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GitRepositoriesApi
   */
  public getRepoIndexes(
    repositoryId?: string,
    branch?: string,
    branches?: GetRepoIndexesBranchesParameter,
    status?: GetRepoIndexesStatusEnum,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return GitRepositoriesApiFp(this.configuration)
      .getRepoIndexes(
        repositoryId,
        branch,
        branches,
        status,
        limit,
        offset,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [owner] Filter by repository owner
   * @param {string} [repo] Filter by repository name
   * @param {GetRepositoriesProviderEnum} [provider] Filter by host provider
   * @param {number} [limit] Maximum number of repositories to return
   * @param {number} [offset] Number of repositories to skip
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GitRepositoriesApi
   */
  public getRepositories(
    owner?: string,
    repo?: string,
    provider?: GetRepositoriesProviderEnum,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return GitRepositoriesApiFp(this.configuration)
      .getRepositories(owner, repo, provider, limit, offset, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GitRepositoriesApi
   */
  public getRepositoryById(id: string, options?: RawAxiosRequestConfig) {
    return GitRepositoriesApiFp(this.configuration)
      .getRepositoryById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {TriggerReindexDto} triggerReindexDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GitRepositoriesApi
   */
  public triggerReindex(
    triggerReindexDto: TriggerReindexDto,
    options?: RawAxiosRequestConfig,
  ) {
    return GitRepositoriesApiFp(this.configuration)
      .triggerReindex(triggerReindexDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {UpdateRepositoryDto} updateRepositoryDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GitRepositoriesApi
   */
  public updateRepository(
    id: string,
    updateRepositoryDto: UpdateRepositoryDto,
    options?: RawAxiosRequestConfig,
  ) {
    return GitRepositoriesApiFp(this.configuration)
      .updateRepository(id, updateRepositoryDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const GetRepoIndexesStatusEnum = {
  Pending: 'pending',
  InProgress: 'in_progress',
  Completed: 'completed',
  Failed: 'failed',
} as const;
export type GetRepoIndexesStatusEnum =
  (typeof GetRepoIndexesStatusEnum)[keyof typeof GetRepoIndexesStatusEnum];
/**
 * @export
 */
export const GetRepositoriesProviderEnum = {
  Github: 'GITHUB',
} as const;
export type GetRepositoriesProviderEnum =
  (typeof GetRepositoriesProviderEnum)[keyof typeof GetRepositoriesProviderEnum];

/**
 * GithubAppApi - axios parameter creator
 * @export
 */
export const GithubAppApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSetupInfo: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/github-app/setup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} installationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkInstallation: async (
      installationId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'installationId' is not null or undefined
      assertParamExists('linkInstallation', 'installationId', installationId);
      const localVarPath =
        `/api/v1/github-app/installations/{installationId}/link`.replace(
          `{${'installationId'}}`,
          encodeURIComponent(String(installationId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {OAuthLinkRequestDto} oAuthLinkRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkViaOAuthCode: async (
      oAuthLinkRequestDto: OAuthLinkRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'oAuthLinkRequestDto' is not null or undefined
      assertParamExists(
        'linkViaOAuthCode',
        'oAuthLinkRequestDto',
        oAuthLinkRequestDto,
      );
      const localVarPath = `/api/v1/github-app/oauth/link`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        oAuthLinkRequestDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInstallations: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/github-app/installations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} installationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkInstallation: async (
      installationId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'installationId' is not null or undefined
      assertParamExists('unlinkInstallation', 'installationId', installationId);
      const localVarPath =
        `/api/v1/github-app/installations/{installationId}`.replace(
          `{${'installationId'}}`,
          encodeURIComponent(String(installationId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GithubAppApi - functional programming interface
 * @export
 */
export const GithubAppApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    GithubAppApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSetupInfo(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SetupInfoResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSetupInfo(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GithubAppApi.getSetupInfo']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} installationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async linkInstallation(
      installationId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<LinkInstallationResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.linkInstallation(
          installationId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GithubAppApi.linkInstallation']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {OAuthLinkRequestDto} oAuthLinkRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async linkViaOAuthCode(
      oAuthLinkRequestDto: OAuthLinkRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<LinkInstallationResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.linkViaOAuthCode(
          oAuthLinkRequestDto,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GithubAppApi.linkViaOAuthCode']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listInstallations(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ListInstallationsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listInstallations(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GithubAppApi.listInstallations']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} installationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unlinkInstallation(
      installationId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UnlinkInstallationResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.unlinkInstallation(
          installationId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GithubAppApi.unlinkInstallation']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * GithubAppApi - factory interface
 * @export
 */
export const GithubAppApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = GithubAppApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSetupInfo(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SetupInfoResponseDto> {
      return localVarFp
        .getSetupInfo(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} installationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkInstallation(
      installationId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<LinkInstallationResponseDto> {
      return localVarFp
        .linkInstallation(installationId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {OAuthLinkRequestDto} oAuthLinkRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkViaOAuthCode(
      oAuthLinkRequestDto: OAuthLinkRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<LinkInstallationResponseDto> {
      return localVarFp
        .linkViaOAuthCode(oAuthLinkRequestDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInstallations(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ListInstallationsResponseDto> {
      return localVarFp
        .listInstallations(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} installationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkInstallation(
      installationId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UnlinkInstallationResponseDto> {
      return localVarFp
        .unlinkInstallation(installationId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * GithubAppApi - object-oriented interface
 * @export
 * @class GithubAppApi
 * @extends {BaseAPI}
 */
export class GithubAppApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GithubAppApi
   */
  public getSetupInfo(options?: RawAxiosRequestConfig) {
    return GithubAppApiFp(this.configuration)
      .getSetupInfo(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} installationId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GithubAppApi
   */
  public linkInstallation(
    installationId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return GithubAppApiFp(this.configuration)
      .linkInstallation(installationId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {OAuthLinkRequestDto} oAuthLinkRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GithubAppApi
   */
  public linkViaOAuthCode(
    oAuthLinkRequestDto: OAuthLinkRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return GithubAppApiFp(this.configuration)
      .linkViaOAuthCode(oAuthLinkRequestDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GithubAppApi
   */
  public listInstallations(options?: RawAxiosRequestConfig) {
    return GithubAppApiFp(this.configuration)
      .listInstallations(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} installationId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GithubAppApi
   */
  public unlinkInstallation(
    installationId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return GithubAppApiFp(this.configuration)
      .unlinkInstallation(installationId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * GraphRevisionsApi - axios parameter creator
 * @export
 */
export const GraphRevisionsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} graphId
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGraphRevision: async (
      graphId: string,
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'graphId' is not null or undefined
      assertParamExists('getGraphRevision', 'graphId', graphId);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getGraphRevision', 'id', id);
      const localVarPath = `/api/v1/graphs/{graphId}/revisions/{id}`
        .replace(`{${'graphId'}}`, encodeURIComponent(String(graphId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} graphId
     * @param {GetGraphRevisionsStatusEnum} [status]
     * @param {number} [limit] Maximum number of revisions to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGraphRevisions: async (
      graphId: string,
      status?: GetGraphRevisionsStatusEnum,
      limit?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'graphId' is not null or undefined
      assertParamExists('getGraphRevisions', 'graphId', graphId);
      const localVarPath = `/api/v1/graphs/{graphId}/revisions`.replace(
        `{${'graphId'}}`,
        encodeURIComponent(String(graphId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (status !== undefined) {
        localVarQueryParameter['status'] = status;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GraphRevisionsApi - functional programming interface
 * @export
 */
export const GraphRevisionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    GraphRevisionsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} graphId
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGraphRevision(
      graphId: string,
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GraphRevisionDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getGraphRevision(graphId, id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphRevisionsApi.getGraphRevision']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} graphId
     * @param {GetGraphRevisionsStatusEnum} [status]
     * @param {number} [limit] Maximum number of revisions to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGraphRevisions(
      graphId: string,
      status?: GetGraphRevisionsStatusEnum,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<GraphRevisionDto>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getGraphRevisions(
          graphId,
          status,
          limit,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphRevisionsApi.getGraphRevisions']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * GraphRevisionsApi - factory interface
 * @export
 */
export const GraphRevisionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = GraphRevisionsApiFp(configuration);
  return {
    /**
     *
     * @param {string} graphId
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGraphRevision(
      graphId: string,
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GraphRevisionDto> {
      return localVarFp
        .getGraphRevision(graphId, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} graphId
     * @param {GetGraphRevisionsStatusEnum} [status]
     * @param {number} [limit] Maximum number of revisions to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGraphRevisions(
      graphId: string,
      status?: GetGraphRevisionsStatusEnum,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<GraphRevisionDto>> {
      return localVarFp
        .getGraphRevisions(graphId, status, limit, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * GraphRevisionsApi - object-oriented interface
 * @export
 * @class GraphRevisionsApi
 * @extends {BaseAPI}
 */
export class GraphRevisionsApi extends BaseAPI {
  /**
   *
   * @param {string} graphId
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphRevisionsApi
   */
  public getGraphRevision(
    graphId: string,
    id: string,
    options?: RawAxiosRequestConfig,
  ) {
    return GraphRevisionsApiFp(this.configuration)
      .getGraphRevision(graphId, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} graphId
   * @param {GetGraphRevisionsStatusEnum} [status]
   * @param {number} [limit] Maximum number of revisions to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphRevisionsApi
   */
  public getGraphRevisions(
    graphId: string,
    status?: GetGraphRevisionsStatusEnum,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return GraphRevisionsApiFp(this.configuration)
      .getGraphRevisions(graphId, status, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const GetGraphRevisionsStatusEnum = {
  Pending: 'pending',
  Applying: 'applying',
  Applied: 'applied',
  Failed: 'failed',
} as const;
export type GetGraphRevisionsStatusEnum =
  (typeof GetGraphRevisionsStatusEnum)[keyof typeof GetGraphRevisionsStatusEnum];

/**
 * GraphsApi - axios parameter creator
 * @export
 */
export const GraphsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} threadId
     * @param {ThreadAnalysisRequestDto} threadAnalysisRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    analyzeThread: async (
      threadId: string,
      threadAnalysisRequestDto: ThreadAnalysisRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'threadId' is not null or undefined
      assertParamExists('analyzeThread', 'threadId', threadId);
      // verify required parameter 'threadAnalysisRequestDto' is not null or undefined
      assertParamExists(
        'analyzeThread',
        'threadAnalysisRequestDto',
        threadAnalysisRequestDto,
      );
      const localVarPath = `/api/v1/threads/{threadId}/analyze`.replace(
        `{${'threadId'}}`,
        encodeURIComponent(String(threadId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        threadAnalysisRequestDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreateGraphDto} createGraphDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGraph: async (
      createGraphDto: CreateGraphDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createGraphDto' is not null or undefined
      assertParamExists('createGraph', 'createGraphDto', createGraphDto);
      const localVarPath = `/api/v1/graphs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createGraphDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGraph: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteGraph', 'id', id);
      const localVarPath = `/api/v1/graphs/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    destroyGraph: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('destroyGraph', 'id', id);
      const localVarPath = `/api/v1/graphs/{id}/destroy`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} graphId
     * @param {string} triggerId
     * @param {ExecuteTriggerDto} executeTriggerDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeTrigger: async (
      graphId: string,
      triggerId: string,
      executeTriggerDto: ExecuteTriggerDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'graphId' is not null or undefined
      assertParamExists('executeTrigger', 'graphId', graphId);
      // verify required parameter 'triggerId' is not null or undefined
      assertParamExists('executeTrigger', 'triggerId', triggerId);
      // verify required parameter 'executeTriggerDto' is not null or undefined
      assertParamExists(
        'executeTrigger',
        'executeTriggerDto',
        executeTriggerDto,
      );
      const localVarPath =
        `/api/v1/graphs/{graphId}/triggers/{triggerId}/execute`
          .replace(`{${'graphId'}}`, encodeURIComponent(String(graphId)))
          .replace(`{${'triggerId'}}`, encodeURIComponent(String(triggerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        executeTriggerDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findGraphById: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('findGraphById', 'id', id);
      const localVarPath = `/api/v1/graphs/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {Array<string>} [ids] Filter graphs by IDs (comma-separated or repeated params)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllGraphs: async (
      ids?: Array<string>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/graphs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (ids) {
        localVarQueryParameter['ids'] = ids;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {string} [threadId]
     * @param {string} [runId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompiledNodes: async (
      id: string,
      threadId?: string,
      runId?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getCompiledNodes', 'id', id);
      const localVarPath = `/api/v1/graphs/{id}/nodes`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (threadId !== undefined) {
        localVarQueryParameter['threadId'] = threadId;
      }

      if (runId !== undefined) {
        localVarQueryParameter['runId'] = runId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGraph: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('runGraph', 'id', id);
      const localVarPath = `/api/v1/graphs/{id}/run`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} graphId
     * @param {string} nodeId
     * @param {SuggestAgentInstructionsDto} suggestAgentInstructionsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suggestAgentInstructions: async (
      graphId: string,
      nodeId: string,
      suggestAgentInstructionsDto: SuggestAgentInstructionsDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'graphId' is not null or undefined
      assertParamExists('suggestAgentInstructions', 'graphId', graphId);
      // verify required parameter 'nodeId' is not null or undefined
      assertParamExists('suggestAgentInstructions', 'nodeId', nodeId);
      // verify required parameter 'suggestAgentInstructionsDto' is not null or undefined
      assertParamExists(
        'suggestAgentInstructions',
        'suggestAgentInstructionsDto',
        suggestAgentInstructionsDto,
      );
      const localVarPath =
        `/api/v1/graphs/{graphId}/nodes/{nodeId}/suggest-instructions`
          .replace(`{${'graphId'}}`, encodeURIComponent(String(graphId)))
          .replace(`{${'nodeId'}}`, encodeURIComponent(String(nodeId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        suggestAgentInstructionsDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} graphId
     * @param {SuggestGraphInstructionsDto} suggestGraphInstructionsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suggestGraphInstructions: async (
      graphId: string,
      suggestGraphInstructionsDto: SuggestGraphInstructionsDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'graphId' is not null or undefined
      assertParamExists('suggestGraphInstructions', 'graphId', graphId);
      // verify required parameter 'suggestGraphInstructionsDto' is not null or undefined
      assertParamExists(
        'suggestGraphInstructions',
        'suggestGraphInstructionsDto',
        suggestGraphInstructionsDto,
      );
      const localVarPath =
        `/api/v1/graphs/{graphId}/suggest-instructions`.replace(
          `{${'graphId'}}`,
          encodeURIComponent(String(graphId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        suggestGraphInstructionsDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {KnowledgeContentSuggestionRequestDto} knowledgeContentSuggestionRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suggestKnowledgeContent: async (
      knowledgeContentSuggestionRequestDto: KnowledgeContentSuggestionRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'knowledgeContentSuggestionRequestDto' is not null or undefined
      assertParamExists(
        'suggestKnowledgeContent',
        'knowledgeContentSuggestionRequestDto',
        knowledgeContentSuggestionRequestDto,
      );
      const localVarPath = `/api/v1/knowledge-docs/suggest`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        knowledgeContentSuggestionRequestDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {UpdateGraphDto} updateGraphDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGraph: async (
      id: string,
      updateGraphDto: UpdateGraphDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateGraph', 'id', id);
      // verify required parameter 'updateGraphDto' is not null or undefined
      assertParamExists('updateGraph', 'updateGraphDto', updateGraphDto);
      const localVarPath = `/api/v1/graphs/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateGraphDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GraphsApi - functional programming interface
 * @export
 */
export const GraphsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = GraphsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} threadId
     * @param {ThreadAnalysisRequestDto} threadAnalysisRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async analyzeThread(
      threadId: string,
      threadAnalysisRequestDto: ThreadAnalysisRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ThreadAnalysisResponseDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.analyzeThread(
        threadId,
        threadAnalysisRequestDto,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphsApi.analyzeThread']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {CreateGraphDto} createGraphDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createGraph(
      createGraphDto: CreateGraphDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createGraph(
        createGraphDto,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphsApi.createGraph']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteGraph(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGraph(
        id,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphsApi.deleteGraph']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async destroyGraph(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.destroyGraph(
        id,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphsApi.destroyGraph']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} graphId
     * @param {string} triggerId
     * @param {ExecuteTriggerDto} executeTriggerDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async executeTrigger(
      graphId: string,
      triggerId: string,
      executeTriggerDto: ExecuteTriggerDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ExecuteTriggerResponseDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.executeTrigger(
        graphId,
        triggerId,
        executeTriggerDto,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphsApi.executeTrigger']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findGraphById(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findGraphById(
        id,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphsApi.findGraphById']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {Array<string>} [ids] Filter graphs by IDs (comma-separated or repeated params)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllGraphs(
      ids?: Array<string>,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<GraphDto>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllGraphs(
        ids,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphsApi.getAllGraphs']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {string} [threadId]
     * @param {string} [runId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCompiledNodes(
      id: string,
      threadId?: string,
      runId?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<GraphNodeWithStatusDto>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCompiledNodes(
          id,
          threadId,
          runId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphsApi.getCompiledNodes']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGraph(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runGraph(
        id,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphsApi.runGraph']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} graphId
     * @param {string} nodeId
     * @param {SuggestAgentInstructionsDto} suggestAgentInstructionsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async suggestAgentInstructions(
      graphId: string,
      nodeId: string,
      suggestAgentInstructionsDto: SuggestAgentInstructionsDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SuggestAgentInstructionsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.suggestAgentInstructions(
          graphId,
          nodeId,
          suggestAgentInstructionsDto,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphsApi.suggestAgentInstructions']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} graphId
     * @param {SuggestGraphInstructionsDto} suggestGraphInstructionsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async suggestGraphInstructions(
      graphId: string,
      suggestGraphInstructionsDto: SuggestGraphInstructionsDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SuggestGraphInstructionsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.suggestGraphInstructions(
          graphId,
          suggestGraphInstructionsDto,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphsApi.suggestGraphInstructions']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {KnowledgeContentSuggestionRequestDto} knowledgeContentSuggestionRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async suggestKnowledgeContent(
      knowledgeContentSuggestionRequestDto: KnowledgeContentSuggestionRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<KnowledgeContentSuggestionResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.suggestKnowledgeContent(
          knowledgeContentSuggestionRequestDto,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphsApi.suggestKnowledgeContent']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {UpdateGraphDto} updateGraphDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateGraph(
      id: string,
      updateGraphDto: UpdateGraphDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UpdateGraphResponseDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateGraph(
        id,
        updateGraphDto,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphsApi.updateGraph']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * GraphsApi - factory interface
 * @export
 */
export const GraphsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = GraphsApiFp(configuration);
  return {
    /**
     *
     * @param {string} threadId
     * @param {ThreadAnalysisRequestDto} threadAnalysisRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    analyzeThread(
      threadId: string,
      threadAnalysisRequestDto: ThreadAnalysisRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ThreadAnalysisResponseDto> {
      return localVarFp
        .analyzeThread(threadId, threadAnalysisRequestDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {CreateGraphDto} createGraphDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGraph(
      createGraphDto: CreateGraphDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GraphDto> {
      return localVarFp
        .createGraph(createGraphDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGraph(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteGraph(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    destroyGraph(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GraphDto> {
      return localVarFp
        .destroyGraph(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} graphId
     * @param {string} triggerId
     * @param {ExecuteTriggerDto} executeTriggerDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeTrigger(
      graphId: string,
      triggerId: string,
      executeTriggerDto: ExecuteTriggerDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ExecuteTriggerResponseDto> {
      return localVarFp
        .executeTrigger(graphId, triggerId, executeTriggerDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findGraphById(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GraphDto> {
      return localVarFp
        .findGraphById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {Array<string>} [ids] Filter graphs by IDs (comma-separated or repeated params)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllGraphs(
      ids?: Array<string>,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<GraphDto>> {
      return localVarFp
        .getAllGraphs(ids, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {string} [threadId]
     * @param {string} [runId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompiledNodes(
      id: string,
      threadId?: string,
      runId?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<GraphNodeWithStatusDto>> {
      return localVarFp
        .getCompiledNodes(id, threadId, runId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGraph(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GraphDto> {
      return localVarFp
        .runGraph(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} graphId
     * @param {string} nodeId
     * @param {SuggestAgentInstructionsDto} suggestAgentInstructionsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suggestAgentInstructions(
      graphId: string,
      nodeId: string,
      suggestAgentInstructionsDto: SuggestAgentInstructionsDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SuggestAgentInstructionsResponseDto> {
      return localVarFp
        .suggestAgentInstructions(
          graphId,
          nodeId,
          suggestAgentInstructionsDto,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} graphId
     * @param {SuggestGraphInstructionsDto} suggestGraphInstructionsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suggestGraphInstructions(
      graphId: string,
      suggestGraphInstructionsDto: SuggestGraphInstructionsDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SuggestGraphInstructionsResponseDto> {
      return localVarFp
        .suggestGraphInstructions(graphId, suggestGraphInstructionsDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {KnowledgeContentSuggestionRequestDto} knowledgeContentSuggestionRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suggestKnowledgeContent(
      knowledgeContentSuggestionRequestDto: KnowledgeContentSuggestionRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<KnowledgeContentSuggestionResponseDto> {
      return localVarFp
        .suggestKnowledgeContent(knowledgeContentSuggestionRequestDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {UpdateGraphDto} updateGraphDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGraph(
      id: string,
      updateGraphDto: UpdateGraphDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UpdateGraphResponseDto> {
      return localVarFp
        .updateGraph(id, updateGraphDto, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * GraphsApi - object-oriented interface
 * @export
 * @class GraphsApi
 * @extends {BaseAPI}
 */
export class GraphsApi extends BaseAPI {
  /**
   *
   * @param {string} threadId
   * @param {ThreadAnalysisRequestDto} threadAnalysisRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public analyzeThread(
    threadId: string,
    threadAnalysisRequestDto: ThreadAnalysisRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return GraphsApiFp(this.configuration)
      .analyzeThread(threadId, threadAnalysisRequestDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CreateGraphDto} createGraphDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public createGraph(
    createGraphDto: CreateGraphDto,
    options?: RawAxiosRequestConfig,
  ) {
    return GraphsApiFp(this.configuration)
      .createGraph(createGraphDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public deleteGraph(id: string, options?: RawAxiosRequestConfig) {
    return GraphsApiFp(this.configuration)
      .deleteGraph(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public destroyGraph(id: string, options?: RawAxiosRequestConfig) {
    return GraphsApiFp(this.configuration)
      .destroyGraph(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} graphId
   * @param {string} triggerId
   * @param {ExecuteTriggerDto} executeTriggerDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public executeTrigger(
    graphId: string,
    triggerId: string,
    executeTriggerDto: ExecuteTriggerDto,
    options?: RawAxiosRequestConfig,
  ) {
    return GraphsApiFp(this.configuration)
      .executeTrigger(graphId, triggerId, executeTriggerDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public findGraphById(id: string, options?: RawAxiosRequestConfig) {
    return GraphsApiFp(this.configuration)
      .findGraphById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {Array<string>} [ids] Filter graphs by IDs (comma-separated or repeated params)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public getAllGraphs(ids?: Array<string>, options?: RawAxiosRequestConfig) {
    return GraphsApiFp(this.configuration)
      .getAllGraphs(ids, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {string} [threadId]
   * @param {string} [runId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public getCompiledNodes(
    id: string,
    threadId?: string,
    runId?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return GraphsApiFp(this.configuration)
      .getCompiledNodes(id, threadId, runId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public runGraph(id: string, options?: RawAxiosRequestConfig) {
    return GraphsApiFp(this.configuration)
      .runGraph(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} graphId
   * @param {string} nodeId
   * @param {SuggestAgentInstructionsDto} suggestAgentInstructionsDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public suggestAgentInstructions(
    graphId: string,
    nodeId: string,
    suggestAgentInstructionsDto: SuggestAgentInstructionsDto,
    options?: RawAxiosRequestConfig,
  ) {
    return GraphsApiFp(this.configuration)
      .suggestAgentInstructions(
        graphId,
        nodeId,
        suggestAgentInstructionsDto,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} graphId
   * @param {SuggestGraphInstructionsDto} suggestGraphInstructionsDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public suggestGraphInstructions(
    graphId: string,
    suggestGraphInstructionsDto: SuggestGraphInstructionsDto,
    options?: RawAxiosRequestConfig,
  ) {
    return GraphsApiFp(this.configuration)
      .suggestGraphInstructions(graphId, suggestGraphInstructionsDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {KnowledgeContentSuggestionRequestDto} knowledgeContentSuggestionRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public suggestKnowledgeContent(
    knowledgeContentSuggestionRequestDto: KnowledgeContentSuggestionRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return GraphsApiFp(this.configuration)
      .suggestKnowledgeContent(knowledgeContentSuggestionRequestDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {UpdateGraphDto} updateGraphDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public updateGraph(
    id: string,
    updateGraphDto: UpdateGraphDto,
    options?: RawAxiosRequestConfig,
  ) {
    return GraphsApiFp(this.configuration)
      .updateGraph(id, updateGraphDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * KnowledgeApi - axios parameter creator
 * @export
 */
export const KnowledgeApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} threadId
     * @param {ThreadAnalysisRequestDto} threadAnalysisRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    analyzeThread: async (
      threadId: string,
      threadAnalysisRequestDto: ThreadAnalysisRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'threadId' is not null or undefined
      assertParamExists('analyzeThread', 'threadId', threadId);
      // verify required parameter 'threadAnalysisRequestDto' is not null or undefined
      assertParamExists(
        'analyzeThread',
        'threadAnalysisRequestDto',
        threadAnalysisRequestDto,
      );
      const localVarPath = `/api/v1/threads/{threadId}/analyze`.replace(
        `{${'threadId'}}`,
        encodeURIComponent(String(threadId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        threadAnalysisRequestDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {KnowledgeDocCreateDto} knowledgeDocCreateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDoc: async (
      knowledgeDocCreateDto: KnowledgeDocCreateDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'knowledgeDocCreateDto' is not null or undefined
      assertParamExists(
        'createDoc',
        'knowledgeDocCreateDto',
        knowledgeDocCreateDto,
      );
      const localVarPath = `/api/v1/knowledge-docs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        knowledgeDocCreateDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDoc: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteDoc', 'id', id);
      const localVarPath = `/api/v1/knowledge-docs/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoc: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getDoc', 'id', id);
      const localVarPath = `/api/v1/knowledge-docs/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {Array<string>} [tags] Filter by tags (match any)
     * @param {string} [search] Search in title/summary/content
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDocs: async (
      tags?: Array<string>,
      search?: string,
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/knowledge-docs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (tags) {
        localVarQueryParameter['tags'] = tags;
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} graphId
     * @param {string} nodeId
     * @param {SuggestAgentInstructionsDto} suggestAgentInstructionsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suggestAgentInstructions: async (
      graphId: string,
      nodeId: string,
      suggestAgentInstructionsDto: SuggestAgentInstructionsDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'graphId' is not null or undefined
      assertParamExists('suggestAgentInstructions', 'graphId', graphId);
      // verify required parameter 'nodeId' is not null or undefined
      assertParamExists('suggestAgentInstructions', 'nodeId', nodeId);
      // verify required parameter 'suggestAgentInstructionsDto' is not null or undefined
      assertParamExists(
        'suggestAgentInstructions',
        'suggestAgentInstructionsDto',
        suggestAgentInstructionsDto,
      );
      const localVarPath =
        `/api/v1/graphs/{graphId}/nodes/{nodeId}/suggest-instructions`
          .replace(`{${'graphId'}}`, encodeURIComponent(String(graphId)))
          .replace(`{${'nodeId'}}`, encodeURIComponent(String(nodeId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        suggestAgentInstructionsDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} graphId
     * @param {SuggestGraphInstructionsDto} suggestGraphInstructionsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suggestGraphInstructions: async (
      graphId: string,
      suggestGraphInstructionsDto: SuggestGraphInstructionsDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'graphId' is not null or undefined
      assertParamExists('suggestGraphInstructions', 'graphId', graphId);
      // verify required parameter 'suggestGraphInstructionsDto' is not null or undefined
      assertParamExists(
        'suggestGraphInstructions',
        'suggestGraphInstructionsDto',
        suggestGraphInstructionsDto,
      );
      const localVarPath =
        `/api/v1/graphs/{graphId}/suggest-instructions`.replace(
          `{${'graphId'}}`,
          encodeURIComponent(String(graphId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        suggestGraphInstructionsDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {KnowledgeContentSuggestionRequestDto} knowledgeContentSuggestionRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suggestKnowledgeContent: async (
      knowledgeContentSuggestionRequestDto: KnowledgeContentSuggestionRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'knowledgeContentSuggestionRequestDto' is not null or undefined
      assertParamExists(
        'suggestKnowledgeContent',
        'knowledgeContentSuggestionRequestDto',
        knowledgeContentSuggestionRequestDto,
      );
      const localVarPath = `/api/v1/knowledge-docs/suggest`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        knowledgeContentSuggestionRequestDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {KnowledgeDocUpdateDto} knowledgeDocUpdateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDoc: async (
      id: string,
      knowledgeDocUpdateDto: KnowledgeDocUpdateDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateDoc', 'id', id);
      // verify required parameter 'knowledgeDocUpdateDto' is not null or undefined
      assertParamExists(
        'updateDoc',
        'knowledgeDocUpdateDto',
        knowledgeDocUpdateDto,
      );
      const localVarPath = `/api/v1/knowledge-docs/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        knowledgeDocUpdateDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * KnowledgeApi - functional programming interface
 * @export
 */
export const KnowledgeApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    KnowledgeApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} threadId
     * @param {ThreadAnalysisRequestDto} threadAnalysisRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async analyzeThread(
      threadId: string,
      threadAnalysisRequestDto: ThreadAnalysisRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ThreadAnalysisResponseDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.analyzeThread(
        threadId,
        threadAnalysisRequestDto,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['KnowledgeApi.analyzeThread']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {KnowledgeDocCreateDto} knowledgeDocCreateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createDoc(
      knowledgeDocCreateDto: KnowledgeDocCreateDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<KnowledgeDocDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createDoc(
        knowledgeDocCreateDto,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['KnowledgeApi.createDoc']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteDoc(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDoc(
        id,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['KnowledgeApi.deleteDoc']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDoc(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<KnowledgeDocDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDoc(
        id,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['KnowledgeApi.getDoc']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {Array<string>} [tags] Filter by tags (match any)
     * @param {string} [search] Search in title/summary/content
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listDocs(
      tags?: Array<string>,
      search?: string,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listDocs(
        tags,
        search,
        limit,
        offset,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['KnowledgeApi.listDocs']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} graphId
     * @param {string} nodeId
     * @param {SuggestAgentInstructionsDto} suggestAgentInstructionsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async suggestAgentInstructions(
      graphId: string,
      nodeId: string,
      suggestAgentInstructionsDto: SuggestAgentInstructionsDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SuggestAgentInstructionsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.suggestAgentInstructions(
          graphId,
          nodeId,
          suggestAgentInstructionsDto,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['KnowledgeApi.suggestAgentInstructions']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} graphId
     * @param {SuggestGraphInstructionsDto} suggestGraphInstructionsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async suggestGraphInstructions(
      graphId: string,
      suggestGraphInstructionsDto: SuggestGraphInstructionsDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SuggestGraphInstructionsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.suggestGraphInstructions(
          graphId,
          suggestGraphInstructionsDto,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['KnowledgeApi.suggestGraphInstructions']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {KnowledgeContentSuggestionRequestDto} knowledgeContentSuggestionRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async suggestKnowledgeContent(
      knowledgeContentSuggestionRequestDto: KnowledgeContentSuggestionRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<KnowledgeContentSuggestionResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.suggestKnowledgeContent(
          knowledgeContentSuggestionRequestDto,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['KnowledgeApi.suggestKnowledgeContent']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {KnowledgeDocUpdateDto} knowledgeDocUpdateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateDoc(
      id: string,
      knowledgeDocUpdateDto: KnowledgeDocUpdateDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<KnowledgeDocDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateDoc(
        id,
        knowledgeDocUpdateDto,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['KnowledgeApi.updateDoc']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * KnowledgeApi - factory interface
 * @export
 */
export const KnowledgeApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = KnowledgeApiFp(configuration);
  return {
    /**
     *
     * @param {string} threadId
     * @param {ThreadAnalysisRequestDto} threadAnalysisRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    analyzeThread(
      threadId: string,
      threadAnalysisRequestDto: ThreadAnalysisRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ThreadAnalysisResponseDto> {
      return localVarFp
        .analyzeThread(threadId, threadAnalysisRequestDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {KnowledgeDocCreateDto} knowledgeDocCreateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDoc(
      knowledgeDocCreateDto: KnowledgeDocCreateDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<KnowledgeDocDto> {
      return localVarFp
        .createDoc(knowledgeDocCreateDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDoc(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp
        .deleteDoc(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoc(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<KnowledgeDocDto> {
      return localVarFp
        .getDoc(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {Array<string>} [tags] Filter by tags (match any)
     * @param {string} [search] Search in title/summary/content
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDocs(
      tags?: Array<string>,
      search?: string,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<object> {
      return localVarFp
        .listDocs(tags, search, limit, offset, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} graphId
     * @param {string} nodeId
     * @param {SuggestAgentInstructionsDto} suggestAgentInstructionsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suggestAgentInstructions(
      graphId: string,
      nodeId: string,
      suggestAgentInstructionsDto: SuggestAgentInstructionsDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SuggestAgentInstructionsResponseDto> {
      return localVarFp
        .suggestAgentInstructions(
          graphId,
          nodeId,
          suggestAgentInstructionsDto,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} graphId
     * @param {SuggestGraphInstructionsDto} suggestGraphInstructionsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suggestGraphInstructions(
      graphId: string,
      suggestGraphInstructionsDto: SuggestGraphInstructionsDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SuggestGraphInstructionsResponseDto> {
      return localVarFp
        .suggestGraphInstructions(graphId, suggestGraphInstructionsDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {KnowledgeContentSuggestionRequestDto} knowledgeContentSuggestionRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suggestKnowledgeContent(
      knowledgeContentSuggestionRequestDto: KnowledgeContentSuggestionRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<KnowledgeContentSuggestionResponseDto> {
      return localVarFp
        .suggestKnowledgeContent(knowledgeContentSuggestionRequestDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {KnowledgeDocUpdateDto} knowledgeDocUpdateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDoc(
      id: string,
      knowledgeDocUpdateDto: KnowledgeDocUpdateDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<KnowledgeDocDto> {
      return localVarFp
        .updateDoc(id, knowledgeDocUpdateDto, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * KnowledgeApi - object-oriented interface
 * @export
 * @class KnowledgeApi
 * @extends {BaseAPI}
 */
export class KnowledgeApi extends BaseAPI {
  /**
   *
   * @param {string} threadId
   * @param {ThreadAnalysisRequestDto} threadAnalysisRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KnowledgeApi
   */
  public analyzeThread(
    threadId: string,
    threadAnalysisRequestDto: ThreadAnalysisRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return KnowledgeApiFp(this.configuration)
      .analyzeThread(threadId, threadAnalysisRequestDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {KnowledgeDocCreateDto} knowledgeDocCreateDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KnowledgeApi
   */
  public createDoc(
    knowledgeDocCreateDto: KnowledgeDocCreateDto,
    options?: RawAxiosRequestConfig,
  ) {
    return KnowledgeApiFp(this.configuration)
      .createDoc(knowledgeDocCreateDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KnowledgeApi
   */
  public deleteDoc(id: string, options?: RawAxiosRequestConfig) {
    return KnowledgeApiFp(this.configuration)
      .deleteDoc(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KnowledgeApi
   */
  public getDoc(id: string, options?: RawAxiosRequestConfig) {
    return KnowledgeApiFp(this.configuration)
      .getDoc(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {Array<string>} [tags] Filter by tags (match any)
   * @param {string} [search] Search in title/summary/content
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KnowledgeApi
   */
  public listDocs(
    tags?: Array<string>,
    search?: string,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return KnowledgeApiFp(this.configuration)
      .listDocs(tags, search, limit, offset, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} graphId
   * @param {string} nodeId
   * @param {SuggestAgentInstructionsDto} suggestAgentInstructionsDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KnowledgeApi
   */
  public suggestAgentInstructions(
    graphId: string,
    nodeId: string,
    suggestAgentInstructionsDto: SuggestAgentInstructionsDto,
    options?: RawAxiosRequestConfig,
  ) {
    return KnowledgeApiFp(this.configuration)
      .suggestAgentInstructions(
        graphId,
        nodeId,
        suggestAgentInstructionsDto,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} graphId
   * @param {SuggestGraphInstructionsDto} suggestGraphInstructionsDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KnowledgeApi
   */
  public suggestGraphInstructions(
    graphId: string,
    suggestGraphInstructionsDto: SuggestGraphInstructionsDto,
    options?: RawAxiosRequestConfig,
  ) {
    return KnowledgeApiFp(this.configuration)
      .suggestGraphInstructions(graphId, suggestGraphInstructionsDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {KnowledgeContentSuggestionRequestDto} knowledgeContentSuggestionRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KnowledgeApi
   */
  public suggestKnowledgeContent(
    knowledgeContentSuggestionRequestDto: KnowledgeContentSuggestionRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return KnowledgeApiFp(this.configuration)
      .suggestKnowledgeContent(knowledgeContentSuggestionRequestDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {KnowledgeDocUpdateDto} knowledgeDocUpdateDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KnowledgeApi
   */
  public updateDoc(
    id: string,
    knowledgeDocUpdateDto: KnowledgeDocUpdateDto,
    options?: RawAxiosRequestConfig,
  ) {
    return KnowledgeApiFp(this.configuration)
      .updateDoc(id, knowledgeDocUpdateDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LitellmApi - axios parameter creator
 * @export
 */
export const LitellmApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listModels: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/litellm/models`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LitellmApi - functional programming interface
 * @export
 */
export const LitellmApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LitellmApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listModels(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<LiteLlmModelDto>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listModels(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LitellmApi.listModels']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * LitellmApi - factory interface
 * @export
 */
export const LitellmApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = LitellmApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listModels(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<LiteLlmModelDto>> {
      return localVarFp
        .listModels(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LitellmApi - object-oriented interface
 * @export
 * @class LitellmApi
 * @extends {BaseAPI}
 */
export class LitellmApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LitellmApi
   */
  public listModels(options?: RawAxiosRequestConfig) {
    return LitellmApiFp(this.configuration)
      .listModels(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RuntimesApi - axios parameter creator
 * @export
 */
export const RuntimesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} threadId Filter by thread ID
     * @param {GetRuntimesStatusEnum} [status] Filter by runtime instance status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRuntimes: async (
      threadId: string,
      status?: GetRuntimesStatusEnum,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'threadId' is not null or undefined
      assertParamExists('getRuntimes', 'threadId', threadId);
      const localVarPath = `/api/v1/runtimes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (threadId !== undefined) {
        localVarQueryParameter['threadId'] = threadId;
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RuntimesApi - functional programming interface
 * @export
 */
export const RuntimesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RuntimesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} threadId Filter by thread ID
     * @param {GetRuntimesStatusEnum} [status] Filter by runtime instance status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRuntimes(
      threadId: string,
      status?: GetRuntimesStatusEnum,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<RuntimeInstanceDto>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRuntimes(
        threadId,
        status,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['RuntimesApi.getRuntimes']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * RuntimesApi - factory interface
 * @export
 */
export const RuntimesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = RuntimesApiFp(configuration);
  return {
    /**
     *
     * @param {string} threadId Filter by thread ID
     * @param {GetRuntimesStatusEnum} [status] Filter by runtime instance status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRuntimes(
      threadId: string,
      status?: GetRuntimesStatusEnum,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<RuntimeInstanceDto>> {
      return localVarFp
        .getRuntimes(threadId, status, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RuntimesApi - object-oriented interface
 * @export
 * @class RuntimesApi
 * @extends {BaseAPI}
 */
export class RuntimesApi extends BaseAPI {
  /**
   *
   * @param {string} threadId Filter by thread ID
   * @param {GetRuntimesStatusEnum} [status] Filter by runtime instance status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RuntimesApi
   */
  public getRuntimes(
    threadId: string,
    status?: GetRuntimesStatusEnum,
    options?: RawAxiosRequestConfig,
  ) {
    return RuntimesApiFp(this.configuration)
      .getRuntimes(threadId, status, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const GetRuntimesStatusEnum = {
  Starting: 'Starting',
  Running: 'Running',
  Stopping: 'Stopping',
  Stopped: 'Stopped',
  Failed: 'Failed',
} as const;
export type GetRuntimesStatusEnum =
  (typeof GetRuntimesStatusEnum)[keyof typeof GetRuntimesStatusEnum];

/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettings: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/system/settings`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSettings(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SystemSettingsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSettings(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['SystemApi.getSettings']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SystemApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettings(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SystemSettingsResponseDto> {
      return localVarFp
        .getSettings(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public getSettings(options?: RawAxiosRequestConfig) {
    return SystemApiFp(this.configuration)
      .getSettings(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TemplatesApi - axios parameter creator
 * @export
 */
export const TemplatesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTemplates: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/templates`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    TemplatesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllTemplates(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<TemplateDto>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllTemplates(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TemplatesApi.getAllTemplates']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TemplatesApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTemplates(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<TemplateDto>> {
      return localVarFp
        .getAllTemplates(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TemplatesApi
   */
  public getAllTemplates(options?: RawAxiosRequestConfig) {
    return TemplatesApiFp(this.configuration)
      .getAllTemplates(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ThreadsApi - axios parameter creator
 * @export
 */
export const ThreadsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} threadId
     * @param {ThreadAnalysisRequestDto} threadAnalysisRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    analyzeThread: async (
      threadId: string,
      threadAnalysisRequestDto: ThreadAnalysisRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'threadId' is not null or undefined
      assertParamExists('analyzeThread', 'threadId', threadId);
      // verify required parameter 'threadAnalysisRequestDto' is not null or undefined
      assertParamExists(
        'analyzeThread',
        'threadAnalysisRequestDto',
        threadAnalysisRequestDto,
      );
      const localVarPath = `/api/v1/threads/{threadId}/analyze`.replace(
        `{${'threadId'}}`,
        encodeURIComponent(String(threadId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        threadAnalysisRequestDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} threadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteThread: async (
      threadId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'threadId' is not null or undefined
      assertParamExists('deleteThread', 'threadId', threadId);
      const localVarPath = `/api/v1/threads/{threadId}`.replace(
        `{${'threadId'}}`,
        encodeURIComponent(String(threadId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} externalThreadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThreadByExternalId: async (
      externalThreadId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'externalThreadId' is not null or undefined
      assertParamExists(
        'getThreadByExternalId',
        'externalThreadId',
        externalThreadId,
      );
      const localVarPath =
        `/api/v1/threads/external/{externalThreadId}`.replace(
          `{${'externalThreadId'}}`,
          encodeURIComponent(String(externalThreadId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} threadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThreadById: async (
      threadId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'threadId' is not null or undefined
      assertParamExists('getThreadById', 'threadId', threadId);
      const localVarPath = `/api/v1/threads/{threadId}`.replace(
        `{${'threadId'}}`,
        encodeURIComponent(String(threadId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} threadId
     * @param {string} [nodeId] Filter messages by node ID (agent node)
     * @param {number} [limit] Maximum number of messages to return
     * @param {number} [offset] Number of messages to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThreadMessages: async (
      threadId: string,
      nodeId?: string,
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'threadId' is not null or undefined
      assertParamExists('getThreadMessages', 'threadId', threadId);
      const localVarPath = `/api/v1/threads/{threadId}/messages`.replace(
        `{${'threadId'}}`,
        encodeURIComponent(String(threadId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (nodeId !== undefined) {
        localVarQueryParameter['nodeId'] = nodeId;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} threadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThreadUsageStatistics: async (
      threadId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'threadId' is not null or undefined
      assertParamExists('getThreadUsageStatistics', 'threadId', threadId);
      const localVarPath =
        `/api/v1/threads/{threadId}/usage-statistics`.replace(
          `{${'threadId'}}`,
          encodeURIComponent(String(threadId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [graphId] Filter by graph ID
     * @param {Array<GetThreadsStatusesEnum>} [statuses] Filter by thread statuses
     * @param {number} [limit] Maximum number of threads to return
     * @param {number} [offset] Number of threads to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThreads: async (
      graphId?: string,
      statuses?: Array<GetThreadsStatusesEnum>,
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/threads`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (graphId !== undefined) {
        localVarQueryParameter['graphId'] = graphId;
      }

      if (statuses) {
        localVarQueryParameter['statuses'] = statuses;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} threadId
     * @param {SetThreadMetadataDto} setThreadMetadataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setThreadMetadata: async (
      threadId: string,
      setThreadMetadataDto: SetThreadMetadataDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'threadId' is not null or undefined
      assertParamExists('setThreadMetadata', 'threadId', threadId);
      // verify required parameter 'setThreadMetadataDto' is not null or undefined
      assertParamExists(
        'setThreadMetadata',
        'setThreadMetadataDto',
        setThreadMetadataDto,
      );
      const localVarPath = `/api/v1/threads/{threadId}/metadata`.replace(
        `{${'threadId'}}`,
        encodeURIComponent(String(threadId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setThreadMetadataDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} externalThreadId
     * @param {SetThreadMetadataDto} setThreadMetadataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setThreadMetadataByExternalId: async (
      externalThreadId: string,
      setThreadMetadataDto: SetThreadMetadataDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'externalThreadId' is not null or undefined
      assertParamExists(
        'setThreadMetadataByExternalId',
        'externalThreadId',
        externalThreadId,
      );
      // verify required parameter 'setThreadMetadataDto' is not null or undefined
      assertParamExists(
        'setThreadMetadataByExternalId',
        'setThreadMetadataDto',
        setThreadMetadataDto,
      );
      const localVarPath =
        `/api/v1/threads/external/{externalThreadId}/metadata`.replace(
          `{${'externalThreadId'}}`,
          encodeURIComponent(String(externalThreadId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setThreadMetadataDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} threadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stopThread: async (
      threadId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'threadId' is not null or undefined
      assertParamExists('stopThread', 'threadId', threadId);
      const localVarPath = `/api/v1/threads/{threadId}/stop`.replace(
        `{${'threadId'}}`,
        encodeURIComponent(String(threadId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} externalThreadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stopThreadByExternalId: async (
      externalThreadId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'externalThreadId' is not null or undefined
      assertParamExists(
        'stopThreadByExternalId',
        'externalThreadId',
        externalThreadId,
      );
      const localVarPath =
        `/api/v1/threads/external/{externalThreadId}/stop`.replace(
          `{${'externalThreadId'}}`,
          encodeURIComponent(String(externalThreadId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} graphId
     * @param {string} nodeId
     * @param {SuggestAgentInstructionsDto} suggestAgentInstructionsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suggestAgentInstructions: async (
      graphId: string,
      nodeId: string,
      suggestAgentInstructionsDto: SuggestAgentInstructionsDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'graphId' is not null or undefined
      assertParamExists('suggestAgentInstructions', 'graphId', graphId);
      // verify required parameter 'nodeId' is not null or undefined
      assertParamExists('suggestAgentInstructions', 'nodeId', nodeId);
      // verify required parameter 'suggestAgentInstructionsDto' is not null or undefined
      assertParamExists(
        'suggestAgentInstructions',
        'suggestAgentInstructionsDto',
        suggestAgentInstructionsDto,
      );
      const localVarPath =
        `/api/v1/graphs/{graphId}/nodes/{nodeId}/suggest-instructions`
          .replace(`{${'graphId'}}`, encodeURIComponent(String(graphId)))
          .replace(`{${'nodeId'}}`, encodeURIComponent(String(nodeId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        suggestAgentInstructionsDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} graphId
     * @param {SuggestGraphInstructionsDto} suggestGraphInstructionsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suggestGraphInstructions: async (
      graphId: string,
      suggestGraphInstructionsDto: SuggestGraphInstructionsDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'graphId' is not null or undefined
      assertParamExists('suggestGraphInstructions', 'graphId', graphId);
      // verify required parameter 'suggestGraphInstructionsDto' is not null or undefined
      assertParamExists(
        'suggestGraphInstructions',
        'suggestGraphInstructionsDto',
        suggestGraphInstructionsDto,
      );
      const localVarPath =
        `/api/v1/graphs/{graphId}/suggest-instructions`.replace(
          `{${'graphId'}}`,
          encodeURIComponent(String(graphId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        suggestGraphInstructionsDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {KnowledgeContentSuggestionRequestDto} knowledgeContentSuggestionRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suggestKnowledgeContent: async (
      knowledgeContentSuggestionRequestDto: KnowledgeContentSuggestionRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'knowledgeContentSuggestionRequestDto' is not null or undefined
      assertParamExists(
        'suggestKnowledgeContent',
        'knowledgeContentSuggestionRequestDto',
        knowledgeContentSuggestionRequestDto,
      );
      const localVarPath = `/api/v1/knowledge-docs/suggest`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        knowledgeContentSuggestionRequestDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ThreadsApi - functional programming interface
 * @export
 */
export const ThreadsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ThreadsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} threadId
     * @param {ThreadAnalysisRequestDto} threadAnalysisRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async analyzeThread(
      threadId: string,
      threadAnalysisRequestDto: ThreadAnalysisRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ThreadAnalysisResponseDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.analyzeThread(
        threadId,
        threadAnalysisRequestDto,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ThreadsApi.analyzeThread']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} threadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteThread(
      threadId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteThread(
        threadId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ThreadsApi.deleteThread']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} externalThreadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getThreadByExternalId(
      externalThreadId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getThreadByExternalId(
          externalThreadId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ThreadsApi.getThreadByExternalId']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} threadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getThreadById(
      threadId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getThreadById(
        threadId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ThreadsApi.getThreadById']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} threadId
     * @param {string} [nodeId] Filter messages by node ID (agent node)
     * @param {number} [limit] Maximum number of messages to return
     * @param {number} [offset] Number of messages to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getThreadMessages(
      threadId: string,
      nodeId?: string,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<ThreadMessageDto>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getThreadMessages(
          threadId,
          nodeId,
          limit,
          offset,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ThreadsApi.getThreadMessages']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} threadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getThreadUsageStatistics(
      threadId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ThreadUsageStatisticsDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getThreadUsageStatistics(
          threadId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ThreadsApi.getThreadUsageStatistics']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} [graphId] Filter by graph ID
     * @param {Array<GetThreadsStatusesEnum>} [statuses] Filter by thread statuses
     * @param {number} [limit] Maximum number of threads to return
     * @param {number} [offset] Number of threads to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getThreads(
      graphId?: string,
      statuses?: Array<GetThreadsStatusesEnum>,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<ThreadDto>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getThreads(
        graphId,
        statuses,
        limit,
        offset,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ThreadsApi.getThreads']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} threadId
     * @param {SetThreadMetadataDto} setThreadMetadataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setThreadMetadata(
      threadId: string,
      setThreadMetadataDto: SetThreadMetadataDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setThreadMetadata(
          threadId,
          setThreadMetadataDto,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ThreadsApi.setThreadMetadata']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} externalThreadId
     * @param {SetThreadMetadataDto} setThreadMetadataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setThreadMetadataByExternalId(
      externalThreadId: string,
      setThreadMetadataDto: SetThreadMetadataDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setThreadMetadataByExternalId(
          externalThreadId,
          setThreadMetadataDto,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ThreadsApi.setThreadMetadataByExternalId']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} threadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async stopThread(
      threadId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.stopThread(
        threadId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ThreadsApi.stopThread']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} externalThreadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async stopThreadByExternalId(
      externalThreadId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.stopThreadByExternalId(
          externalThreadId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ThreadsApi.stopThreadByExternalId']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} graphId
     * @param {string} nodeId
     * @param {SuggestAgentInstructionsDto} suggestAgentInstructionsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async suggestAgentInstructions(
      graphId: string,
      nodeId: string,
      suggestAgentInstructionsDto: SuggestAgentInstructionsDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SuggestAgentInstructionsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.suggestAgentInstructions(
          graphId,
          nodeId,
          suggestAgentInstructionsDto,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ThreadsApi.suggestAgentInstructions']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} graphId
     * @param {SuggestGraphInstructionsDto} suggestGraphInstructionsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async suggestGraphInstructions(
      graphId: string,
      suggestGraphInstructionsDto: SuggestGraphInstructionsDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SuggestGraphInstructionsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.suggestGraphInstructions(
          graphId,
          suggestGraphInstructionsDto,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ThreadsApi.suggestGraphInstructions']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {KnowledgeContentSuggestionRequestDto} knowledgeContentSuggestionRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async suggestKnowledgeContent(
      knowledgeContentSuggestionRequestDto: KnowledgeContentSuggestionRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<KnowledgeContentSuggestionResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.suggestKnowledgeContent(
          knowledgeContentSuggestionRequestDto,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ThreadsApi.suggestKnowledgeContent']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ThreadsApi - factory interface
 * @export
 */
export const ThreadsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ThreadsApiFp(configuration);
  return {
    /**
     *
     * @param {string} threadId
     * @param {ThreadAnalysisRequestDto} threadAnalysisRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    analyzeThread(
      threadId: string,
      threadAnalysisRequestDto: ThreadAnalysisRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ThreadAnalysisResponseDto> {
      return localVarFp
        .analyzeThread(threadId, threadAnalysisRequestDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} threadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteThread(
      threadId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteThread(threadId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} externalThreadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThreadByExternalId(
      externalThreadId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ThreadDto> {
      return localVarFp
        .getThreadByExternalId(externalThreadId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} threadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThreadById(
      threadId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ThreadDto> {
      return localVarFp
        .getThreadById(threadId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} threadId
     * @param {string} [nodeId] Filter messages by node ID (agent node)
     * @param {number} [limit] Maximum number of messages to return
     * @param {number} [offset] Number of messages to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThreadMessages(
      threadId: string,
      nodeId?: string,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<ThreadMessageDto>> {
      return localVarFp
        .getThreadMessages(threadId, nodeId, limit, offset, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} threadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThreadUsageStatistics(
      threadId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ThreadUsageStatisticsDto> {
      return localVarFp
        .getThreadUsageStatistics(threadId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [graphId] Filter by graph ID
     * @param {Array<GetThreadsStatusesEnum>} [statuses] Filter by thread statuses
     * @param {number} [limit] Maximum number of threads to return
     * @param {number} [offset] Number of threads to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThreads(
      graphId?: string,
      statuses?: Array<GetThreadsStatusesEnum>,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<ThreadDto>> {
      return localVarFp
        .getThreads(graphId, statuses, limit, offset, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} threadId
     * @param {SetThreadMetadataDto} setThreadMetadataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setThreadMetadata(
      threadId: string,
      setThreadMetadataDto: SetThreadMetadataDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ThreadDto> {
      return localVarFp
        .setThreadMetadata(threadId, setThreadMetadataDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} externalThreadId
     * @param {SetThreadMetadataDto} setThreadMetadataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setThreadMetadataByExternalId(
      externalThreadId: string,
      setThreadMetadataDto: SetThreadMetadataDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ThreadDto> {
      return localVarFp
        .setThreadMetadataByExternalId(
          externalThreadId,
          setThreadMetadataDto,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} threadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stopThread(
      threadId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ThreadDto> {
      return localVarFp
        .stopThread(threadId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} externalThreadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stopThreadByExternalId(
      externalThreadId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ThreadDto> {
      return localVarFp
        .stopThreadByExternalId(externalThreadId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} graphId
     * @param {string} nodeId
     * @param {SuggestAgentInstructionsDto} suggestAgentInstructionsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suggestAgentInstructions(
      graphId: string,
      nodeId: string,
      suggestAgentInstructionsDto: SuggestAgentInstructionsDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SuggestAgentInstructionsResponseDto> {
      return localVarFp
        .suggestAgentInstructions(
          graphId,
          nodeId,
          suggestAgentInstructionsDto,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} graphId
     * @param {SuggestGraphInstructionsDto} suggestGraphInstructionsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suggestGraphInstructions(
      graphId: string,
      suggestGraphInstructionsDto: SuggestGraphInstructionsDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SuggestGraphInstructionsResponseDto> {
      return localVarFp
        .suggestGraphInstructions(graphId, suggestGraphInstructionsDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {KnowledgeContentSuggestionRequestDto} knowledgeContentSuggestionRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suggestKnowledgeContent(
      knowledgeContentSuggestionRequestDto: KnowledgeContentSuggestionRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<KnowledgeContentSuggestionResponseDto> {
      return localVarFp
        .suggestKnowledgeContent(knowledgeContentSuggestionRequestDto, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ThreadsApi - object-oriented interface
 * @export
 * @class ThreadsApi
 * @extends {BaseAPI}
 */
export class ThreadsApi extends BaseAPI {
  /**
   *
   * @param {string} threadId
   * @param {ThreadAnalysisRequestDto} threadAnalysisRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThreadsApi
   */
  public analyzeThread(
    threadId: string,
    threadAnalysisRequestDto: ThreadAnalysisRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ThreadsApiFp(this.configuration)
      .analyzeThread(threadId, threadAnalysisRequestDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} threadId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThreadsApi
   */
  public deleteThread(threadId: string, options?: RawAxiosRequestConfig) {
    return ThreadsApiFp(this.configuration)
      .deleteThread(threadId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} externalThreadId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThreadsApi
   */
  public getThreadByExternalId(
    externalThreadId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ThreadsApiFp(this.configuration)
      .getThreadByExternalId(externalThreadId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} threadId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThreadsApi
   */
  public getThreadById(threadId: string, options?: RawAxiosRequestConfig) {
    return ThreadsApiFp(this.configuration)
      .getThreadById(threadId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} threadId
   * @param {string} [nodeId] Filter messages by node ID (agent node)
   * @param {number} [limit] Maximum number of messages to return
   * @param {number} [offset] Number of messages to skip
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThreadsApi
   */
  public getThreadMessages(
    threadId: string,
    nodeId?: string,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return ThreadsApiFp(this.configuration)
      .getThreadMessages(threadId, nodeId, limit, offset, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} threadId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThreadsApi
   */
  public getThreadUsageStatistics(
    threadId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ThreadsApiFp(this.configuration)
      .getThreadUsageStatistics(threadId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [graphId] Filter by graph ID
   * @param {Array<GetThreadsStatusesEnum>} [statuses] Filter by thread statuses
   * @param {number} [limit] Maximum number of threads to return
   * @param {number} [offset] Number of threads to skip
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThreadsApi
   */
  public getThreads(
    graphId?: string,
    statuses?: Array<GetThreadsStatusesEnum>,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return ThreadsApiFp(this.configuration)
      .getThreads(graphId, statuses, limit, offset, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} threadId
   * @param {SetThreadMetadataDto} setThreadMetadataDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThreadsApi
   */
  public setThreadMetadata(
    threadId: string,
    setThreadMetadataDto: SetThreadMetadataDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ThreadsApiFp(this.configuration)
      .setThreadMetadata(threadId, setThreadMetadataDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} externalThreadId
   * @param {SetThreadMetadataDto} setThreadMetadataDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThreadsApi
   */
  public setThreadMetadataByExternalId(
    externalThreadId: string,
    setThreadMetadataDto: SetThreadMetadataDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ThreadsApiFp(this.configuration)
      .setThreadMetadataByExternalId(
        externalThreadId,
        setThreadMetadataDto,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} threadId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThreadsApi
   */
  public stopThread(threadId: string, options?: RawAxiosRequestConfig) {
    return ThreadsApiFp(this.configuration)
      .stopThread(threadId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} externalThreadId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThreadsApi
   */
  public stopThreadByExternalId(
    externalThreadId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ThreadsApiFp(this.configuration)
      .stopThreadByExternalId(externalThreadId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} graphId
   * @param {string} nodeId
   * @param {SuggestAgentInstructionsDto} suggestAgentInstructionsDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThreadsApi
   */
  public suggestAgentInstructions(
    graphId: string,
    nodeId: string,
    suggestAgentInstructionsDto: SuggestAgentInstructionsDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ThreadsApiFp(this.configuration)
      .suggestAgentInstructions(
        graphId,
        nodeId,
        suggestAgentInstructionsDto,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} graphId
   * @param {SuggestGraphInstructionsDto} suggestGraphInstructionsDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThreadsApi
   */
  public suggestGraphInstructions(
    graphId: string,
    suggestGraphInstructionsDto: SuggestGraphInstructionsDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ThreadsApiFp(this.configuration)
      .suggestGraphInstructions(graphId, suggestGraphInstructionsDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {KnowledgeContentSuggestionRequestDto} knowledgeContentSuggestionRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThreadsApi
   */
  public suggestKnowledgeContent(
    knowledgeContentSuggestionRequestDto: KnowledgeContentSuggestionRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ThreadsApiFp(this.configuration)
      .suggestKnowledgeContent(knowledgeContentSuggestionRequestDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const GetThreadsStatusesEnum = {
  Running: 'running',
  Done: 'done',
  NeedMoreInfo: 'need_more_info',
  Stopped: 'stopped',
} as const;
export type GetThreadsStatusesEnum =
  (typeof GetThreadsStatusesEnum)[keyof typeof GetThreadsStatusesEnum];
