import { useCallback, useState } from 'react';

import type { ThreadMessageDto } from '../autogenerated';
import type {
  MessageScopeKey,
  MessagesState,
  PendingMessage,
  PendingMessagesState,
} from '../pages/graphs/types/messages';

const DEFAULT_SCOPE_KEY: MessageScopeKey = 'all';

/**
 * Normalize message content for comparison.
 * Handles string, array, and nested object formats.
 */
const normalizeContent = (raw: unknown): string | null => {
  if (typeof raw === 'string') {
    const trimmed = raw.trim();
    return trimmed || null;
  }
  if (Array.isArray(raw) && raw.length === 1 && typeof raw[0] === 'string') {
    const trimmed = raw[0].trim();
    return trimmed || null;
  }
  if (raw && typeof raw === 'object') {
    const record = raw as Record<string, unknown>;
    const nested = record.content;
    if (typeof nested === 'string') {
      const trimmed = nested.trim();
      return trimmed || null;
    }
  }
  return null;
};

export const useThreadMessageStore = () => {
  const [messages, setMessages] = useState<MessagesState>({});
  const [pendingMessages, setPendingMessages] = useState<PendingMessagesState>(
    {},
  );
  const [externalThreadIds, setExternalThreadIds] = useState<
    Record<string, string | undefined>
  >({});

  const updateMessages = useCallback(
    (
      threadId: string,
      updater: (prev: ThreadMessageDto[]) => ThreadMessageDto[],
      nodeId?: string,
    ) => {
      setMessages((prev) => {
        const threadMessages = prev[threadId] || {};
        const key = (nodeId ?? DEFAULT_SCOPE_KEY) as MessageScopeKey;
        const currentMessages = threadMessages[key] || [];
        const updatedMessages = updater(currentMessages);

        // Fast-path: skip expensive multi-pass processing when no optimistic
        // messages exist. This covers the common streaming case.
        const hasOptimistic = updatedMessages.some(
          (msg) =>
            typeof msg.id === 'string' && msg.id.startsWith('optimistic-'),
        );

        if (!hasOptimistic) {
          const seenIds = new Set<string>();
          const deduped = updatedMessages.filter((msg) => {
            if (seenIds.has(msg.id)) return false;
            seenIds.add(msg.id);
            return true;
          });

          return {
            ...prev,
            [threadId]: {
              ...threadMessages,
              [key]: deduped,
            },
          };
        }

        /**
         * Replace optimistic messages with real ones when they arrive.
         *
         * For each real human message, find and remove any optimistic message
         * with matching content. Use the optimistic message's createdAt to
         * maintain consistent positioning in the timeline.
         */
        const optimisticByContent = new Map<string, ThreadMessageDto>();
        const realMessagesToAdd: ThreadMessageDto[] = [];
        const realMessageContents = new Set<string>();

        // First pass: collect all optimistic human messages by content
        updatedMessages.forEach((msg) => {
          const isOptimistic =
            typeof msg.id === 'string' && msg.id.startsWith('optimistic-');
          if (isOptimistic && msg.message?.role === 'human') {
            const content = normalizeContent(msg.message?.content);
            if (content) {
              // Only keep the first optimistic message with this content
              if (!optimisticByContent.has(content)) {
                optimisticByContent.set(content, msg);
              }
            }
          }
        });

        // Second pass: build final message list
        const finalMessages = updatedMessages.filter((msg) => {
          const isOptimistic =
            typeof msg.id === 'string' && msg.id.startsWith('optimistic-');

          // Keep all optimistic messages initially
          if (isOptimistic) {
            return true;
          }

          // For real human messages, check if we need to replace an optimistic one
          if (msg.message?.role === 'human') {
            const content = normalizeContent(msg.message?.content);
            if (content) {
              // Check if we've already seen this real message content
              if (realMessageContents.has(content)) {
                // Skip duplicate real messages
                return false;
              }

              if (optimisticByContent.has(content)) {
                const optimisticMsg = optimisticByContent.get(content)!;
                // Use optimistic timestamp to preserve position
                realMessagesToAdd.push({
                  ...msg,
                  createdAt: optimisticMsg.createdAt,
                  updatedAt: msg.updatedAt || optimisticMsg.updatedAt,
                });
                // Mark this optimistic message for removal
                optimisticByContent.delete(content);
                realMessageContents.add(content);
                return false; // Don't add the real message yet
              }

              // Track this real message content
              realMessageContents.add(content);
            }
          }

          return true;
        });

        // Remove optimistic messages that have been replaced
        const result = finalMessages.filter((msg) => {
          const isOptimistic =
            typeof msg.id === 'string' && msg.id.startsWith('optimistic-');
          if (!isOptimistic) {
            return true;
          }
          if (msg.message?.role === 'human') {
            const content = normalizeContent(msg.message?.content);
            // Keep only if not replaced (still in map)
            return content ? optimisticByContent.has(content) : true;
          }
          return true;
        });

        // Add the real messages that replaced optimistic ones
        const merged = [...result, ...realMessagesToAdd];

        // Sort by createdAt to maintain chronological order (Schwartzian transform
        // to avoid redundant Date parsing in the comparator).
        const decorated = merged.map((msg, i) => ({
          msg,
          ts: new Date(msg.createdAt).getTime(),
          idx: i,
        }));
        decorated.sort((a, b) => a.ts - b.ts || a.idx - b.idx);
        const sorted = decorated.map((d) => d.msg);

        // Final safety check: deduplicate by ID to catch any edge cases
        const seenIds = new Set<string>();
        const deduplicated = sorted.filter((msg) => {
          if (seenIds.has(msg.id)) {
            return false;
          }
          seenIds.add(msg.id);
          return true;
        });

        // Additional safety check: deduplicate human messages by content
        // This catches cases where the same message appears with different IDs
        const seenHumanContent = new Set<string>();
        const finalDeduplicated = deduplicated.filter((msg) => {
          if (msg.message?.role === 'human') {
            const content = normalizeContent(msg.message?.content);
            if (content) {
              if (seenHumanContent.has(content)) {
                // Prefer real messages over optimistic ones
                const isOptimistic =
                  typeof msg.id === 'string' &&
                  msg.id.startsWith('optimistic-');
                return !isOptimistic;
              }
              seenHumanContent.add(content);
            }
          }
          return true;
        });

        return {
          ...prev,
          [threadId]: {
            ...threadMessages,
            [key]: finalDeduplicated,
          },
        };
      });
    },
    [],
  );

  const updatePendingMessages = useCallback(
    (
      threadId: string,
      updater: (prev: PendingMessage[]) => PendingMessage[],
      nodeId?: string,
    ) => {
      setPendingMessages((prev) => {
        const threadPendings = prev[threadId] || {};
        const key = (nodeId ?? DEFAULT_SCOPE_KEY) as MessageScopeKey;
        const current = threadPendings[key] || [];
        const next = updater(current);

        // Deduplicate by role+content
        const seen = new Set<string>();
        const deduped = next.filter((p) => {
          const contentKey = `${p.role}-${p.content}`;
          if (seen.has(contentKey)) return false;
          seen.add(contentKey);
          return true;
        });

        return {
          ...prev,
          [threadId]: {
            ...threadPendings,
            [key]: deduped,
          },
        };
      });
    },
    [],
  );

  return {
    messages,
    updateMessages,
    pendingMessages,
    updatePendingMessages,
    externalThreadIds,
    setExternalThreadIds,
  };
};
