import { isAxiosError } from 'axios';

import {
  GraphDtoStatusEnum,
  ThreadDtoStatusEnum,
} from '../../../autogenerated';
import type { AgentStateUpdateNotification } from '../../../services/WebSocketTypes';
import type { ThreadTokenUsageSnapshot } from '../types';

export const THREADS_PAGE_SIZE = 30;
export const THREAD_MESSAGES_PAGE_SIZE = 500;
export const MAX_THREAD_SOCKET_EVENTS = 200;

export const isDraftThreadId = (threadId?: string | null): boolean => {
  return Boolean(threadId && threadId.startsWith('draft-'));
};

export const isResolvedThreadStatus = (status?: string): boolean => {
  return status === ThreadDtoStatusEnum.Done;
};

export const GRAPH_STATUS_META: Record<
  string,
  { label: string; color: string }
> = {
  [GraphDtoStatusEnum.Running]: { label: 'Running', color: '#52c41a' },
  [GraphDtoStatusEnum.Compiling]: { label: 'Compiled', color: '#1677ff' },
  [GraphDtoStatusEnum.Created]: { label: 'Created', color: '#1677ff' },
  [GraphDtoStatusEnum.Stopped]: { label: 'Stopped', color: '#bfbfbf' },
  [GraphDtoStatusEnum.Error]: { label: 'Error', color: '#ff4d4f' },
};

export const mergeTokenUsageByNode = (
  baseline: Record<string, ThreadTokenUsageSnapshot>,
  overrides: Record<string, ThreadTokenUsageSnapshot>,
): Record<string, ThreadTokenUsageSnapshot> => {
  const baseKeys = Object.keys(baseline);
  const overKeys = Object.keys(overrides);
  if (overKeys.length === 0) return baseline;

  const keys = new Set([...baseKeys, ...overKeys]);
  let changed = keys.size !== baseKeys.length;
  const merged: Record<string, ThreadTokenUsageSnapshot> = {};
  keys.forEach((key) => {
    const base = baseline[key];
    const over = overrides[key];
    if (base && !over) {
      merged[key] = base;
    } else if (!base && over) {
      changed = true;
      merged[key] = over;
    } else {
      const m = { ...base, ...over };
      if (!changed) {
        const bKeys = Object.keys(base) as (keyof ThreadTokenUsageSnapshot)[];
        const mKeys = Object.keys(m) as (keyof ThreadTokenUsageSnapshot)[];
        if (
          bKeys.length !== mKeys.length ||
          bKeys.some((k) => base[k] !== m[k])
        ) {
          changed = true;
        }
      }
      merged[key] = m;
    }
  });
  return changed ? merged : baseline;
};

const usdFormatter = new Intl.NumberFormat('en-US', {
  style: 'currency',
  currency: 'USD',
  minimumFractionDigits: 2,
  maximumFractionDigits: 2,
});

const compactFormatter = new Intl.NumberFormat('en-US', {
  notation: 'compact',
  compactDisplay: 'short',
  maximumFractionDigits: 0,
});

export const formatUsd = (amount?: number | null): string => {
  if (typeof amount !== 'number' || !Number.isFinite(amount)) return '$—';
  if (amount === 0) return '$0.00';
  if (amount > 0 && amount < 0.01) return '<$0.01';
  return usdFormatter.format(amount);
};

export const formatCompactNumber = (value?: number | null): string => {
  if (typeof value !== 'number' || !Number.isFinite(value)) return '—';
  return compactFormatter.format(value);
};

const safeNumber = (value: unknown): number | undefined => {
  return typeof value === 'number' && Number.isFinite(value)
    ? value
    : undefined;
};

export const compactUsageUpdate = (
  source: AgentStateUpdateNotification['data'],
): Partial<ThreadTokenUsageSnapshot> => {
  const next: Partial<ThreadTokenUsageSnapshot> = {};

  const inputTokens = safeNumber(source?.inputTokens);
  if (inputTokens !== undefined) next.inputTokens = inputTokens;

  const cachedInputTokens = safeNumber(source?.cachedInputTokens);
  if (cachedInputTokens !== undefined)
    next.cachedInputTokens = cachedInputTokens;

  const outputTokens = safeNumber(source?.outputTokens);
  if (outputTokens !== undefined) next.outputTokens = outputTokens;

  const reasoningTokens = safeNumber(source?.reasoningTokens);
  if (reasoningTokens !== undefined) next.reasoningTokens = reasoningTokens;

  const totalTokens = safeNumber(source?.totalTokens);
  if (totalTokens !== undefined) next.totalTokens = totalTokens;

  const totalPrice = safeNumber(source?.totalPrice);
  if (totalPrice !== undefined) next.totalPrice = totalPrice;

  const currentContext = safeNumber(source?.currentContext);
  if (currentContext !== undefined) next.currentContext = currentContext;

  return next;
};

export const sumUsage = (
  usages: ThreadTokenUsageSnapshot[],
): ThreadTokenUsageSnapshot => {
  const sumField = (
    key: keyof ThreadTokenUsageSnapshot,
  ): number | undefined => {
    let hasAny = false;
    const total = usages.reduce((acc, usage) => {
      const value = usage[key];
      if (typeof value === 'number' && Number.isFinite(value)) {
        hasAny = true;
        return acc + value;
      }
      return acc;
    }, 0);
    return hasAny ? total : undefined;
  };

  const maxField = (
    key: keyof ThreadTokenUsageSnapshot,
  ): number | undefined => {
    let hasAny = false;
    const max = usages.reduce(
      (acc, usage) => {
        const value = usage[key];
        if (typeof value === 'number' && Number.isFinite(value)) {
          hasAny = true;
          return acc === undefined || value > acc ? value : acc;
        }
        return acc;
      },
      undefined as number | undefined,
    );
    return hasAny ? max : undefined;
  };

  return {
    inputTokens: sumField('inputTokens'),
    cachedInputTokens: sumField('cachedInputTokens'),
    outputTokens: sumField('outputTokens'),
    reasoningTokens: sumField('reasoningTokens'),
    totalTokens: sumField('totalTokens'),
    totalPrice: sumField('totalPrice'),
    currentContext: maxField('currentContext'),
  };
};

export const clampPercent = (value: number): number => {
  if (!Number.isFinite(value)) return 0;
  return Math.max(0, Math.min(100, value));
};

export const getPercentColor = (percent: number): string => {
  if (percent >= 90) return '#ff4d4f';
  if (percent >= 75) return '#faad14';
  return '#52c41a';
};

export const isValidationExceptionsError = (error: unknown): boolean => {
  if (!isAxiosError(error)) return false;

  const data: unknown = error.response?.data;
  if (!data) return false;

  if (typeof data === 'string') {
    return data.toLowerCase().includes('validation exception');
  }

  if (typeof data === 'object') {
    const message: unknown = (data as Record<string, unknown>)['message'];
    if (typeof message === 'string') {
      return message.toLowerCase().includes('validation exception');
    }
  }

  return false;
};

export const DEFAULT_MESSAGE_META = {
  loading: false,
  loadingMore: false,
  hasMore: true,
  offset: 0,
  initialLoadFailed: false,
} as const;
