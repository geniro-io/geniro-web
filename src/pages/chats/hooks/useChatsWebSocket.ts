import {
  type MutableRefObject,
  useCallback,
  useEffect,
  useRef,
  useState,
} from 'react';

import { threadsApi } from '../../../api';
import type {
  TemplateDto,
  ThreadDto,
  ThreadMessageDto,
} from '../../../autogenerated';
import { ThreadDtoStatusEnum } from '../../../autogenerated';
import { useWebSocketEvent } from '../../../hooks/useWebSocket';
import type {
  MessagesState,
  MessagesUpdater,
  PendingMessagesState,
  PendingMessagesUpdater,
} from '../../../pages/graphs/types/messages';
import type {
  AgentMessageNotification,
  AgentStateUpdateNotification,
  GraphNodeUpdateNotification,
  SocketNotification,
  ThreadCreateNotification,
  ThreadDeleteNotification,
  ThreadUpdateNotification,
} from '../../../services/WebSocketTypes';
import {
  extractReasoningEntries,
  mergeMessagesReplacingStreaming,
  narrowReasoningContainer,
  upsertReasoningEntries,
} from '../../../utils/threadMessages';
import type {
  DraftThread,
  GraphCacheEntry,
  MessageMeta,
  ThreadSocketEventEntry,
  ThreadTokenUsageSnapshot,
} from '../types';
import {
  compactUsageUpdate,
  MAX_THREAD_SOCKET_EVENTS,
} from '../utils/chatsPageUtils';

/** Additive number merge — returns `existing + incoming`, treating undefined as 0. */
const addUsageField = (
  existing: number | undefined,
  incoming: number | undefined,
): number | undefined => {
  if (typeof incoming !== 'number' || !Number.isFinite(incoming))
    return existing;
  return (existing ?? 0) + incoming;
};

interface UseChatsWebSocketDeps {
  graphFilterId: string | undefined;
  selectedThreadId: string | undefined;
  draftThread: DraftThread | null;

  threadsRef: MutableRefObject<ThreadDto[]>;
  pendingThreadSelectionRef: MutableRefObject<string | null>;

  setThreads: React.Dispatch<React.SetStateAction<ThreadDto[]>>;
  setSelectedThreadId: React.Dispatch<React.SetStateAction<string | undefined>>;
  setSelectedThreadShadow: React.Dispatch<
    React.SetStateAction<ThreadDto | null>
  >;
  setDraftThread: React.Dispatch<React.SetStateAction<DraftThread | null>>;
  setExternalThreadIds: React.Dispatch<
    React.SetStateAction<Record<string, string | undefined>>
  >;
  setMessageMeta: React.Dispatch<
    React.SetStateAction<Record<string, MessageMeta>>
  >;
  setThreadTokenUsageByNode: React.Dispatch<
    React.SetStateAction<
      Record<string, Record<string, ThreadTokenUsageSnapshot>>
    >
  >;

  messages: MessagesState;
  pendingMessages: PendingMessagesState;
  updateMessages: MessagesUpdater;
  updatePendingMessages: PendingMessagesUpdater;
  externalThreadIds: Record<string, string | undefined>;

  sortThreadsByTimestampDesc: (list: ThreadDto[]) => ThreadDto[];
  getThreadTimestamp: (thread: ThreadDto) => number;
  ensureGraphsLoaded: (threads: (ThreadDto | DraftThread)[]) => Promise<void>;

  graphCache: Record<string, GraphCacheEntry>;
  templatesById: Record<string, TemplateDto>;
  invalidateThreadUsageStats: (threadId: string) => void;
}

export const useChatsWebSocket = (deps: UseChatsWebSocketDeps) => {
  const {
    graphFilterId,
    selectedThreadId,
    draftThread,
    threadsRef,
    pendingThreadSelectionRef,
    setThreads,
    setSelectedThreadId,
    setSelectedThreadShadow,
    setDraftThread,
    setExternalThreadIds,
    setMessageMeta,
    setThreadTokenUsageByNode,
    messages,
    pendingMessages,
    updateMessages,
    updatePendingMessages,
    externalThreadIds,
    sortThreadsByTimestampDesc,
    getThreadTimestamp,
    ensureGraphsLoaded,
    graphCache,
    templatesById,
    invalidateThreadUsageStats,
  } = deps;

  const draftThreadRef = useRef(draftThread);
  useEffect(() => {
    draftThreadRef.current = draftThread;
  }, [draftThread]);
  const messagesRef = useRef(messages);
  useEffect(() => {
    messagesRef.current = messages;
  }, [messages]);
  const pendingMessagesRef = useRef(pendingMessages);
  useEffect(() => {
    pendingMessagesRef.current = pendingMessages;
  }, [pendingMessages]);
  const externalThreadIdsRef = useRef(externalThreadIds);
  useEffect(() => {
    externalThreadIdsRef.current = externalThreadIds;
  }, [externalThreadIds]);
  const selectedThreadIdRef = useRef(selectedThreadId);
  useEffect(() => {
    selectedThreadIdRef.current = selectedThreadId;
  }, [selectedThreadId]);
  const graphFilterIdRef = useRef(graphFilterId);
  useEffect(() => {
    graphFilterIdRef.current = graphFilterId;
  }, [graphFilterId]);

  // Track which thread→nodeId pairs have received agent.state.update events.
  // For nodes with state updates, we skip additive requestTokenUsage from
  // the parent node's own messages (to avoid double-counting with cumulative
  // state totals) but still accumulate toolTokenUsage and subagent/comm
  // requestTokenUsage additively (subagent costs aren't in state updates
  // until the subagent completes).
  // Keyed by threadId so entries can be cleared when a thread restarts.
  const nodesWithStateUpdateRef = useRef<Map<string, Set<string>>>(new Map());

  const agentMessageBufferRef = useRef<
    Map<
      string,
      {
        threadId: string;
        scopeKeys: (string | undefined)[];
        messages: AgentMessageNotification[];
      }
    >
  >(new Map());
  const agentMessageFlushScheduledRef = useRef(false);

  const [threadSocketEvents, setThreadSocketEvents] = useState<
    Record<string, ThreadSocketEventEntry[]>
  >({});

  const resolveInternalThreadId = useCallback(
    (externalThreadId?: string) => {
      if (!externalThreadId) return undefined;
      const found = threadsRef.current.find(
        (thread) => thread.externalThreadId === externalThreadId,
      );
      return found?.id;
    },
    [threadsRef],
  );

  const appendThreadSocketEvent = useCallback(
    (threadId: string | undefined, notification: SocketNotification) => {
      if (!threadId) return;
      setThreadSocketEvents((prev) => {
        const existing = prev[threadId] ?? [];
        const receivedAt = new Date().toISOString();
        const nextEntry: ThreadSocketEventEntry = {
          id: `${threadId}-${Date.now()}-${existing.length}`,
          receivedAt,
          type: notification.type,
          nodeId: notification.nodeId,
          runId: notification.runId,
          graphId: notification.graphId,
          payload: notification,
        };
        const next = [...existing, nextEntry].slice(-MAX_THREAD_SOCKET_EVENTS);
        return { ...prev, [threadId]: next };
      });
    },
    [setThreadSocketEvents],
  );

  const shouldApplyThreadUpdate = useCallback(
    (existing: ThreadDto, incoming: ThreadDto) => {
      const incomingTs = getThreadTimestamp(incoming);
      const existingTs = getThreadTimestamp(existing);

      const hasComparableTimestamps =
        Number.isFinite(incomingTs) && Number.isFinite(existingTs);

      if (hasComparableTimestamps && incomingTs < existingTs) {
        return false;
      }

      const existingIsTerminal =
        existing.status === ThreadDtoStatusEnum.Done ||
        existing.status === ThreadDtoStatusEnum.Stopped;

      if (
        hasComparableTimestamps &&
        incomingTs === existingTs &&
        existingIsTerminal &&
        incoming.status === ThreadDtoStatusEnum.Running
      ) {
        return false;
      }

      return true;
    },
    [getThreadTimestamp],
  );

  const isAgentNodeIdInGraph = useCallback(
    (graphId: string | undefined, nodeId: string | undefined): boolean => {
      if (!graphId || !nodeId) return false;
      const graph = graphCache[graphId]?.graph;
      if (!graph) return false;
      const schemaNode = (graph.schema?.nodes ?? []).find(
        (n) => n.id === nodeId,
      );
      if (!schemaNode) return false;
      const template = templatesById[schemaNode.template];
      const kind = (template?.kind || '').toLowerCase();
      return kind === 'simpleagent' || schemaNode.template === 'simple-agent';
    },
    [graphCache, templatesById],
  );

  const buildAgentMessageScopeKeysForGraph = useCallback(
    (graphId: string | undefined, nodeId: string | undefined) => {
      return isAgentNodeIdInGraph(graphId, nodeId)
        ? [undefined, nodeId]
        : [undefined];
    },
    [isAgentNodeIdInGraph],
  );

  const applyThreadCreate = useCallback(
    (newThread: ThreadDto) => {
      if (
        graphFilterIdRef.current &&
        newThread.graphId !== graphFilterIdRef.current
      )
        return;

      const currentDraft = draftThreadRef.current;
      const isDraftReplacement =
        currentDraft &&
        pendingThreadSelectionRef.current &&
        pendingThreadSelectionRef.current === newThread.externalThreadId;

      setThreads((prev) => {
        const exists = prev.some((thread) => thread.id === newThread.id);
        if (exists) {
          const updated = prev.map((thread) =>
            thread.id === newThread.id ? newThread : thread,
          );
          return sortThreadsByTimestampDesc(updated);
        }
        return sortThreadsByTimestampDesc([newThread, ...prev]);
      });
      void ensureGraphsLoaded([newThread]);

      if (newThread.externalThreadId) {
        setExternalThreadIds((prev) => ({
          ...prev,
          [newThread.id]: newThread.externalThreadId,
        }));
      }

      if (isDraftReplacement && currentDraft) {
        const draftId = currentDraft.id;

        const draftThreadMessages = messagesRef.current[draftId];
        if (draftThreadMessages) {
          Object.entries(draftThreadMessages).forEach(([scopeKey, msgs]) => {
            const nodeScope = scopeKey === 'all' ? undefined : scopeKey;
            const migratedMessages = msgs.map((msg) => ({
              ...msg,
              threadId: newThread.id,
              externalThreadId:
                newThread.externalThreadId || msg.externalThreadId,
            }));
            updateMessages(newThread.id, () => migratedMessages, nodeScope);
          });

          const draftAllMessages = draftThreadMessages['all'] ?? [];
          setMessageMeta((prev) => ({
            ...prev,
            [newThread.id]: {
              loading: false,
              loadingMore: false,
              hasMore: true,
              offset: draftAllMessages.length,
              initialLoadFailed: false,
            },
          }));
        }

        const draftPending = pendingMessagesRef.current[draftId];
        if (draftPending) {
          Object.entries(draftPending).forEach(([scopeKey, msgs]) => {
            const nodeScope = scopeKey === 'all' ? undefined : scopeKey;
            updatePendingMessages(newThread.id, () => msgs ?? [], nodeScope);
          });
        }

        setDraftThread(null);
        setSelectedThreadId(newThread.id);
        pendingThreadSelectionRef.current = null;

        // Safety net: re-fetch thread after a delay to pick up the
        // AI-generated name that may have been missed during the
        // draft-to-real transition (WebSocket subscription gap).
        const refetchThreadId = newThread.id;
        setTimeout(() => {
          void (async () => {
            try {
              const response = await threadsApi.getThreadById(refetchThreadId);
              const refreshed = response.data;
              if (!refreshed) return;

              setThreads((prev) => {
                const idx = prev.findIndex((t) => t.id === refetchThreadId);
                if (idx === -1) return prev;
                const existing = prev[idx];
                if (
                  existing.name === refreshed.name &&
                  existing.status === refreshed.status
                ) {
                  return prev;
                }
                const next = [...prev];
                next[idx] = { ...existing, ...refreshed };
                return sortThreadsByTimestampDesc(next);
              });
            } catch {
              // Best-effort — thread list is already populated
            }
          })();
        }, 3000);
      } else if (
        pendingThreadSelectionRef.current &&
        pendingThreadSelectionRef.current === newThread.externalThreadId
      ) {
        setSelectedThreadId(newThread.id);
        pendingThreadSelectionRef.current = null;
      }
    },
    [
      ensureGraphsLoaded,
      setExternalThreadIds,
      sortThreadsByTimestampDesc,
      updateMessages,
      updatePendingMessages,
      setThreads,
      setSelectedThreadId,
      setDraftThread,
      setMessageMeta,
      pendingThreadSelectionRef,
    ],
  );

  const handleThreadCreateEvent = useCallback(
    (notification: ThreadCreateNotification) => {
      const newThread = notification.data;
      const newThreadId =
        newThread?.id ||
        notification.internalThreadId ||
        resolveInternalThreadId(notification.threadId);
      appendThreadSocketEvent(newThreadId, notification);
      if (newThread) {
        applyThreadCreate(newThread);
        return;
      }

      const externalThreadId = notification.threadId;
      if (!externalThreadId) return;

      void (async () => {
        try {
          const response =
            await threadsApi.getThreadByExternalId(externalThreadId);
          const fetchedThread = response.data;
          if (!fetchedThread) return;
          applyThreadCreate(fetchedThread);
        } catch (error) {
          console.error('Error fetching thread by external ID:', error);
        }
      })();
    },
    [appendThreadSocketEvent, applyThreadCreate, resolveInternalThreadId],
  );

  const handleThreadUpdateEvent = useCallback(
    (notification: ThreadUpdateNotification) => {
      const updatedThread = notification.data;
      if (!updatedThread) return;
      appendThreadSocketEvent(updatedThread.id, notification);
      if (
        graphFilterIdRef.current &&
        updatedThread.graphId !== graphFilterIdRef.current
      )
        return;

      setThreads((prev) => {
        const index = prev.findIndex(
          (thread) => thread.id === updatedThread.id,
        );
        if (index === -1) {
          // Thread not yet in list — add it instead of dropping.
          // This handles the race where ThreadUpdate arrives before
          // ThreadCreate (e.g. eager creation + notification handler timing).
          // Graph-level filtering already happened above, so the thread
          // is relevant to the current view.
          return sortThreadsByTimestampDesc([updatedThread, ...prev]);
        }
        const currentThread = prev[index];

        if (!shouldApplyThreadUpdate(currentThread, updatedThread)) {
          return prev;
        }
        const next = [...prev];
        next[index] = updatedThread;
        return sortThreadsByTimestampDesc(next);
      });

      // Ensure graph cache is populated for this thread (idempotent —
      // skips fetch if already cached). Needed when ThreadUpdate adds
      // a previously-unknown thread to the list.
      void ensureGraphsLoaded([updatedThread]);

      if (selectedThreadIdRef.current === updatedThread.id) {
        setSelectedThreadShadow(updatedThread);
      }

      if (updatedThread.externalThreadId) {
        setExternalThreadIds((prev) => ({
          ...prev,
          [updatedThread.id]: updatedThread.externalThreadId,
        }));
      }

      if (
        pendingThreadSelectionRef.current &&
        pendingThreadSelectionRef.current === updatedThread.externalThreadId
      ) {
        setSelectedThreadId(updatedThread.id);
        pendingThreadSelectionRef.current = null;
      }

      // Invalidate cached usage stats and clear the state-update tracking
      // when a thread finishes so the auto-load effect refetches fresh totals
      // from the API and future re-runs start with a clean slate.
      if (
        updatedThread.status === ThreadDtoStatusEnum.Done ||
        updatedThread.status === ThreadDtoStatusEnum.Stopped
      ) {
        invalidateThreadUsageStats(updatedThread.id);
        nodesWithStateUpdateRef.current.delete(updatedThread.id);
      }
    },
    [
      appendThreadSocketEvent,
      ensureGraphsLoaded,
      setExternalThreadIds,
      shouldApplyThreadUpdate,
      sortThreadsByTimestampDesc,
      setThreads,
      setSelectedThreadId,
      setSelectedThreadShadow,
      pendingThreadSelectionRef,
      invalidateThreadUsageStats,
    ],
  );

  const handleThreadDeleteEvent = useCallback(
    (notification: ThreadDeleteNotification) => {
      const deletedThread = notification.data;
      if (!deletedThread) return;
      appendThreadSocketEvent(deletedThread.id, notification);
      setThreads((prev) =>
        prev.filter((thread) => thread.id !== deletedThread.id),
      );
      if (selectedThreadIdRef.current === deletedThread.id) {
        setSelectedThreadId(undefined);
        setSelectedThreadShadow(null);
      }
      if (
        pendingThreadSelectionRef.current &&
        pendingThreadSelectionRef.current === deletedThread.externalThreadId
      ) {
        pendingThreadSelectionRef.current = null;
      }
    },
    [
      appendThreadSocketEvent,
      setThreads,
      setSelectedThreadId,
      setSelectedThreadShadow,
      pendingThreadSelectionRef,
    ],
  );

  // Register all WS event handlers
  useWebSocketEvent('thread.create', (notification) =>
    handleThreadCreateEvent(notification as ThreadCreateNotification),
  );
  useWebSocketEvent('thread.update', (notification) =>
    handleThreadUpdateEvent(notification as ThreadUpdateNotification),
  );
  useWebSocketEvent('thread.delete', (notification) =>
    handleThreadDeleteEvent(notification as ThreadDeleteNotification),
  );

  useWebSocketEvent('graph.node.update', (notification) => {
    const data = notification as GraphNodeUpdateNotification;
    const eventThreadId =
      (typeof data.threadId === 'string' && data.threadId.length > 0
        ? data.threadId
        : undefined) ??
      (typeof data.data?.metadata?.threadId === 'string'
        ? data.data.metadata.threadId
        : undefined);
    const eventInternalThreadId =
      typeof data.internalThreadId === 'string' &&
      data.internalThreadId.length > 0
        ? data.internalThreadId
        : undefined;
    const metadataRunId =
      typeof data.data?.metadata?.runId === 'string'
        ? data.data.metadata.runId
        : undefined;
    const internalThreadId =
      eventInternalThreadId || resolveInternalThreadId(eventThreadId);

    const targetThreadId = internalThreadId ?? eventThreadId;
    if (!targetThreadId) return;
    appendThreadSocketEvent(targetThreadId, data);

    const externalThreadIdForTarget =
      externalThreadIdsRef.current[targetThreadId] ?? eventThreadId;

    if (eventThreadId) {
      setExternalThreadIds((prev) => {
        const existing = prev[targetThreadId];
        if (existing === eventThreadId) return prev;
        return { ...prev, [targetThreadId]: eventThreadId };
      });
    }

    const reasoningChunks = data.data?.additionalNodeMetadata?.reasoningChunks;
    if (!reasoningChunks) return;

    const applyUpdateToKeys = buildAgentMessageScopeKeysForGraph(
      data.graphId,
      data.nodeId,
    );

    const reasoningContainer = narrowReasoningContainer(reasoningChunks, [
      eventThreadId,
      externalThreadIdForTarget,
      data.runId ?? metadataRunId,
    ]);
    const reasoningEntries = extractReasoningEntries(reasoningContainer, {
      threadId: externalThreadIdForTarget ?? eventThreadId,
      runId: data.runId ?? metadataRunId,
    });

    if (reasoningEntries.length > 0) {
      applyUpdateToKeys.forEach((key) => {
        updateMessages(
          targetThreadId,
          (prev) =>
            upsertReasoningEntries(prev, reasoningEntries, {
              externalThreadId: externalThreadIdForTarget,
              runId: data.runId ?? metadataRunId,
              selectedThreadId: targetThreadId,
              nodeId: key,
            }),
          key,
        );
      });
    }
  });

  const flushAgentMessages = useCallback(() => {
    agentMessageFlushScheduledRef.current = false;
    const buffer = agentMessageBufferRef.current;
    if (buffer.size === 0) return;

    const snapshot = new Map(buffer);
    buffer.clear();

    // Accumulate all token usage updates to apply in a single setState call
    const tokenUsageUpdates: {
      threadId: string;
      nodeId: string;
      usageToAccumulate: NonNullable<
        AgentMessageNotification['data']['requestTokenUsage']
      >;
    }[] = [];

    // Track the last externalThreadId per thread (last one wins)
    const externalThreadIdUpdates = new Map<string, string>();

    snapshot.forEach(({ threadId, scopeKeys, messages }) => {
      // Batch-normalize all incoming messages and merge in a single call per scope key.
      // This avoids O(B * N log N) from calling mergeMessagesReplacingStreaming per message.
      scopeKeys.forEach((key) => {
        updateMessages(
          threadId,
          (prev) => {
            const existingIds = new Set(prev.map((m) => m.id));
            const lastPrevCreatedAt =
              prev.length > 0 ? prev[prev.length - 1].createdAt : undefined;

            const normalizedIncoming: ThreadMessageDto[] = [];
            let maxCreatedAtMs = lastPrevCreatedAt
              ? new Date(lastPrevCreatedAt).getTime()
              : -Infinity;

            for (const msg of messages) {
              let normalized = msg.data;

              if (!existingIds.has(normalized.id)) {
                const incomingMs = new Date(normalized.createdAt).getTime();
                if (
                  Number.isFinite(maxCreatedAtMs) &&
                  Number.isFinite(incomingMs) &&
                  incomingMs < maxCreatedAtMs
                ) {
                  normalized = {
                    ...normalized,
                    createdAt: new Date(maxCreatedAtMs + 1).toISOString(),
                  };
                }
                const normalizedMs = new Date(normalized.createdAt).getTime();
                if (
                  Number.isFinite(normalizedMs) &&
                  normalizedMs > maxCreatedAtMs
                ) {
                  maxCreatedAtMs = normalizedMs;
                }
              }

              normalizedIncoming.push(normalized);
            }

            return mergeMessagesReplacingStreaming(prev, normalizedIncoming);
          },
          key,
        );
      });

      // Batch pending message removals: collect all human message contents
      const humanContents = new Set<string>();
      for (const msg of messages) {
        const content = msg.data.message?.content;
        const role = msg.data.message?.role as string | undefined;
        if (typeof content === 'string' && role === 'human') {
          humanContents.add(content);
        }
      }
      if (humanContents.size > 0) {
        scopeKeys.forEach((key) => {
          updatePendingMessages(
            threadId,
            (prev) =>
              prev.filter(
                (p) =>
                  typeof p.content !== 'string' ||
                  !humanContents.has(p.content),
              ),
            key,
          );
        });
      }

      // Track externalThreadId — last message with one wins
      for (const msg of messages) {
        if (msg.data.externalThreadId) {
          externalThreadIdUpdates.set(threadId, msg.data.externalThreadId);
        }
      }

      // Accumulate token usage for all messages in this thread
      for (const msg of messages) {
        const nodeId = msg.nodeId;
        const incomingMessage = msg.data;
        const reqUsage = incomingMessage.requestTokenUsage;
        const toolUsage = incomingMessage.toolTokenUsage;
        const threadNodeSet = nodesWithStateUpdateRef.current.get(threadId);
        const nodeHasStateUpdates = threadNodeSet?.has(nodeId) ?? false;

        const msgRecord = incomingMessage.message as unknown as
          | Record<string, unknown>
          | undefined;
        const msgKwargs =
          msgRecord?.additionalKwargs ?? msgRecord?.additional_kwargs;
        const isSubagentOrCommMessage =
          typeof msgKwargs === 'object' &&
          msgKwargs !== null &&
          (Boolean(
            (msgKwargs as Record<string, unknown>).__subagentCommunication,
          ) ||
            Boolean(
              (msgKwargs as Record<string, unknown>).__interAgentCommunication,
            ));

        const usageToAccumulate =
          isSubagentOrCommMessage && reqUsage
            ? reqUsage
            : !nodeHasStateUpdates && reqUsage
              ? reqUsage
              : toolUsage;

        if (usageToAccumulate && nodeId) {
          tokenUsageUpdates.push({
            threadId,
            nodeId,
            usageToAccumulate,
          });
        }
      }
    });

    // Apply externalThreadId updates in a single setState call
    if (externalThreadIdUpdates.size > 0) {
      setExternalThreadIds((prev) => {
        const updates: Record<string, string> = {};
        let changed = false;
        externalThreadIdUpdates.forEach((extId, tid) => {
          if (prev[tid] !== extId) {
            updates[tid] = extId;
            changed = true;
          }
        });
        return changed ? { ...prev, ...updates } : prev;
      });
    }

    // Apply all token usage updates in a single setState call
    if (tokenUsageUpdates.length > 0) {
      setThreadTokenUsageByNode((prev) => {
        let result = prev;
        for (const {
          threadId,
          nodeId,
          usageToAccumulate,
        } of tokenUsageUpdates) {
          const existingThread = result[threadId] ?? {};
          const existingNode = existingThread[nodeId] ?? {};
          result = {
            ...result,
            [threadId]: {
              ...existingThread,
              [nodeId]: {
                inputTokens: addUsageField(
                  existingNode.inputTokens,
                  usageToAccumulate.inputTokens,
                ),
                cachedInputTokens: addUsageField(
                  existingNode.cachedInputTokens,
                  usageToAccumulate.cachedInputTokens,
                ),
                outputTokens: addUsageField(
                  existingNode.outputTokens,
                  usageToAccumulate.outputTokens,
                ),
                reasoningTokens: addUsageField(
                  existingNode.reasoningTokens,
                  usageToAccumulate.reasoningTokens,
                ),
                totalTokens: addUsageField(
                  existingNode.totalTokens,
                  usageToAccumulate.totalTokens,
                ),
                totalPrice: addUsageField(
                  existingNode.totalPrice,
                  usageToAccumulate.totalPrice,
                ),
                currentContext:
                  typeof usageToAccumulate.currentContext === 'number' &&
                  Number.isFinite(usageToAccumulate.currentContext)
                    ? usageToAccumulate.currentContext
                    : existingNode.currentContext,
              },
            },
          };
        }
        return result;
      });
    }
  }, [
    updateMessages,
    updatePendingMessages,
    setExternalThreadIds,
    setThreadTokenUsageByNode,
  ]);

  useWebSocketEvent('agent.message', (notification) => {
    const data = notification as AgentMessageNotification;
    if (!data.internalThreadId) return;

    const threadId = data.internalThreadId;
    appendThreadSocketEvent(threadId, data);

    const scopeKeys = buildAgentMessageScopeKeysForGraph(
      data.graphId,
      data.nodeId,
    );

    // Buffer the message for batched processing
    const buffer = agentMessageBufferRef.current;
    const existing = buffer.get(threadId);
    if (existing) {
      // Merge scope keys (union) and append message
      const mergedKeys = new Set([...existing.scopeKeys, ...scopeKeys]);
      existing.scopeKeys = Array.from(mergedKeys);
      existing.messages.push(data);
    } else {
      buffer.set(threadId, {
        threadId,
        scopeKeys: [...scopeKeys],
        messages: [data],
      });
    }

    // Schedule flush via microtask if not already scheduled
    if (!agentMessageFlushScheduledRef.current) {
      agentMessageFlushScheduledRef.current = true;
      setTimeout(flushAgentMessages, 0);
    }
  });

  useWebSocketEvent('agent.state.update', (notification) => {
    const data = notification as AgentStateUpdateNotification;
    const internalThreadId =
      (typeof data.internalThreadId === 'string' && data.internalThreadId) ||
      resolveInternalThreadId(data.threadId);
    if (!internalThreadId) return;
    appendThreadSocketEvent(internalThreadId, data);
    if (!data.nodeId) return;

    // Mark this node as receiving cumulative state updates so we skip
    // additive requestTokenUsage from agent.message for the same node.
    let threadNodeSet = nodesWithStateUpdateRef.current.get(internalThreadId);
    if (!threadNodeSet) {
      threadNodeSet = new Set();
      nodesWithStateUpdateRef.current.set(internalThreadId, threadNodeSet);
    }
    threadNodeSet.add(data.nodeId);

    const usageUpdate = compactUsageUpdate(data.data ?? {});
    if (Object.keys(usageUpdate).length === 0) return;

    setThreadTokenUsageByNode((prev) => {
      const existingThread = prev[internalThreadId] ?? {};
      const existingNode = existingThread[data.nodeId] ?? {};
      return {
        ...prev,
        [internalThreadId]: {
          ...existingThread,
          [data.nodeId]: {
            ...existingNode,
            ...usageUpdate,
          },
        },
      };
    });
  });

  return {
    applyThreadCreate,
    isAgentNodeIdInGraph,
    resolveInternalThreadId,
    threadSocketEvents,
  };
};
