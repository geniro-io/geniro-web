import {
  type MutableRefObject,
  useCallback,
  useEffect,
  useRef,
  useState,
} from 'react';

import { threadsApi } from '../../../api';
import type { TemplateDto, ThreadDto } from '../../../autogenerated';
import { ThreadDtoStatusEnum } from '../../../autogenerated';
import { useWebSocketEvent } from '../../../hooks/useWebSocket';
import type {
  MessagesState,
  MessagesUpdater,
  PendingMessagesState,
  PendingMessagesUpdater,
} from '../../../pages/graphs/types/messages';
import type {
  AgentMessageNotification,
  AgentStateUpdateNotification,
  GraphNodeUpdateNotification,
  SocketNotification,
  ThreadCreateNotification,
  ThreadDeleteNotification,
  ThreadUpdateNotification,
} from '../../../services/WebSocketTypes';
import {
  extractReasoningEntries,
  mergeMessagesReplacingStreaming,
  narrowReasoningContainer,
  upsertReasoningEntries,
} from '../../../utils/threadMessages';
import type {
  DraftThread,
  GraphCacheEntry,
  MessageMeta,
  ThreadSocketEventEntry,
  ThreadTokenUsageSnapshot,
} from '../types';
import {
  compactUsageUpdate,
  MAX_THREAD_SOCKET_EVENTS,
  normalizeIncomingCreatedAtForDisplay,
} from '../utils/chatsPageUtils';

/** Additive number merge — returns `existing + incoming`, treating undefined as 0. */
const addUsageField = (
  existing: number | undefined,
  incoming: number | undefined,
): number | undefined => {
  if (typeof incoming !== 'number' || !Number.isFinite(incoming))
    return existing;
  return (existing ?? 0) + incoming;
};

interface UseChatsWebSocketDeps {
  graphFilterId: string | undefined;
  selectedThreadId: string | undefined;
  draftThread: DraftThread | null;

  threadsRef: MutableRefObject<ThreadDto[]>;
  pendingThreadSelectionRef: MutableRefObject<string | null>;

  setThreads: React.Dispatch<React.SetStateAction<ThreadDto[]>>;
  setSelectedThreadId: React.Dispatch<React.SetStateAction<string | undefined>>;
  setSelectedThreadShadow: React.Dispatch<
    React.SetStateAction<ThreadDto | null>
  >;
  setDraftThread: React.Dispatch<React.SetStateAction<DraftThread | null>>;
  setExternalThreadIds: React.Dispatch<
    React.SetStateAction<Record<string, string | undefined>>
  >;
  setMessageMeta: React.Dispatch<
    React.SetStateAction<Record<string, MessageMeta>>
  >;
  setThreadTokenUsageByNode: React.Dispatch<
    React.SetStateAction<
      Record<string, Record<string, ThreadTokenUsageSnapshot>>
    >
  >;

  messages: MessagesState;
  pendingMessages: PendingMessagesState;
  updateMessages: MessagesUpdater;
  updatePendingMessages: PendingMessagesUpdater;
  externalThreadIds: Record<string, string | undefined>;

  sortThreadsByTimestampDesc: (list: ThreadDto[]) => ThreadDto[];
  getThreadTimestamp: (thread: ThreadDto) => number;
  ensureGraphsLoaded: (threads: (ThreadDto | DraftThread)[]) => Promise<void>;

  graphCache: Record<string, GraphCacheEntry>;
  templatesById: Record<string, TemplateDto>;
  invalidateThreadUsageStats: (threadId: string) => void;
}

export const useChatsWebSocket = (deps: UseChatsWebSocketDeps) => {
  const {
    graphFilterId,
    selectedThreadId,
    draftThread,
    threadsRef,
    pendingThreadSelectionRef,
    setThreads,
    setSelectedThreadId,
    setSelectedThreadShadow,
    setDraftThread,
    setExternalThreadIds,
    setMessageMeta,
    setThreadTokenUsageByNode,
    messages,
    pendingMessages,
    updateMessages,
    updatePendingMessages,
    externalThreadIds,
    sortThreadsByTimestampDesc,
    getThreadTimestamp,
    ensureGraphsLoaded,
    graphCache,
    templatesById,
    invalidateThreadUsageStats,
  } = deps;

  const draftThreadRef = useRef(draftThread);
  useEffect(() => {
    draftThreadRef.current = draftThread;
  }, [draftThread]);
  const messagesRef = useRef(messages);
  useEffect(() => {
    messagesRef.current = messages;
  }, [messages]);
  const pendingMessagesRef = useRef(pendingMessages);
  useEffect(() => {
    pendingMessagesRef.current = pendingMessages;
  }, [pendingMessages]);
  const externalThreadIdsRef = useRef(externalThreadIds);
  useEffect(() => {
    externalThreadIdsRef.current = externalThreadIds;
  }, [externalThreadIds]);
  const selectedThreadIdRef = useRef(selectedThreadId);
  useEffect(() => {
    selectedThreadIdRef.current = selectedThreadId;
  }, [selectedThreadId]);
  const graphFilterIdRef = useRef(graphFilterId);
  useEffect(() => {
    graphFilterIdRef.current = graphFilterId;
  }, [graphFilterId]);

  // Track which thread→nodeId pairs have received agent.state.update events.
  // For nodes with state updates, we skip additive requestTokenUsage from
  // the parent node's own messages (to avoid double-counting with cumulative
  // state totals) but still accumulate toolTokenUsage and subagent/comm
  // requestTokenUsage additively (subagent costs aren't in state updates
  // until the subagent completes).
  // Keyed by threadId so entries can be cleared when a thread restarts.
  const nodesWithStateUpdateRef = useRef<Map<string, Set<string>>>(new Map());

  const [threadSocketEvents, setThreadSocketEvents] = useState<
    Record<string, ThreadSocketEventEntry[]>
  >({});

  const resolveInternalThreadId = useCallback(
    (externalThreadId?: string) => {
      if (!externalThreadId) return undefined;
      const found = threadsRef.current.find(
        (thread) => thread.externalThreadId === externalThreadId,
      );
      return found?.id;
    },
    [threadsRef],
  );

  const appendThreadSocketEvent = useCallback(
    (threadId: string | undefined, notification: SocketNotification) => {
      if (!threadId) return;
      setThreadSocketEvents((prev) => {
        const existing = prev[threadId] ?? [];
        const receivedAt = new Date().toISOString();
        const nextEntry: ThreadSocketEventEntry = {
          id: `${threadId}-${Date.now()}-${existing.length}`,
          receivedAt,
          type: notification.type,
          nodeId: notification.nodeId,
          runId: notification.runId,
          graphId: notification.graphId,
          payload: notification,
        };
        const next = [...existing, nextEntry].slice(-MAX_THREAD_SOCKET_EVENTS);
        return { ...prev, [threadId]: next };
      });
    },
    [setThreadSocketEvents],
  );

  const shouldApplyThreadUpdate = useCallback(
    (existing: ThreadDto, incoming: ThreadDto) => {
      const incomingTs = getThreadTimestamp(incoming);
      const existingTs = getThreadTimestamp(existing);

      const hasComparableTimestamps =
        Number.isFinite(incomingTs) && Number.isFinite(existingTs);

      if (hasComparableTimestamps && incomingTs < existingTs) {
        return false;
      }

      const existingIsTerminal =
        existing.status === ThreadDtoStatusEnum.Done ||
        existing.status === ThreadDtoStatusEnum.Stopped;

      if (
        hasComparableTimestamps &&
        incomingTs === existingTs &&
        existingIsTerminal &&
        incoming.status === ThreadDtoStatusEnum.Running
      ) {
        return false;
      }

      return true;
    },
    [getThreadTimestamp],
  );

  const isAgentNodeIdInGraph = useCallback(
    (graphId: string | undefined, nodeId: string | undefined): boolean => {
      if (!graphId || !nodeId) return false;
      const graph = graphCache[graphId]?.graph;
      if (!graph) return false;
      const schemaNode = (graph.schema?.nodes ?? []).find(
        (n) => n.id === nodeId,
      );
      if (!schemaNode) return false;
      const template = templatesById[schemaNode.template];
      const kind = (template?.kind || '').toLowerCase();
      return kind === 'simpleagent' || schemaNode.template === 'simple-agent';
    },
    [graphCache, templatesById],
  );

  const buildAgentMessageScopeKeysForGraph = useCallback(
    (graphId: string | undefined, nodeId: string | undefined) => {
      return isAgentNodeIdInGraph(graphId, nodeId)
        ? [undefined, nodeId]
        : [undefined];
    },
    [isAgentNodeIdInGraph],
  );

  const applyThreadCreate = useCallback(
    (newThread: ThreadDto) => {
      if (
        graphFilterIdRef.current &&
        newThread.graphId !== graphFilterIdRef.current
      )
        return;

      const currentDraft = draftThreadRef.current;
      const isDraftReplacement =
        currentDraft &&
        pendingThreadSelectionRef.current &&
        pendingThreadSelectionRef.current === newThread.externalThreadId;

      setThreads((prev) => {
        const exists = prev.some((thread) => thread.id === newThread.id);
        if (exists) {
          const updated = prev.map((thread) =>
            thread.id === newThread.id ? newThread : thread,
          );
          return sortThreadsByTimestampDesc(updated);
        }
        return sortThreadsByTimestampDesc([newThread, ...prev]);
      });
      void ensureGraphsLoaded([newThread]);

      if (newThread.externalThreadId) {
        setExternalThreadIds((prev) => ({
          ...prev,
          [newThread.id]: newThread.externalThreadId,
        }));
      }

      if (isDraftReplacement && currentDraft) {
        const draftId = currentDraft.id;

        const draftThreadMessages = messagesRef.current[draftId];
        if (draftThreadMessages) {
          Object.entries(draftThreadMessages).forEach(([scopeKey, msgs]) => {
            const nodeScope = scopeKey === 'all' ? undefined : scopeKey;
            const migratedMessages = msgs.map((msg) => ({
              ...msg,
              threadId: newThread.id,
              externalThreadId:
                newThread.externalThreadId || msg.externalThreadId,
            }));
            updateMessages(newThread.id, () => migratedMessages, nodeScope);
          });

          const draftAllMessages = draftThreadMessages['all'] ?? [];
          setMessageMeta((prev) => ({
            ...prev,
            [newThread.id]: {
              loading: false,
              loadingMore: false,
              hasMore: true,
              offset: draftAllMessages.length,
              initialLoadFailed: false,
            },
          }));
        }

        const draftPending = pendingMessagesRef.current[draftId];
        if (draftPending) {
          Object.entries(draftPending).forEach(([scopeKey, msgs]) => {
            const nodeScope = scopeKey === 'all' ? undefined : scopeKey;
            updatePendingMessages(newThread.id, () => msgs ?? [], nodeScope);
          });
        }

        setDraftThread(null);
        setSelectedThreadId(newThread.id);
        pendingThreadSelectionRef.current = null;

        // Safety net: re-fetch thread after a delay to pick up the
        // AI-generated name that may have been missed during the
        // draft-to-real transition (WebSocket subscription gap).
        const refetchThreadId = newThread.id;
        setTimeout(() => {
          void (async () => {
            try {
              const response = await threadsApi.getThreadById(refetchThreadId);
              const refreshed = response.data;
              if (!refreshed) return;

              setThreads((prev) => {
                const idx = prev.findIndex((t) => t.id === refetchThreadId);
                if (idx === -1) return prev;
                const existing = prev[idx];
                if (
                  existing.name === refreshed.name &&
                  existing.status === refreshed.status
                ) {
                  return prev;
                }
                const next = [...prev];
                next[idx] = { ...existing, ...refreshed };
                return sortThreadsByTimestampDesc(next);
              });
            } catch {
              // Best-effort — thread list is already populated
            }
          })();
        }, 3000);
      } else if (
        pendingThreadSelectionRef.current &&
        pendingThreadSelectionRef.current === newThread.externalThreadId
      ) {
        setSelectedThreadId(newThread.id);
        pendingThreadSelectionRef.current = null;
      }
    },
    [
      ensureGraphsLoaded,
      setExternalThreadIds,
      sortThreadsByTimestampDesc,
      updateMessages,
      updatePendingMessages,
      setThreads,
      setSelectedThreadId,
      setDraftThread,
      setMessageMeta,
      pendingThreadSelectionRef,
    ],
  );

  const handleThreadCreateEvent = useCallback(
    (notification: ThreadCreateNotification) => {
      const newThread = notification.data;
      const newThreadId =
        newThread?.id ||
        notification.internalThreadId ||
        resolveInternalThreadId(notification.threadId);
      appendThreadSocketEvent(newThreadId, notification);
      if (newThread) {
        applyThreadCreate(newThread);
        return;
      }

      const externalThreadId = notification.threadId;
      if (!externalThreadId) return;

      void (async () => {
        try {
          const response =
            await threadsApi.getThreadByExternalId(externalThreadId);
          const fetchedThread = response.data;
          if (!fetchedThread) return;
          applyThreadCreate(fetchedThread);
        } catch (error) {
          console.error('Error fetching thread by external ID:', error);
        }
      })();
    },
    [appendThreadSocketEvent, applyThreadCreate, resolveInternalThreadId],
  );

  const handleThreadUpdateEvent = useCallback(
    (notification: ThreadUpdateNotification) => {
      const updatedThread = notification.data;
      if (!updatedThread) return;
      appendThreadSocketEvent(updatedThread.id, notification);
      if (
        graphFilterIdRef.current &&
        updatedThread.graphId !== graphFilterIdRef.current
      )
        return;

      setThreads((prev) => {
        const index = prev.findIndex(
          (thread) => thread.id === updatedThread.id,
        );
        if (index === -1) {
          // Thread not yet in list — add it instead of dropping.
          // This handles the race where ThreadUpdate arrives before
          // ThreadCreate (e.g. eager creation + notification handler timing).
          // Graph-level filtering already happened above, so the thread
          // is relevant to the current view.
          return sortThreadsByTimestampDesc([updatedThread, ...prev]);
        }
        const currentThread = prev[index];

        if (!shouldApplyThreadUpdate(currentThread, updatedThread)) {
          return prev;
        }
        const next = [...prev];
        next[index] = updatedThread;
        return sortThreadsByTimestampDesc(next);
      });

      // Ensure graph cache is populated for this thread (idempotent —
      // skips fetch if already cached). Needed when ThreadUpdate adds
      // a previously-unknown thread to the list.
      void ensureGraphsLoaded([updatedThread]);

      if (selectedThreadIdRef.current === updatedThread.id) {
        setSelectedThreadShadow(updatedThread);
      }

      if (updatedThread.externalThreadId) {
        setExternalThreadIds((prev) => ({
          ...prev,
          [updatedThread.id]: updatedThread.externalThreadId,
        }));
      }

      if (
        pendingThreadSelectionRef.current &&
        pendingThreadSelectionRef.current === updatedThread.externalThreadId
      ) {
        setSelectedThreadId(updatedThread.id);
        pendingThreadSelectionRef.current = null;
      }

      // Invalidate cached usage stats and clear the state-update tracking
      // when a thread finishes so the auto-load effect refetches fresh totals
      // from the API and future re-runs start with a clean slate.
      if (
        updatedThread.status === ThreadDtoStatusEnum.Done ||
        updatedThread.status === ThreadDtoStatusEnum.Stopped
      ) {
        invalidateThreadUsageStats(updatedThread.id);
        nodesWithStateUpdateRef.current.delete(updatedThread.id);
      }
    },
    [
      appendThreadSocketEvent,
      ensureGraphsLoaded,
      setExternalThreadIds,
      shouldApplyThreadUpdate,
      sortThreadsByTimestampDesc,
      setThreads,
      setSelectedThreadId,
      setSelectedThreadShadow,
      pendingThreadSelectionRef,
      invalidateThreadUsageStats,
    ],
  );

  const handleThreadDeleteEvent = useCallback(
    (notification: ThreadDeleteNotification) => {
      const deletedThread = notification.data;
      if (!deletedThread) return;
      appendThreadSocketEvent(deletedThread.id, notification);
      setThreads((prev) =>
        prev.filter((thread) => thread.id !== deletedThread.id),
      );
      if (selectedThreadIdRef.current === deletedThread.id) {
        setSelectedThreadId(undefined);
        setSelectedThreadShadow(null);
      }
      if (
        pendingThreadSelectionRef.current &&
        pendingThreadSelectionRef.current === deletedThread.externalThreadId
      ) {
        pendingThreadSelectionRef.current = null;
      }
    },
    [
      appendThreadSocketEvent,
      setThreads,
      setSelectedThreadId,
      setSelectedThreadShadow,
      pendingThreadSelectionRef,
    ],
  );

  // Register all WS event handlers
  useWebSocketEvent('thread.create', (notification) =>
    handleThreadCreateEvent(notification as ThreadCreateNotification),
  );
  useWebSocketEvent('thread.update', (notification) =>
    handleThreadUpdateEvent(notification as ThreadUpdateNotification),
  );
  useWebSocketEvent('thread.delete', (notification) =>
    handleThreadDeleteEvent(notification as ThreadDeleteNotification),
  );

  useWebSocketEvent('graph.node.update', (notification) => {
    const data = notification as GraphNodeUpdateNotification;
    const eventThreadId =
      (typeof data.threadId === 'string' && data.threadId.length > 0
        ? data.threadId
        : undefined) ??
      (typeof data.data?.metadata?.threadId === 'string'
        ? data.data.metadata.threadId
        : undefined);
    const eventInternalThreadId =
      typeof data.internalThreadId === 'string' &&
      data.internalThreadId.length > 0
        ? data.internalThreadId
        : undefined;
    const metadataRunId =
      typeof data.data?.metadata?.runId === 'string'
        ? data.data.metadata.runId
        : undefined;
    const internalThreadId =
      eventInternalThreadId || resolveInternalThreadId(eventThreadId);

    const targetThreadId = internalThreadId ?? eventThreadId;
    if (!targetThreadId) return;
    appendThreadSocketEvent(targetThreadId, data);

    const externalThreadIdForTarget =
      externalThreadIdsRef.current[targetThreadId] ?? eventThreadId;

    if (eventThreadId) {
      setExternalThreadIds((prev) => {
        const existing = prev[targetThreadId];
        if (existing === eventThreadId) return prev;
        return { ...prev, [targetThreadId]: eventThreadId };
      });
    }

    const reasoningChunks = data.data?.additionalNodeMetadata?.reasoningChunks;
    if (!reasoningChunks) return;

    const applyUpdateToKeys = buildAgentMessageScopeKeysForGraph(
      data.graphId,
      data.nodeId,
    );

    const reasoningContainer = narrowReasoningContainer(reasoningChunks, [
      eventThreadId,
      externalThreadIdForTarget,
      data.runId ?? metadataRunId,
    ]);
    const reasoningEntries = extractReasoningEntries(reasoningContainer, {
      threadId: externalThreadIdForTarget ?? eventThreadId,
      runId: data.runId ?? metadataRunId,
    });

    if (reasoningEntries.length > 0) {
      applyUpdateToKeys.forEach((key) => {
        updateMessages(
          targetThreadId,
          (prev) =>
            upsertReasoningEntries(prev, reasoningEntries, {
              externalThreadId: externalThreadIdForTarget,
              runId: data.runId ?? metadataRunId,
              selectedThreadId: targetThreadId,
              nodeId: key,
            }),
          key,
        );
      });
    }
  });

  useWebSocketEvent('agent.message', (notification) => {
    const data = notification as AgentMessageNotification;
    if (!data.internalThreadId) return;

    const threadId = data.internalThreadId;
    appendThreadSocketEvent(threadId, data);
    const nodeId = data.nodeId;
    const incomingMessage = data.data;

    const applyMessageKeys = buildAgentMessageScopeKeysForGraph(
      data.graphId,
      nodeId,
    );
    applyMessageKeys.forEach((key) => {
      updateMessages(
        threadId,
        (prev) => {
          const normalized = normalizeIncomingCreatedAtForDisplay(
            prev,
            incomingMessage,
          );
          return mergeMessagesReplacingStreaming(prev, [normalized]);
        },
        key,
      );
    });

    const incomingContent =
      typeof incomingMessage.message?.content === 'string'
        ? (incomingMessage.message?.content as string)
        : undefined;
    const incomingRole = incomingMessage.message?.role as string | undefined;
    if (incomingContent && incomingRole === 'human') {
      const applyPendingToKeys = applyMessageKeys;
      applyPendingToKeys.forEach((key) => {
        updatePendingMessages(
          threadId,
          (prev) =>
            prev.filter(
              (p) =>
                typeof p.content !== 'string' || p.content !== incomingContent,
            ),
          key,
        );
      });
    }

    if (incomingMessage.externalThreadId) {
      setExternalThreadIds((prev) => ({
        ...prev,
        [threadId]: incomingMessage.externalThreadId,
      }));
    }

    // Accumulate per-request token usage into real-time node totals.
    //
    // For nodes that receive agent.state.update events (cumulative totals),
    // we skip additive requestTokenUsage to avoid double-counting — the state
    // update is the authoritative source.  However we still additively
    // accumulate toolTokenUsage, which captures subagent/tool costs that
    // the node-level state update may not yet include.
    //
    // Exception: subagent / inter-agent communication messages carry their
    // own requestTokenUsage representing the *subagent's* LLM cost, which
    // is NOT included in the parent node's agent.state.update totals until
    // the subagent completes.  Always accumulate these additively so the
    // thread header updates in real-time during subagent execution.
    //
    // For nodes without state updates, we accumulate requestTokenUsage
    // additively so the UI shows live progress.
    const reqUsage = incomingMessage.requestTokenUsage;
    const toolUsage = incomingMessage.toolTokenUsage;
    const threadNodeSet = nodesWithStateUpdateRef.current.get(threadId);
    const nodeHasStateUpdates = threadNodeSet?.has(nodeId) ?? false;

    // Detect subagent/communication inner messages via additional_kwargs flags.
    const msgRecord = incomingMessage.message as unknown as
      | Record<string, unknown>
      | undefined;
    const msgKwargs =
      msgRecord?.additionalKwargs ?? msgRecord?.additional_kwargs;
    const isSubagentOrCommMessage =
      typeof msgKwargs === 'object' &&
      msgKwargs !== null &&
      (Boolean(
        (msgKwargs as Record<string, unknown>).__subagentCommunication,
      ) ||
        Boolean(
          (msgKwargs as Record<string, unknown>).__interAgentCommunication,
        ));

    const usageToAccumulate =
      isSubagentOrCommMessage && reqUsage
        ? reqUsage
        : !nodeHasStateUpdates && reqUsage
          ? reqUsage
          : toolUsage;

    if (usageToAccumulate && nodeId) {
      setThreadTokenUsageByNode((prev) => {
        const existingThread = prev[threadId] ?? {};
        const existingNode = existingThread[nodeId] ?? {};

        return {
          ...prev,
          [threadId]: {
            ...existingThread,
            [nodeId]: {
              inputTokens: addUsageField(
                existingNode.inputTokens,
                usageToAccumulate.inputTokens,
              ),
              cachedInputTokens: addUsageField(
                existingNode.cachedInputTokens,
                usageToAccumulate.cachedInputTokens,
              ),
              outputTokens: addUsageField(
                existingNode.outputTokens,
                usageToAccumulate.outputTokens,
              ),
              reasoningTokens: addUsageField(
                existingNode.reasoningTokens,
                usageToAccumulate.reasoningTokens,
              ),
              totalTokens: addUsageField(
                existingNode.totalTokens,
                usageToAccumulate.totalTokens,
              ),
              totalPrice: addUsageField(
                existingNode.totalPrice,
                usageToAccumulate.totalPrice,
              ),
              // currentContext is a snapshot, not additive — always replace
              currentContext:
                typeof usageToAccumulate.currentContext === 'number' &&
                Number.isFinite(usageToAccumulate.currentContext)
                  ? usageToAccumulate.currentContext
                  : existingNode.currentContext,
            },
          },
        };
      });
    }
  });

  useWebSocketEvent('agent.state.update', (notification) => {
    const data = notification as AgentStateUpdateNotification;
    const internalThreadId =
      (typeof data.internalThreadId === 'string' && data.internalThreadId) ||
      resolveInternalThreadId(data.threadId);
    if (!internalThreadId) return;
    appendThreadSocketEvent(internalThreadId, data);
    if (!data.nodeId) return;

    // Mark this node as receiving cumulative state updates so we skip
    // additive requestTokenUsage from agent.message for the same node.
    let threadNodeSet = nodesWithStateUpdateRef.current.get(internalThreadId);
    if (!threadNodeSet) {
      threadNodeSet = new Set();
      nodesWithStateUpdateRef.current.set(internalThreadId, threadNodeSet);
    }
    threadNodeSet.add(data.nodeId);

    const usageUpdate = compactUsageUpdate(data.data ?? {});
    if (Object.keys(usageUpdate).length === 0) return;

    setThreadTokenUsageByNode((prev) => {
      const existingThread = prev[internalThreadId] ?? {};
      const existingNode = existingThread[data.nodeId] ?? {};
      return {
        ...prev,
        [internalThreadId]: {
          ...existingThread,
          [data.nodeId]: {
            ...existingNode,
            ...usageUpdate,
          },
        },
      };
    });
  });

  return {
    applyThreadCreate,
    isAgentNodeIdInGraph,
    resolveInternalThreadId,
    threadSocketEvents,
  };
};
