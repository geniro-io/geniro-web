import { useCallback, useEffect, useRef, useState } from 'react';

import { runtimesApi } from '../../../api';
import type { RuntimeInstanceDto } from '../../../autogenerated';
import { useWebSocketEvent } from '../../../hooks/useWebSocket';
import type { RuntimeStatusNotification } from '../../../services/WebSocketTypes';

interface UseThreadRuntimesReturn {
  runtimes: RuntimeInstanceDto[];
  loading: boolean;
  error: string | null;
  refresh: () => void;
}

export const useThreadRuntimes = (
  threadId: string | undefined,
  graphId: string | undefined,
): UseThreadRuntimesReturn => {
  const [runtimes, setRuntimes] = useState<RuntimeInstanceDto[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const threadIdRef = useRef(threadId);
  useEffect(() => {
    threadIdRef.current = threadId;
  }, [threadId]);

  const graphIdRef = useRef(graphId);
  useEffect(() => {
    graphIdRef.current = graphId;
  }, [graphId]);

  const fetchRuntimes = useCallback(async (tid: string) => {
    setLoading(true);
    setError(null);
    try {
      const response = await runtimesApi.getRuntimes(tid);
      if (threadIdRef.current === tid) {
        setRuntimes(response.data);
      }
    } catch (err) {
      if (threadIdRef.current === tid) {
        const message =
          err instanceof Error ? err.message : 'Failed to load runtimes';
        setError(message);
      }
    } finally {
      if (threadIdRef.current === tid) {
        setLoading(false);
      }
    }
  }, []);

  useEffect(() => {
    if (!threadId) {
      setRuntimes([]);
      setLoading(false);
      setError(null);
      return;
    }
    void fetchRuntimes(threadId);
  }, [threadId, fetchRuntimes]);

  const refresh = useCallback(() => {
    const tid = threadIdRef.current;
    if (tid) {
      void fetchRuntimes(tid);
    }
  }, [fetchRuntimes]);

  const runtimesRef = useRef(runtimes);
  useEffect(() => {
    runtimesRef.current = runtimes;
  }, [runtimes]);

  useWebSocketEvent('runtime.status', (notification) => {
    const data = notification as RuntimeStatusNotification;
    const currentThreadId = threadIdRef.current;
    if (!currentThreadId) return;

    // Events arrive scoped to the graph room. Match by graphId to ensure
    // we only process events for the current graph.
    if (data.graphId !== graphIdRef.current) return;

    const { runtimeId, status } = data.data;
    if (!runtimeId) return;

    const isKnownRuntime = runtimesRef.current.some((r) => r.id === runtimeId);

    if (isKnownRuntime) {
      setRuntimes((prev) =>
        prev.map((r) =>
          r.id === runtimeId
            ? { ...r, status, updatedAt: new Date().toISOString() }
            : r,
        ),
      );
    } else {
      // Unknown runtime â€” refetch to get full data
      void fetchRuntimes(currentThreadId);
    }
  });

  return { runtimes, loading, error, refresh };
};
