import {
  BarChartOutlined,
  CloseOutlined,
  CloudServerOutlined,
  LinkOutlined,
  PlusOutlined,
  ReloadOutlined,
} from '@ant-design/icons';
import {
  App,
  Button,
  Empty,
  Popover,
  Space,
  Spin,
  Tabs,
  Tag,
  Tooltip,
  Typography,
} from 'antd';
import { useEffect, useMemo, useRef, useState } from 'react';
import { Link } from 'react-router';

import type { ThreadDto } from '../../autogenerated';
import { getAgentAvatarDataUri } from '../../utils/agentAvatars';
import { getThreadStatusDisplay } from '../../utils/threadStatus';
import { AnalyzeThreadModal } from './components/AnalyzeThreadModal';
import { GraphPickerContent } from './components/GraphPickerPopover';
import { SocketEventsModal } from './components/SocketEventsModal';
import ThreadChatPanel from './components/ThreadChatPanel';
import { ThreadListItem } from './components/ThreadListItem';
import { ThreadRuntimeSidebar } from './components/ThreadRuntimeSidebar';
import { ThreadTokenUsageLine } from './components/ThreadTokenUsageLine';
import { UsageStatsModal } from './components/UsageStatsModal';
import { useChatsAnalysis } from './hooks/useChatsAnalysis';
import { useChatsMessages } from './hooks/useChatsMessages';
import { useChatsThreadList } from './hooks/useChatsThreadList';
import { useChatsUsageStats } from './hooks/useChatsUsageStats';
import { useChatsWebSocket } from './hooks/useChatsWebSocket';
import { useThreadRuntimes } from './hooks/useThreadRuntimes';
import { isDraftThreadId } from './utils/chatsPageUtils';

const { Title, Text } = Typography;

export const ChatsPage = () => {
  const { message: antdMessage } = App.useApp();

  // --- Messages hook ---
  const {
    messages,
    updateMessages,
    pendingMessages,
    updatePendingMessages,
    externalThreadIds,
    setExternalThreadIds,
    messageMeta,
    setMessageMeta,
    getMessageMeta,
    updateMessageMeta,
    loadMessagesForThread,
    loadMoreMessagesForThread,
  } = useChatsMessages({ antdMessage });

  // --- Thread list hook ---
  const threadList = useChatsThreadList({ antdMessage });
  const {
    threads,
    setThreads,
    threadsLoading,
    threadsLoadingMore,
    threadStatusTab,
    selectedThreadId,
    setSelectedThreadId,
    setSelectedThreadShadow,
    selectedAgentNodeId,
    setSelectedAgentNodeId,
    draftThread,
    setDraftThread,
    graphCache,
    templatesById,
    templatesLoading,
    triggerNodesForSelectedThread,
    graphPickerOpen,
    setGraphPickerOpen,
    graphPickerLoading,
    graphPickerError,
    graphPickerGraphs,
    threadsContainerRef,
    pendingThreadSelectionRef,
    threadsRef,
    graphFilterId,
    graphIsRunning,
    selectedThreadIsDraft,
    selectedThread,
    filteredThreads,
    shouldShowDraftThread,
    filteredGraphLabel,
    getThreadTimestamp,
    sortThreadsByTimestampDesc,
    ensureGraphsLoaded,
    handleRefreshThreads,
    handleThreadsScroll,
    handleThreadStatusTabChange,
    handleClearGraphFilter,
    handleDeleteThread,
    handleCreateDraftThread,
    handleGraphPickerSelect,
    handleThreadChatSwitchRequest,
  } = threadList;

  // --- Usage stats hook ---
  const {
    setThreadTokenUsageByNode,
    selectedThreadUsageByNode,
    selectedThreadThreadUsage,
    selectedThreadContextPercent,
    selectedThreadContextMaxTokens,
    selectedThreadHeaderUsage,
    selectedThreadHeaderContextPercent,
    selectedThreadHeaderContextMaxTokens,
    getNodeConfigString,
    getNodeConfigNumber,
    getNodeTemplateId,
    formatNodeLabel,
    handleOpenUsageStatsModal,
    handleCloseUsageStatsModal,
    invalidateThreadUsageStats,
    usageStatsModalOpen,
    usageStatsModalThreadId,
    threadUsageStats,
    threadUsageStatsLoading,
  } = useChatsUsageStats({
    antdMessage,
    selectedThread,
    selectedThreadId,
    selectedThreadIsDraft,
    selectedAgentNodeId,
    graphCache,
  });

  // --- WebSocket hook ---
  const { applyThreadCreate, isAgentNodeIdInGraph, threadSocketEvents } =
    useChatsWebSocket({
      graphFilterId,
      selectedThreadId,
      draftThread,
      threadsRef,
      pendingThreadSelectionRef,
      setThreads,
      setSelectedThreadId,
      setSelectedThreadShadow,
      setDraftThread,
      setExternalThreadIds,
      setMessageMeta,
      setThreadTokenUsageByNode,
      messages,
      pendingMessages,
      updateMessages,
      updatePendingMessages,
      externalThreadIds,
      sortThreadsByTimestampDesc,
      getThreadTimestamp,
      ensureGraphsLoaded,
      graphCache,
      templatesById,
      invalidateThreadUsageStats,
    });

  const socketEventsForUsageStatsThread = useMemo(() => {
    if (!usageStatsModalThreadId) return [];
    return threadSocketEvents[usageStatsModalThreadId] ?? [];
  }, [threadSocketEvents, usageStatsModalThreadId]);

  // --- Analysis hook ---
  const analysis = useChatsAnalysis({
    antdMessage,
    selectedThread,
    selectedThreadId,
    selectedThreadIsDraft,
    graphIsRunning,
    threadSocketEvents,
  });

  const {
    analyzeModalOpen,
    analyzeLoading,
    analysisResult,
    analysisUserInput,
    setAnalysisUserInput,
    analysisModel,
    setAnalysisModel,
    liteLlmModels,
    litellmModelsLoading,
    analysisButtonDisabled,
    handleOpenAnalyzeModal,
    handleCloseAnalyzeModal,
    handleAnalyzeThread,
    threadSocketEventsModalOpen,
    socketEventsForModalThread,
    handleOpenThreadSocketEventsModal,
    handleCloseThreadSocketEventsModal,
    handleCopyThreadSocketEventsJson,
    threadSocketEventsModalThreadId,
  } = analysis;

  // --- Runtime sidebar ---
  const [runtimeSidebarOpen, setRuntimeSidebarOpen] = useState(false);

  const runtimeNodeNames = useMemo(() => {
    if (!selectedThread || selectedThreadIsDraft) return undefined;
    const graph = graphCache[selectedThread.graphId]?.graph;
    if (!graph) return undefined;
    const metadataNames =
      graphCache[selectedThread.graphId]?.nodeDisplayNames ?? {};
    const names: Record<string, string> = {};
    for (const node of graph.schema?.nodes ?? []) {
      const configName = getNodeConfigString(node.id, 'name');
      names[node.id] =
        configName ?? metadataNames[node.id] ?? formatNodeLabel(node.id);
    }
    return names;
  }, [
    graphCache,
    selectedThread,
    selectedThreadIsDraft,
    getNodeConfigString,
    formatNodeLabel,
  ]);

  const {
    runtimes,
    loading: runtimesLoading,
    error: runtimesError,
    refresh: refreshRuntimes,
  } = useThreadRuntimes(
    selectedThreadId && !selectedThreadIsDraft ? selectedThreadId : undefined,
    selectedThread && !selectedThreadIsDraft
      ? selectedThread.graphId
      : undefined,
  );

  // --- Auto-load messages for selected thread ---

  const messagesRef = useRef(messages);
  useEffect(() => {
    messagesRef.current = messages;
  }, [messages]);

  useEffect(() => {
    if (
      !selectedThread ||
      ('isDraft' in selectedThread && selectedThread.isDraft)
    )
      return;

    const meta = getMessageMeta(selectedThread.id);
    const existingMessages =
      messagesRef.current[selectedThread.id]?.['all'] ?? [];

    if (existingMessages.length > 0) {
      if (meta.offset === 0) {
        updateMessageMeta(selectedThread.id, (prev) => ({
          ...prev,
          loading: false,
          loadingMore: false,
          offset: existingMessages.length,
        }));
      }
      return;
    }

    if (meta.initialLoadFailed) {
      return;
    }

    if (meta.offset === 0 && !meta.loading) {
      void loadMessagesForThread(selectedThread.id);
    }
  }, [
    selectedThread,
    getMessageMeta,
    loadMessagesForThread,
    updateMessageMeta,
  ]);

  // --- Derived thread data ---

  const threadStatusMeta = selectedThread
    ? 'isDraft' in selectedThread && selectedThread.isDraft
      ? null
      : getThreadStatusDisplay((selectedThread as ThreadDto).status)
    : null;

  const selectedThreadAllMessages = useMemo(() => {
    if (!selectedThreadId) return [];
    return messages[selectedThreadId]?.['all'] || [];
  }, [messages, selectedThreadId]);

  const agentsForSelectedThread = useMemo(() => {
    if (!selectedThreadId || !selectedThread || selectedThreadIsDraft) {
      return [];
    }

    const agents: {
      nodeId: string;
      label: string;
      description?: string;
      avatarSrc?: string;
    }[] = [];

    const graphId = selectedThread.graphId;
    const graph = graphCache[graphId]?.graph;
    const schemaNodes = graph?.schema?.nodes ?? [];

    schemaNodes.forEach((node) => {
      const nodeId = node.id;
      if (!isAgentNodeIdInGraph(graphId, nodeId)) return;

      const configName = getNodeConfigString(nodeId, 'name');
      const configDescription = getNodeConfigString(nodeId, 'description');

      agents.push({
        nodeId,
        label: configName ?? formatNodeLabel(nodeId),
        description: configDescription,
        avatarSrc: getAgentAvatarDataUri(nodeId),
      });
    });

    return agents;
  }, [
    formatNodeLabel,
    graphCache,
    getNodeConfigString,
    isAgentNodeIdInGraph,
    selectedThread,
    selectedThreadId,
    selectedThreadIsDraft,
  ]);

  const runtimeAgentNames = useMemo(() => {
    if (!selectedThread || selectedThreadIsDraft) return {};
    const graph = graphCache[selectedThread.graphId]?.graph;
    if (!graph) return {};

    const edges = graph.schema?.edges ?? [];
    const agentNodeIds = new Set(agentsForSelectedThread.map((a) => a.nodeId));

    // Build child â†’ parents adjacency
    const parentMap: Record<string, string[]> = {};
    for (const edge of edges) {
      if (!parentMap[edge.to]) parentMap[edge.to] = [];
      parentMap[edge.to]!.push(edge.from);
    }

    // BFS from a node upward to find agent ancestors
    const findAgentAncestors = (nodeId: string): string[] => {
      const visited = new Set<string>();
      const queue = [nodeId];
      const agents: string[] = [];
      while (queue.length > 0) {
        const current = queue.shift()!;
        if (visited.has(current)) continue;
        visited.add(current);
        if (agentNodeIds.has(current)) {
          agents.push(current);
          continue;
        }
        for (const parent of parentMap[current] ?? []) {
          queue.push(parent);
        }
      }
      return agents;
    };

    const result: Record<string, string> = {};
    for (const node of graph.schema?.nodes ?? []) {
      const agentAncestors = findAgentAncestors(node.id);
      if (agentAncestors.length > 0) {
        const labels = agentAncestors.map((agentId) => {
          const agent = agentsForSelectedThread.find(
            (a) => a.nodeId === agentId,
          );
          return agent?.label ?? agentId;
        });
        result[node.id] = labels.join(', ');
      }
    }
    return result;
  }, [
    graphCache,
    selectedThread,
    selectedThreadIsDraft,
    agentsForSelectedThread,
  ]);

  const visibleMessagesForSelectedThread = useMemo(() => {
    if (!selectedThreadId) return [];
    if (!selectedAgentNodeId) return selectedThreadAllMessages;
    return selectedThreadAllMessages.filter(
      (msg) => msg.nodeId === selectedAgentNodeId,
    );
  }, [selectedAgentNodeId, selectedThreadAllMessages, selectedThreadId]);

  const visiblePendingMessagesForSelectedThread = useMemo(() => {
    if (!selectedThreadId) return [];
    if (selectedAgentNodeId) return [];
    return pendingMessages[selectedThreadId]?.['all'] || [];
  }, [pendingMessages, selectedAgentNodeId, selectedThreadId]);

  // --- Empty state ---

  const threadsEmpty =
    !threadsLoading &&
    !threadsLoadingMore &&
    filteredThreads.length === 0 &&
    !shouldShowDraftThread;

  const threadsEmptyDescription = useMemo(() => {
    const scopeSuffix = graphFilterId ? ' for this graph' : '';
    if (threadStatusTab === 'resolved')
      return `No resolved threads${scopeSuffix}`;
    if (threadStatusTab === 'open') return `No open threads${scopeSuffix}`;
    return graphFilterId ? 'No threads found for this graph' : 'No threads yet';
  }, [graphFilterId, threadStatusTab]);

  // --- Render ---

  return (
    <div
      style={{
        height: 'calc(100vh - 64px)',
        maxHeight: 'calc(100vh - 64px)',
        display: 'flex',
        flexDirection: 'column',
        overflow: 'hidden',
      }}>
      <div
        style={{
          display: 'flex',
          flex: 1,
          minHeight: 0,
          overflow: 'hidden',
        }}>
        {/* Left sidebar: thread list */}
        <div
          style={{
            width: 340,
            borderRight: '1px solid #f0f0f0',
            display: 'flex',
            flexDirection: 'column',
            background: '#fff',
            overflow: 'hidden',
          }}>
          <div
            style={{
              padding: '16px',
              borderBottom: '1px solid #f0f0f0',
              flexShrink: 0,
            }}>
            <div
              style={{
                width: '100%',
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'flex-start',
                gap: 12,
                minWidth: 0,
              }}>
              <div
                style={{
                  display: 'flex',
                  flexDirection: 'column',
                  gap: 4,
                  minWidth: 0,
                  flex: 1,
                }}>
                <Title level={4} style={{ margin: 0 }}>
                  Chats
                </Title>
              </div>
              <Space>
                {graphFilterId ? (
                  <Button
                    size="small"
                    icon={<PlusOutlined />}
                    onClick={handleCreateDraftThread}
                    style={{ border: 'none', boxShadow: 'none' }}
                  />
                ) : (
                  <Popover
                    open={graphPickerOpen}
                    placement="bottomRight"
                    onOpenChange={setGraphPickerOpen}
                    content={
                      <GraphPickerContent
                        graphs={graphPickerGraphs}
                        loading={graphPickerLoading}
                        error={graphPickerError}
                        onSelect={handleGraphPickerSelect}
                      />
                    }>
                    <Button
                      size="small"
                      icon={<PlusOutlined />}
                      onClick={handleCreateDraftThread}
                      style={{ border: 'none', boxShadow: 'none' }}
                    />
                  </Popover>
                )}
                <Button
                  size="small"
                  icon={<ReloadOutlined />}
                  onClick={handleRefreshThreads}
                  loading={threadsLoading}
                  style={{ border: 'none', boxShadow: 'none' }}
                />
              </Space>
            </div>
            <Tabs
              size="small"
              activeKey={threadStatusTab}
              onChange={handleThreadStatusTabChange}
              items={[
                { key: 'all', label: 'All' },
                { key: 'open', label: 'Open' },
                { key: 'resolved', label: 'Resolved' },
              ]}
              style={{ marginTop: 10 }}
            />
          </div>
          {graphFilterId && (
            <div
              style={{
                padding: '10px 16px',
                borderBottom: '1px solid #f0f0f0',
                background: '#fafafa',
                flexShrink: 0,
              }}>
              <div
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'space-between',
                  gap: 12,
                  minWidth: 0,
                }}>
                <div style={{ minWidth: 0, flex: 1 }}>
                  <Text
                    type="secondary"
                    style={{
                      fontSize: 11,
                      display: 'block',
                      marginBottom: 2,
                    }}>
                    Current graph
                  </Text>
                  <Text
                    strong
                    ellipsis={{ tooltip: filteredGraphLabel }}
                    style={{ display: 'block' }}>
                    {filteredGraphLabel}
                  </Text>
                </div>
                <Button
                  type="text"
                  size="small"
                  icon={<CloseOutlined />}
                  onClick={handleClearGraphFilter}
                  aria-label="Clear graph filter"
                />
              </div>
            </div>
          )}
          <div
            ref={threadsContainerRef}
            onScroll={handleThreadsScroll}
            style={{
              flex: 1,
              minHeight: 0,
              overflowY: 'auto',
            }}>
            {shouldShowDraftThread && draftThread ? (
              <ThreadListItem
                thread={draftThread}
                isActive={draftThread.id === selectedThreadId}
                graphCache={graphCache}
                selectedAgentNodeId={selectedAgentNodeId}
                onSelect={setSelectedThreadId}
                onSelectAgent={setSelectedAgentNodeId}
                onDeleteThread={handleDeleteThread}
                agents={[]}
                usageByNode={{}}
                getNodeTemplateId={getNodeTemplateId}
                getNodeConfigNumber={getNodeConfigNumber}
              />
            ) : null}
            {filteredThreads.map((thread) => (
              <ThreadListItem
                key={thread.id}
                thread={thread}
                isActive={thread.id === selectedThreadId}
                graphCache={graphCache}
                selectedAgentNodeId={selectedAgentNodeId}
                onSelect={setSelectedThreadId}
                onSelectAgent={setSelectedAgentNodeId}
                onDeleteThread={handleDeleteThread}
                agents={
                  thread.id === selectedThreadId ? agentsForSelectedThread : []
                }
                threadUsage={
                  thread.id === selectedThreadId
                    ? selectedThreadThreadUsage
                    : undefined
                }
                usageByNode={
                  thread.id === selectedThreadId
                    ? selectedThreadUsageByNode
                    : {}
                }
                contextPercent={
                  thread.id === selectedThreadId
                    ? selectedThreadContextPercent
                    : undefined
                }
                contextMaxTokens={
                  thread.id === selectedThreadId
                    ? selectedThreadContextMaxTokens
                    : undefined
                }
                getNodeTemplateId={getNodeTemplateId}
                getNodeConfigNumber={getNodeConfigNumber}
              />
            ))}
            {threadsLoading && (
              <div style={{ padding: 24, textAlign: 'center' }}>
                <Spin />
              </div>
            )}
            {threadsEmpty && (
              <div style={{ padding: 24 }}>
                <Empty description={threadsEmptyDescription} />
              </div>
            )}
            {threadsLoadingMore && (
              <div style={{ padding: 12, textAlign: 'center' }}>
                <Spin size="small" />
              </div>
            )}
          </div>
        </div>

        {/* Right panel: chat + runtime sidebar */}
        <div
          style={{
            flex: 1,
            minHeight: 0,
            display: 'flex',
            overflow: 'hidden',
          }}>
          <div
            style={{
              flex: 1,
              minHeight: 0,
              display: 'flex',
              flexDirection: 'column',
              overflow: 'hidden',
            }}>
            <div
              style={{
                padding: 24,
                display: 'flex',
                flexDirection: 'column',
                flex: 1,
                minHeight: 0,
                background: '#fff',
                overflow: 'hidden',
              }}>
              {selectedThread ? (
                <>
                  <div
                    style={{
                      marginBottom: 16,
                      display: 'flex',
                      justifyContent: 'space-between',
                      alignItems: 'center',
                      flexWrap: 'wrap',
                      gap: 12,
                    }}>
                    <div>
                      <Title level={4} style={{ margin: 0 }}>
                        {selectedThread.name || 'New Thread'}
                      </Title>
                      <Space size="small" wrap>
                        <Text type="secondary">
                          Graph:{' '}
                          {graphCache[selectedThread.graphId]?.graph.name ||
                            'Loading\u2026'}
                        </Text>
                        <Link
                          to={`/graphs/${selectedThread.graphId}`}
                          style={{
                            display: 'inline-flex',
                            alignItems: 'center',
                            color: '#1677ff',
                            textDecoration: 'none',
                            position: 'relative',
                            top: '2px',
                            padding: '0 3px',
                          }}
                          aria-label="Open graph details"
                          title="Open graph details">
                          <LinkOutlined />
                        </Link>
                        <Space size={8} align="center">
                          {threadStatusMeta && (
                            <Tag color={threadStatusMeta.color}>
                              {threadStatusMeta.label}
                            </Tag>
                          )}
                          <Button
                            type="link"
                            size="small"
                            style={{
                              padding: 0,
                              height: 'auto',
                              fontSize: 12,
                            }}
                            onClick={handleOpenAnalyzeModal}
                            disabled={analysisButtonDisabled}
                            title={
                              selectedThreadIsDraft
                                ? 'Create the thread before analyzing it'
                                : undefined
                            }>
                            Analyze thread
                          </Button>
                        </Space>
                      </Space>
                    </div>
                    <div
                      style={{
                        marginLeft: 'auto',
                        textAlign: 'right',
                        display: 'flex',
                        alignItems: 'center',
                        gap: 8,
                      }}>
                      <ThreadTokenUsageLine
                        usage={selectedThreadHeaderUsage}
                        withPopover
                        contextPercent={selectedThreadHeaderContextPercent}
                        contextMaxTokens={selectedThreadHeaderContextMaxTokens}
                      />
                      {selectedThreadHeaderUsage && (
                        <Tooltip title="View detailed usage statistics">
                          <Button
                            type="text"
                            size="small"
                            icon={<BarChartOutlined />}
                            onClick={handleOpenUsageStatsModal}
                            style={{ padding: '4px 8px' }}
                          />
                        </Tooltip>
                      )}
                      {!selectedThreadIsDraft && (
                        <Tooltip
                          title={
                            runtimeSidebarOpen
                              ? 'Hide runtimes'
                              : 'Show runtimes'
                          }>
                          <Button
                            type="text"
                            size="small"
                            icon={<CloudServerOutlined />}
                            onClick={() => setRuntimeSidebarOpen((v) => !v)}
                            style={{ padding: '4px 8px' }}
                          />
                        </Tooltip>
                      )}
                    </div>
                  </div>

                  <div
                    style={{
                      flex: 1,
                      minHeight: 0,
                      display: 'flex',
                      flexDirection: 'column',
                    }}>
                    <ThreadChatPanel
                      graphId={selectedThread.graphId}
                      thread={selectedThread as ThreadDto}
                      triggerNodes={triggerNodesForSelectedThread}
                      templatesLoading={templatesLoading}
                      nodeDisplayNames={
                        graphCache[selectedThread.graphId]?.nodeDisplayNames
                      }
                      graphLoaded={Boolean(graphCache[selectedThread.graphId])}
                      graphIsRunning={graphIsRunning}
                      onRequestThreadSwitch={handleThreadChatSwitchRequest}
                      isDraft={draftThread?.id === selectedThreadId}
                      onDraftMessageSent={applyThreadCreate}
                      messages={
                        selectedThreadId ? visibleMessagesForSelectedThread : []
                      }
                      messagesLoading={
                        selectedThreadId
                          ? (messageMeta[selectedThreadId]?.loading ?? false)
                          : false
                      }
                      hasMoreMessages={
                        selectedThreadId
                          ? isDraftThreadId(selectedThreadId)
                            ? false
                            : (messageMeta[selectedThreadId]?.hasMore ?? true)
                          : false
                      }
                      loadingMoreMessages={
                        selectedThreadId
                          ? (messageMeta[selectedThreadId]?.loadingMore ??
                            false)
                          : false
                      }
                      pendingMessages={
                        selectedThreadId
                          ? visiblePendingMessagesForSelectedThread
                          : []
                      }
                      externalThreadId={
                        selectedThreadId
                          ? externalThreadIds[selectedThreadId]
                          : undefined
                      }
                      onLoadMoreMessages={
                        selectedThreadId
                          ? isDraftThreadId(selectedThreadId)
                            ? undefined
                            : () => loadMoreMessagesForThread(selectedThreadId)
                          : undefined
                      }
                      onUpdateSharedMessages={updateMessages}
                      onUpdatePendingMessages={updatePendingMessages}
                    />
                  </div>
                </>
              ) : (
                <div
                  style={{
                    flex: 1,
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                  }}>
                  <Empty
                    description="Select a thread to view its messages"
                    image={Empty.PRESENTED_IMAGE_SIMPLE}
                  />
                </div>
              )}
            </div>
          </div>

          <ThreadRuntimeSidebar
            open={
              runtimeSidebarOpen && !!selectedThread && !selectedThreadIsDraft
            }
            onClose={() => setRuntimeSidebarOpen(false)}
            runtimes={runtimes}
            loading={runtimesLoading}
            error={runtimesError}
            onRefresh={refreshRuntimes}
            nodeDisplayNames={runtimeNodeNames}
            nodeAgentNames={runtimeAgentNames}
          />
        </div>
      </div>

      <AnalyzeThreadModal
        open={analyzeModalOpen}
        onCancel={handleCloseAnalyzeModal}
        onAnalyze={handleAnalyzeThread}
        loading={analyzeLoading}
        disabled={analysisButtonDisabled}
        result={analysisResult}
        userInput={analysisUserInput}
        onUserInputChange={setAnalysisUserInput}
        model={analysisModel}
        onModelChange={setAnalysisModel}
        models={liteLlmModels}
        modelsLoading={litellmModelsLoading}
      />

      <UsageStatsModal
        open={usageStatsModalOpen}
        onClose={handleCloseUsageStatsModal}
        threadId={usageStatsModalThreadId}
        threads={threads}
        graphCache={graphCache}
        templatesById={templatesById}
        threadUsageStats={threadUsageStats}
        threadUsageStatsLoading={threadUsageStatsLoading}
        socketEventsCount={socketEventsForUsageStatsThread.length}
        onShowLocalEvents={handleOpenThreadSocketEventsModal}
      />

      <SocketEventsModal
        open={threadSocketEventsModalOpen}
        onClose={handleCloseThreadSocketEventsModal}
        threadId={threadSocketEventsModalThreadId}
        events={socketEventsForModalThread}
        onCopyJson={handleCopyThreadSocketEventsJson}
      />
    </div>
  );
};

export default ChatsPage;
