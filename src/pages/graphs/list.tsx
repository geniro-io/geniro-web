import {
  CommentOutlined,
  DeleteOutlined,
  EditOutlined,
  EllipsisOutlined,
  PlusOutlined,
  UploadOutlined,
} from '@ant-design/icons';
import type { Viewport } from '@xyflow/react';
import {
  App,
  Button,
  Card,
  Dropdown,
  Empty,
  Form,
  Input,
  Modal,
  Spin,
  Tag,
  Typography,
} from 'antd';
import { formatDistanceToNow } from 'date-fns';
import type { ChangeEvent } from 'react';
import { useEffect, useRef, useState } from 'react';
import { useNavigate, useParams } from 'react-router';

import { graphsApi } from '../../api';
import type { CreateGraphDto, GraphDto } from '../../autogenerated';
import { extractApiErrorMessage } from '../../utils/errors';
import type { GraphMetadata, NodeMetadata } from './types';

const { Title, Text, Paragraph } = Typography;
const { Search } = Input;

const STATUS_META: Record<
  NonNullable<GraphDto['status']> | 'draft',
  { label: string; color: string; bg: string }
> = {
  running: { label: 'Running', color: '#166534', bg: '#bbf7d0' },
  compiling: { label: 'Compiled', color: '#1d4ed8', bg: '#dbeafe' },
  created: { label: 'Created', color: '#1d4ed8', bg: '#dbeafe' },
  stopped: { label: 'Stopped', color: '#4b5563', bg: '#e5e7eb' },
  error: { label: 'Error', color: '#b91c1c', bg: '#fee2e2' },
  draft: { label: 'Draft', color: '#92400e', bg: '#fed7aa' },
};

export const GraphsListPage = () => {
  const { message } = App.useApp();
  const navigate = useNavigate();
  const { projectId } = useParams<{ projectId: string }>();
  const [loading, setLoading] = useState(true);
  const [deleting, setDeleting] = useState<string | null>(null);
  const [importing, setImporting] = useState(false);
  const [graphs, setGraphs] = useState<GraphDto[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [editingGraph, setEditingGraph] = useState<GraphDto | null>(null);
  const [editSaving, setEditSaving] = useState(false);
  const [deletingGraphId, setDeletingGraphId] = useState<string | null>(null);
  const [editForm] = Form.useForm<{ name: string; description: string }>();
  const fileInputRef = useRef<HTMLInputElement | null>(null);

  useEffect(() => {
    let mounted = true;
    (async () => {
      try {
        const res = await graphsApi.getAllGraphs();
        if (!mounted) return;
        setGraphs(res.data || []);
      } catch (e) {
        if (!mounted) return;
        console.error('Error fetching graphs:', e);
        const errorMessage = extractApiErrorMessage(e, 'Failed to load graphs');
        setError(errorMessage);
      } finally {
        if (mounted) setLoading(false);
      }
    })();
    return () => {
      mounted = false;
    };
  }, [projectId]);

  const handleCreateGraph = async () => {
    try {
      const res = await graphsApi.createGraph({
        name: `New Graph ${new Date().toLocaleString()}`,
        description: 'A new graph',
        schema: {
          nodes: [],
          edges: [],
        },
      });

      const graphId = res.data.id;
      message.success('Graph created successfully');
      navigate(
        projectId
          ? `/projects/${projectId}/graphs/${graphId}`
          : `/graphs/${graphId}`,
      );
    } catch (e: unknown) {
      console.error('Error creating graph:', e);
      const errorMessage = extractApiErrorMessage(e, 'Failed to create graph');
      message.error(errorMessage);
    }
  };

  const handleDeleteGraph = async (graphId: string) => {
    setDeleting(graphId);
    try {
      await graphsApi.deleteGraph(graphId);
      setGraphs((prev) => prev.filter((graph) => graph.id !== graphId));
      message.success('Graph deleted successfully');
    } catch (e: unknown) {
      console.error('Error deleting graph:', e);
      const errorMessage = extractApiErrorMessage(e, 'Failed to delete graph');
      message.error(errorMessage);
    } finally {
      setDeleting(null);
    }
  };

  const handleEditGraph = (graphId: string) => {
    navigate(
      projectId
        ? `/projects/${projectId}/graphs/${graphId}`
        : `/graphs/${graphId}`,
    );
  };

  const openEditModal = (graph: GraphDto) => {
    setEditingGraph(graph);
    editForm.setFieldsValue({
      name: graph.name || '',
      description: graph.description || '',
    });
  };

  const handleSaveGraphDetails = async () => {
    if (!editingGraph) return;
    try {
      const values = await editForm.validateFields();
      setEditSaving(true);
      const res = await graphsApi.updateGraph(editingGraph.id, {
        name: values.name,
        description: values.description,
        currentVersion: editingGraph.version || '',
      });
      const updated = res.data.graph;
      setGraphs((prev) =>
        prev.map((g) => (g.id === editingGraph.id ? { ...g, ...updated } : g)),
      );
      message.success('Graph updated');
      setEditingGraph(null);
    } catch (e: unknown) {
      console.error('Error updating graph:', e);
      const errorMessage = extractApiErrorMessage(e, 'Failed to update graph');
      message.error(errorMessage);
    } finally {
      setEditSaving(false);
    }
  };

  const parseImportedGraphFile = (
    raw: string,
  ): {
    createGraphDto: CreateGraphDto;
  } => {
    const isRecord = (value: unknown): value is Record<string, unknown> =>
      typeof value === 'object' && value !== null && !Array.isArray(value);

    const asString = (value: unknown, field: string): string => {
      if (typeof value !== 'string' || value.trim() === '') {
        throw new Error(`Invalid "${field}"`);
      }
      return value;
    };

    const asOptionalString = (value: unknown): string | undefined => {
      if (value === undefined || value === null) return undefined;
      if (typeof value !== 'string') return undefined;
      return value;
    };

    const asViewport = (value: unknown): Viewport | null => {
      if (!isRecord(value)) return null;
      const x = value.x;
      const y = value.y;
      const zoom = value.zoom;
      if (
        typeof x !== 'number' ||
        typeof y !== 'number' ||
        typeof zoom !== 'number'
      ) {
        return null;
      }
      return { x, y, zoom };
    };

    const parseNodeMetadataFromDraftNodes = (
      nodesValue: unknown,
    ): NodeMetadata[] | null => {
      if (!Array.isArray(nodesValue)) return null;

      const metas: NodeMetadata[] = [];
      for (const node of nodesValue) {
        if (!isRecord(node)) continue;
        const id = node.id;
        const position = node.position;
        if (typeof id !== 'string') continue;
        if (!isRecord(position)) continue;
        const x = position.x;
        const y = position.y;
        if (typeof x !== 'number' || typeof y !== 'number') continue;

        const data = node.data;
        const label =
          isRecord(data) && typeof data.label === 'string'
            ? data.label
            : undefined;

        metas.push({ id, x, y, name: label });
      }

      return metas;
    };

    const parseSchema = (value: unknown) => {
      if (!isRecord(value)) {
        throw new Error('Invalid "schema"');
      }

      const nodesValue = value.nodes;
      if (!Array.isArray(nodesValue)) {
        throw new Error('Invalid "schema.nodes"');
      }

      const nodes = nodesValue.map((n, idx) => {
        if (!isRecord(n)) {
          throw new Error(`Invalid "schema.nodes[${idx}]"`);
        }
        const id = asString(n.id, `schema.nodes[${idx}].id`);
        const template = asString(n.template, `schema.nodes[${idx}].template`);
        const config = n.config;
        if (!isRecord(config)) {
          throw new Error(`Invalid "schema.nodes[${idx}].config"`);
        }
        return { id, template, config };
      });

      const edgesValue = value.edges;
      const edges = Array.isArray(edgesValue)
        ? edgesValue.map((e, idx) => {
            if (!isRecord(e)) {
              throw new Error(`Invalid "schema.edges[${idx}]"`);
            }
            const from = asString(e.from, `schema.edges[${idx}].from`);
            const to = asString(e.to, `schema.edges[${idx}].to`);
            const label = asOptionalString(e.label);
            return { from, to, ...(label !== undefined ? { label } : {}) };
          })
        : [];

      return { nodes, edges };
    };

    let parsed: unknown;
    try {
      parsed = JSON.parse(raw) as unknown;
    } catch {
      throw new Error('File is not valid JSON');
    }

    if (!isRecord(parsed)) {
      throw new Error('Invalid JSON shape');
    }

    const wrapperGraph = parsed.graph;
    const graphCandidate = wrapperGraph !== undefined ? wrapperGraph : parsed;
    if (!isRecord(graphCandidate)) {
      throw new Error('Invalid "graph"');
    }

    const importedPrefix = 'Imported: ';
    const sourceName = asString(graphCandidate.name, 'name');
    const name = sourceName.startsWith(importedPrefix)
      ? sourceName
      : `${importedPrefix}${sourceName}`;
    const description = asOptionalString(graphCandidate.description);
    const schema = parseSchema(graphCandidate.schema);

    const metadataCandidate = graphCandidate.metadata;
    const existingMetadata =
      metadataCandidate && isRecord(metadataCandidate)
        ? (metadataCandidate as GraphMetadata)
        : undefined;

    const draftNodeMetadata = parseNodeMetadataFromDraftNodes(parsed.nodes);
    const draftViewport = asViewport(parsed.viewport);

    const mergedMetadata: GraphMetadata | undefined = (() => {
      const next: GraphMetadata = { ...(existingMetadata ?? {}) };
      let changed = false;

      if (draftNodeMetadata) {
        next.nodes = draftNodeMetadata;
        changed = true;
      }

      if (draftViewport) {
        next.x = draftViewport.x;
        next.y = draftViewport.y;
        next.zoom = draftViewport.zoom;
        changed = true;
      }

      if (changed) return next;
      return existingMetadata;
    })();

    return {
      createGraphDto: {
        name,
        description,
        schema: {
          nodes: schema.nodes,
          edges: schema.edges,
        },
        metadata: mergedMetadata,
      },
    };
  };

  const handleImportGraphClick = () => {
    fileInputRef.current?.click();
  };

  const handleImportGraphFile = async (
    event: ChangeEvent<HTMLInputElement>,
  ) => {
    const file = event.target.files?.[0];
    // Reset value so picking the same file twice still triggers onChange
    event.target.value = '';
    if (!file) return;

    setImporting(true);
    try {
      const raw = await file.text();
      const { createGraphDto } = parseImportedGraphFile(raw);
      const res = await graphsApi.createGraph(createGraphDto);
      const created = res.data;
      setGraphs((prev) => [created, ...prev]);
      message.success('Graph imported successfully');
      navigate(
        projectId
          ? `/projects/${projectId}/graphs/${created.id}`
          : `/graphs/${created.id}`,
      );
    } catch (e: unknown) {
      console.error('Error importing graph:', e);
      const errorMessage =
        e instanceof Error ? e.message : 'Failed to import graph';
      message.error(errorMessage);
    } finally {
      setImporting(false);
    }
  };

  const confirmDeleteGraph = (graphId: string) => {
    setDeletingGraphId(graphId);
  };

  const handleConfirmDelete = async () => {
    if (!deletingGraphId) return;
    await handleDeleteGraph(deletingGraphId);
    setDeletingGraphId(null);
  };

  const getNodeCount = (graph: GraphDto) => {
    return graph.schema?.nodes?.length || 0;
  };

  const getStatusMeta = (graph: GraphDto) => {
    if (graph.temporary) {
      return STATUS_META.draft;
    }
    const normalizedStatus =
      graph.status?.toLowerCase() as keyof typeof STATUS_META;

    if (normalizedStatus && STATUS_META[normalizedStatus]) {
      return STATUS_META[normalizedStatus];
    }
    return { label: 'Active', color: '#0f172a', bg: '#e5e7eb' };
  };

  const filteredGraphs = graphs.filter((graph) => {
    if (!searchTerm) return true;
    return graph.name?.toLowerCase().includes(searchTerm.toLowerCase());
  });

  const stats = graphs.reduce(
    (acc, graph) => {
      acc.total += 1;
      const normalized = graph.status?.toLowerCase();
      if (normalized === 'running') {
        acc.running += 1;
      } else if (normalized === 'stopped') {
        acc.stopped += 1;
      }
      if (graph.temporary) {
        acc.drafts += 1;
      }
      return acc;
    },
    { total: 0, running: 0, stopped: 0, drafts: 0 },
  );

  if (loading) {
    return (
      <div
        style={{
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          height: '50vh',
        }}>
        <Spin size="large" />
      </div>
    );
  }

  if (error) {
    return (
      <div style={{ padding: 24, textAlign: 'center' }}>
        <Text type="danger">{error}</Text>
      </div>
    );
  }

  return (
    <div
      style={{
        minHeight: '100%',
      }}>
      <div
        style={{
          background: 'white',
          padding: 24,
        }}>
        <div
          style={{
            display: 'flex',
            justifyContent: 'space-between',
            gap: 24,
            flexWrap: 'wrap',
          }}>
          <div>
            <Title level={2} style={{ marginBottom: 4 }}>
              Agent Graphs
            </Title>
            <Paragraph type="secondary" style={{ marginBottom: 0 }}>
              Manage and monitor your agent workflow graphs
            </Paragraph>
          </div>
          <div style={{ display: 'flex', gap: 12, flexWrap: 'wrap' }}>
            <input
              ref={fileInputRef}
              type="file"
              accept="application/json,.json"
              style={{ display: 'none' }}
              onChange={handleImportGraphFile}
            />
            <Button
              icon={<UploadOutlined />}
              size="middle"
              loading={importing}
              onClick={handleImportGraphClick}>
              Import Graph
            </Button>
            <Button
              type="primary"
              icon={<PlusOutlined />}
              size="middle"
              onClick={handleCreateGraph}>
              New Graph
            </Button>
          </div>
        </div>

        <div
          style={{
            marginTop: 20,
            display: 'flex',
            flexWrap: 'wrap',
            gap: 32,
            alignItems: 'center',
          }}>
          <Search
            placeholder="Search graphs..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            allowClear
            size="large"
            style={{ width: 340, maxWidth: '100%' }}
          />
          <div style={{ display: 'flex', gap: 20, flexWrap: 'wrap' }}>
            {[
              { label: 'Total', value: stats.total },
              { label: 'Running', value: stats.running, color: '#16a34a' },
              { label: 'Stopped', value: stats.stopped, color: '#0f172a' },
              { label: 'Drafts', value: stats.drafts, color: '#ea580c' },
            ].map((item) => (
              <div key={item.label}>
                <Text
                  style={{
                    fontSize: 12,
                    letterSpacing: 1,
                    color: '#94a3b8',
                  }}>
                  {item.label.toUpperCase()}{' '}
                  <span
                    style={{
                      color: item.color || '#0f172a',
                    }}>
                    {item.value}
                  </span>
                </Text>
              </div>
            ))}
          </div>
        </div>
      </div>

      {graphs.length === 0 ? (
        <Empty
          description="No graphs found"
          image={Empty.PRESENTED_IMAGE_SIMPLE}>
          <Button type="primary" onClick={handleCreateGraph}>
            Create your first graph
          </Button>
        </Empty>
      ) : filteredGraphs.length === 0 ? (
        <div style={{ marginTop: 48 }}>
          <Empty description={`No graphs match "${searchTerm}"`} />
        </div>
      ) : (
        <div
          style={{
            display: 'flex',
            flexWrap: 'wrap',
            gap: 24,
            padding: 24,
          }}>
          {filteredGraphs.map((graph) => {
            const statusMeta = getStatusMeta(graph);
            const updatedAt = new Date(
              graph.updatedAt || graph.createdAt || new Date().toISOString(),
            );

            return (
              <Card
                key={graph.id}
                hoverable
                onClick={() => handleEditGraph(graph.id)}
                style={{
                  borderRadius: 15,
                  border: '1px solid #e5e7eb',
                  backgroundColor: '#ffffff',
                  cursor: 'pointer',
                  flex: '0 0 clamp(280px, 28vw, 360px)',
                }}
                styles={{
                  body: {
                    padding: 15,
                    display: 'flex',
                    flexDirection: 'column',
                    height: '100%',
                  },
                }}>
                <div
                  style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'flex-start',
                    marginBottom: 16,
                  }}>
                  <div>
                    <div
                      style={{
                        fontSize: 18,
                        fontWeight: 500,
                        color: '#111827',
                        marginBottom: 5,
                      }}>
                      {graph.name}
                    </div>
                    <div
                      style={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: 12,
                      }}>
                      <Tag
                        style={{
                          margin: 0,
                          border: 'none',
                          color: statusMeta.color,
                          backgroundColor: statusMeta.bg,
                        }}>
                        {statusMeta.label}
                      </Tag>
                      <span
                        style={{
                          fontSize: 12,
                          color: '#6b7280',
                        }}>
                        v{graph.version}
                      </span>
                    </div>
                  </div>
                  <div onClick={(e) => e.stopPropagation()}>
                    <Dropdown
                      trigger={['click']}
                      menu={{
                        items: [
                          {
                            key: 'edit',
                            icon: <EditOutlined />,
                            label: 'Edit',
                          },
                          { type: 'divider' },
                          {
                            key: 'delete',
                            icon: <DeleteOutlined />,
                            danger: true,
                            label: 'Delete',
                            disabled: deleting === graph.id,
                          },
                        ],
                        onClick: ({ key }) => {
                          if (key === 'edit') {
                            openEditModal(graph);
                          } else if (key === 'delete') {
                            confirmDeleteGraph(graph.id);
                          }
                        },
                      }}>
                      <Button
                        type="text"
                        icon={<EllipsisOutlined />}
                        style={{
                          border: 'none',
                          boxShadow: 'none',
                          color: '#6b7280',
                        }}
                      />
                    </Dropdown>
                  </div>
                </div>

                <Paragraph
                  style={{
                    color: '#374151',
                    fontSize: 14,
                    marginBottom: 8,
                  }}>
                  {graph.description ||
                    'Automated workflow for your agent graphs.'}
                </Paragraph>

                <div
                  style={{
                    display: 'flex',
                    flexWrap: 'wrap',
                    alignItems: 'center',
                    gap: '2px 8px',
                    color: '#9ca3af',
                    fontSize: 13,
                  }}>
                  <span>{getNodeCount(graph)} nodes</span>
                  <span>·</span>
                  <span
                    style={{
                      display: 'inline-flex',
                      alignItems: 'center',
                      gap: 4,
                    }}>
                    <CommentOutlined />
                    {graph.runningThreads ?? 0} running of{' '}
                    {graph.totalThreads ?? 0} threads
                  </span>
                  <span>·</span>
                  <span>
                    Modified{' '}
                    {formatDistanceToNow(updatedAt, { addSuffix: true })}
                  </span>
                </div>
              </Card>
            );
          })}
        </div>
      )}

      <Modal
        title="Edit Graph"
        open={!!editingGraph}
        onCancel={() => setEditingGraph(null)}
        onOk={handleSaveGraphDetails}
        confirmLoading={editSaving}
        okText="Save"
        destroyOnClose>
        <Form form={editForm} layout="vertical" style={{ marginTop: 16 }}>
          <Form.Item
            name="name"
            label="Name"
            rules={[{ required: true, message: 'Graph name is required' }]}>
            <Input />
          </Form.Item>
          <Form.Item name="description" label="Description">
            <Input.TextArea rows={3} />
          </Form.Item>
        </Form>
      </Modal>

      <Modal
        title="Delete graph"
        open={!!deletingGraphId}
        onCancel={() => setDeletingGraphId(null)}
        onOk={handleConfirmDelete}
        confirmLoading={deleting === deletingGraphId}
        okText="Delete"
        okButtonProps={{ danger: true }}
        centered>
        Are you sure you want to delete this graph? This action cannot be
        undone.
      </Modal>
    </div>
  );
};
