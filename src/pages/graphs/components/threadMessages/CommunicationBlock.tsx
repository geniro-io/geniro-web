import {
  DownOutlined,
  LoadingOutlined,
  RightOutlined,
} from '@ant-design/icons';
import { Popover, Typography } from 'antd';
import React, { useMemo, useState } from 'react';

import type {
  ThreadMessageDto,
  ThreadMessageDtoRequestTokenUsage,
} from '../../../../autogenerated';
import { MarkdownContent } from '../../../../components/markdown/MarkdownContent';
import {
  EXPAND_TOGGLE_STYLE,
  FOOTER_ROW_STYLE,
  HEADER_LABEL_STYLE,
  INNER_AREA_STYLE,
  PARENT_CONTENT_STYLE,
  THINKING_STYLE,
} from './blockStyles';
import { formatMessageContent } from './messageUtils';
import { StatisticsFooter } from './StatisticsFooter';
import { StatusTag } from './StatusTag';
import { StyledSection } from './StyledSection';
import type {
  PreparedMessage,
  SubagentStatistics,
} from './threadMessagesTypes';

const COLLAPSED_MESSAGE_COUNT = 3;

const { Text } = Typography;

export interface CommunicationBlockProps {
  targetAgentName?: string;
  targetAvatarSrc?: string;
  /** The parent AI message whose text content triggered the communication. */
  parentMessage?: ThreadMessageDto;
  instructionMessage?: ThreadMessageDto;
  status: 'calling' | 'executed' | 'stopped';
  innerMessages: PreparedMessage[];
  statistics?: SubagentStatistics;
  resultText?: string;
  errorText?: string;
  model?: string;
  /** Pre-rendered popover content (built via renderToolPopoverContent in the parent). */
  popoverContent?: React.ReactNode;
  /** LLM request-level token usage (input message that triggered the tool call). */
  requestTokenUsageIn?: ThreadMessageDtoRequestTokenUsage | null;
  /** LLM request-level token usage (tool result message). */
  requestTokenUsageOut?: ThreadMessageDtoRequestTokenUsage | null;
  renderItem: (item: PreparedMessage, index: number) => React.ReactNode;
}

export const CommunicationBlock: React.FC<CommunicationBlockProps> = ({
  targetAgentName,
  targetAvatarSrc,
  parentMessage,
  instructionMessage,
  status,
  innerMessages,
  statistics,
  resultText,
  errorText,
  model,
  popoverContent,
  requestTokenUsageIn,
  requestTokenUsageOut,
  renderItem,
}) => {
  const isCalling = status === 'calling';
  const [expanded, setExpanded] = useState(false);

  const headerLabel = targetAgentName
    ? `Communication: ${targetAgentName}`
    : 'Agent Communication';

  const parentContent = useMemo(() => {
    if (!parentMessage) return undefined;
    const raw = parentMessage.message?.content;
    if (!raw) return undefined;
    return formatMessageContent(raw);
  }, [parentMessage]);

  const instructionContent = useMemo(() => {
    if (!instructionMessage) return undefined;
    const raw = instructionMessage.message?.content;
    if (!raw) return undefined;
    return formatMessageContent(raw);
  }, [instructionMessage]);

  const instructionLabel = targetAgentName
    ? `Providing Instructions for ${targetAgentName}`
    : 'Providing Instructions';
  const errorLabel = targetAgentName
    ? `Error from ${targetAgentName}`
    : 'Error';
  const resultLabel = targetAgentName
    ? `Result from ${targetAgentName}`
    : 'Result';

  const filteredInnerMessages = useMemo(() => {
    if (!resultText || innerMessages.length === 0) return innerMessages;
    let filtered = innerMessages;
    const last = filtered[filtered.length - 1];
    if (last.type === 'tool' && last.name?.toLowerCase() === 'finish') {
      filtered = filtered.slice(0, -1);
    }
    if (filtered.length > 0) {
      const newLast = filtered[filtered.length - 1];
      if (newLast.type === 'chat' && !newLast.isToolCallContent) {
        filtered = filtered.slice(0, -1);
      }
    }
    return filtered;
  }, [innerMessages, resultText]);

  // Count only non-reasoning messages for collapse threshold.
  const nonReasoningCount = filteredInnerMessages.filter(
    (m) => m.type !== 'reasoning',
  ).length;
  const isCollapsible =
    !isCalling && nonReasoningCount > COLLAPSED_MESSAGE_COUNT;

  // When collapsed, take items from the start until we have enough non-reasoning ones.
  const visibleMessages = useMemo(() => {
    if (!isCollapsible || expanded) return filteredInnerMessages;
    const result: PreparedMessage[] = [];
    let count = 0;
    for (const m of filteredInnerMessages) {
      result.push(m);
      if (m.type !== 'reasoning') count++;
      if (count >= COLLAPSED_MESSAGE_COUNT) break;
    }
    return result;
  }, [filteredInnerMessages, isCollapsible, expanded]);

  const hiddenCount = nonReasoningCount - COLLAPSED_MESSAGE_COUNT;

  const isClickable =
    (status === 'executed' || status === 'stopped') && !!popoverContent;

  const headerRow = (
    <div
      style={{
        display: 'flex',
        alignItems: 'center',
        gap: 6,
        cursor: isClickable ? 'pointer' : undefined,
      }}
      aria-label={
        isClickable
          ? `View communication details for ${headerLabel}`
          : undefined
      }>
      {isCalling && (
        <LoadingOutlined style={{ fontSize: 11, color: '#595959' }} />
      )}
      {targetAvatarSrc && (
        <img
          src={targetAvatarSrc}
          alt=""
          style={{
            width: 18,
            height: 18,
            borderRadius: '50%',
            flexShrink: 0,
          }}
        />
      )}
      <Text style={HEADER_LABEL_STYLE}>{headerLabel}</Text>
      <StatusTag status={status} hasError={!!errorText} />
    </div>
  );

  return (
    <div
      style={{
        display: 'flex',
        flexDirection: 'column',
        gap: 6,
        width: '100%',
      }}>
      {/* Header row — wrapped in Popover for click-to-view input/output */}
      {isClickable ? (
        <Popover
          content={popoverContent}
          trigger={['click']}
          placement="topLeft">
          {headerRow}
        </Popover>
      ) : (
        headerRow
      )}

      {/* Parent AI text */}
      {parentContent && (
        <div style={PARENT_CONTENT_STYLE}>
          <MarkdownContent
            content={parentContent}
            style={{
              fontSize: '12px',
              lineHeight: '1.4',
              color: '#333',
            }}
          />
        </div>
      )}

      {/* Instruction content */}
      {instructionContent && (
        <StyledSection
          variant="instruction"
          label={instructionLabel}
          content={instructionContent}
          collapsible
        />
      )}

      {/* Inner messages area */}
      {(filteredInnerMessages.length > 0 || isCalling) && (
        <div style={INNER_AREA_STYLE}>
          {filteredInnerMessages.length === 0 && isCalling && (
            <Text
              type="secondary"
              style={{ fontSize: 12, fontStyle: 'italic' }}>
              Agent is working...
            </Text>
          )}
          {visibleMessages.map((item, idx) => (
            <div
              key={item.id || idx}
              style={
                idx < visibleMessages.length - 1
                  ? { marginBottom: 4 }
                  : undefined
              }>
              {renderItem(item, idx)}
            </div>
          ))}
          {isCollapsible && (
            <div
              onClick={() => setExpanded((prev) => !prev)}
              style={EXPAND_TOGGLE_STYLE}>
              {expanded ? (
                <>
                  <DownOutlined style={{ fontSize: 9 }} />
                  Collapse
                </>
              ) : (
                <>
                  <RightOutlined style={{ fontSize: 9 }} />
                  {hiddenCount} more message
                  {hiddenCount !== 1 ? 's' : ''}
                </>
              )}
            </div>
          )}
        </div>
      )}

      {errorText && (
        <StyledSection variant="error" label={errorLabel} content={errorText} />
      )}

      {resultText && !errorText && (
        <StyledSection
          variant="result"
          label={resultLabel}
          content={resultText}
          collapsible
        />
      )}

      {/* Thinking indicator + statistics — rendered on a single row when both present */}
      {isCalling && filteredInnerMessages.length > 0 ? (
        <div style={FOOTER_ROW_STYLE}>
          <StatisticsFooter
            statistics={statistics}
            model={model}
            requestTokenUsageIn={requestTokenUsageIn}
            requestTokenUsageOut={requestTokenUsageOut}
          />
          <div style={THINKING_STYLE}>
            {targetAgentName
              ? `${targetAgentName} is thinking...`
              : 'Agent is thinking...'}
          </div>
        </div>
      ) : (
        <StatisticsFooter
          statistics={statistics}
          model={model}
          requestTokenUsageIn={requestTokenUsageIn}
          requestTokenUsageOut={requestTokenUsageOut}
        />
      )}
    </div>
  );
};

CommunicationBlock.displayName = 'CommunicationBlock';
