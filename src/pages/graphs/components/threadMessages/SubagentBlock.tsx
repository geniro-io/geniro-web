import {
  DownOutlined,
  LoadingOutlined,
  RightOutlined,
} from '@ant-design/icons';
import { Popover, Typography } from 'antd';
import React, { useMemo, useState } from 'react';

import type { ThreadMessageDtoRequestTokenUsage } from '../../../../autogenerated';
import {
  EXPAND_TOGGLE_STYLE,
  FOOTER_ROW_STYLE,
  HEADER_LABEL_STYLE,
  INNER_AREA_STYLE,
  THINKING_STYLE,
} from './blockStyles';
import { StatisticsFooter } from './StatisticsFooter';
import { StatusTag } from './StatusTag';
import { StyledSection } from './StyledSection';
import type {
  PreparedMessage,
  SubagentStatistics,
} from './threadMessagesTypes';

const COLLAPSED_MESSAGE_COUNT = 3;

const { Text } = Typography;

export interface SubagentBlockProps {
  purpose?: string;
  taskDescription?: string;
  model?: string;
  status: 'calling' | 'executed' | 'stopped';
  innerMessages: PreparedMessage[];
  statistics?: SubagentStatistics;
  resultText?: string;
  errorText?: string;
  /** Pre-rendered popover content (built via renderToolPopoverContent in the parent). */
  popoverContent?: React.ReactNode;
  /** LLM request-level token usage (input message that triggered the tool call). */
  requestTokenUsageIn?: ThreadMessageDtoRequestTokenUsage | null;
  /** LLM request-level token usage (tool result message). */
  requestTokenUsageOut?: ThreadMessageDtoRequestTokenUsage | null;
  renderItem: (item: PreparedMessage, index: number) => React.ReactNode;
}

/**
 * Filter out redundant trailing messages when resultText is present —
 * their content is already surfaced in the Result section below.
 */
const filterTrailingMessages = (
  messages: PreparedMessage[],
  hasResultText: boolean,
): PreparedMessage[] => {
  if (!hasResultText || messages.length === 0) return messages;

  let filtered = messages;

  // Remove trailing finish tool — its result duplicates the Result section
  const last = filtered[filtered.length - 1];
  if (last.type === 'tool' && last.name?.toLowerCase() === 'finish') {
    filtered = filtered.slice(0, -1);
  }

  // Remove trailing plain chat (no tool calls) — its content duplicates resultText
  if (filtered.length > 0) {
    const newLast = filtered[filtered.length - 1];
    if (newLast.type === 'chat' && !newLast.isToolCallContent) {
      filtered = filtered.slice(0, -1);
    }
  }

  return filtered;
};

export const SubagentBlock: React.FC<SubagentBlockProps> = ({
  purpose,
  taskDescription,
  model,
  status,
  innerMessages,
  statistics,
  resultText,
  errorText,
  popoverContent,
  requestTokenUsageIn,
  requestTokenUsageOut,
  renderItem,
}) => {
  const isCalling = status === 'calling';
  const [expanded, setExpanded] = useState(false);

  const headerLabel = purpose ? `Subagent: ${purpose}` : 'Subagent';

  const filteredInnerMessages = useMemo(
    () => filterTrailingMessages(innerMessages, !!resultText),
    [innerMessages, resultText],
  );

  // Count only non-reasoning messages for collapse threshold.
  const nonReasoningCount = filteredInnerMessages.filter(
    (m) => m.type !== 'reasoning',
  ).length;
  const isCollapsible = nonReasoningCount > COLLAPSED_MESSAGE_COUNT;

  // When collapsed, take items from the start until we have enough non-reasoning ones.
  const visibleMessages = useMemo(() => {
    if (!isCollapsible || expanded) return filteredInnerMessages;
    const result: PreparedMessage[] = [];
    let count = 0;
    for (const m of filteredInnerMessages) {
      result.push(m);
      if (m.type !== 'reasoning') count++;
      if (count >= COLLAPSED_MESSAGE_COUNT) break;
    }
    return result;
  }, [filteredInnerMessages, isCollapsible, expanded]);

  const hiddenCount = nonReasoningCount - COLLAPSED_MESSAGE_COUNT;

  const isClickable =
    (status === 'executed' || status === 'stopped') && !!popoverContent;

  const headerRow = (
    <div
      style={{
        display: 'flex',
        alignItems: 'center',
        gap: 6,
        cursor: isClickable ? 'pointer' : undefined,
      }}
      aria-label={
        isClickable ? `View subagent details for ${headerLabel}` : undefined
      }>
      {isCalling && (
        <LoadingOutlined style={{ fontSize: 11, color: '#595959' }} />
      )}
      <Text style={HEADER_LABEL_STYLE}>{headerLabel}</Text>
      <StatusTag status={status} hasError={!!errorText} />
    </div>
  );

  return (
    <div
      style={{
        display: 'flex',
        flexDirection: 'column',
        gap: 6,
        width: '100%',
      }}>
      {/* Header row — wrapped in Popover for click-to-view input/output */}
      {isClickable ? (
        <Popover
          content={popoverContent}
          trigger={['click']}
          placement="topLeft">
          {headerRow}
        </Popover>
      ) : (
        headerRow
      )}

      {taskDescription && (
        <StyledSection
          variant="task"
          label="Task"
          content={taskDescription}
          collapsible
        />
      )}

      {/* Inner messages area */}
      {(filteredInnerMessages.length > 0 || isCalling) && (
        <div style={INNER_AREA_STYLE}>
          {filteredInnerMessages.length === 0 && isCalling && (
            <Text
              type="secondary"
              style={{ fontSize: 12, fontStyle: 'italic' }}>
              Subagent is working...
            </Text>
          )}
          {visibleMessages.map((item, idx) => (
            <div
              key={item.id || idx}
              style={
                idx < visibleMessages.length - 1
                  ? { marginBottom: 6 }
                  : undefined
              }>
              {renderItem(item, idx)}
            </div>
          ))}
          {isCollapsible && (
            <div
              onClick={() => setExpanded((prev) => !prev)}
              style={EXPAND_TOGGLE_STYLE}>
              {expanded ? (
                <>
                  <DownOutlined style={{ fontSize: 9 }} />
                  Collapse
                </>
              ) : (
                <>
                  <RightOutlined style={{ fontSize: 9 }} />
                  {hiddenCount} more message{hiddenCount !== 1 ? 's' : ''}
                </>
              )}
            </div>
          )}
        </div>
      )}

      {errorText && (
        <StyledSection variant="error" label="Error" content={errorText} />
      )}

      {resultText && !errorText && (
        <StyledSection
          variant="result"
          label="Result"
          content={resultText}
          collapsible
        />
      )}

      {/* Thinking indicator + statistics — rendered on a single row when both present */}
      {isCalling && filteredInnerMessages.length > 0 ? (
        <div style={FOOTER_ROW_STYLE}>
          <StatisticsFooter
            statistics={statistics}
            model={model}
            requestTokenUsageIn={requestTokenUsageIn}
            requestTokenUsageOut={requestTokenUsageOut}
          />
          <div style={THINKING_STYLE}>Agent is thinking...</div>
        </div>
      ) : (
        <StatisticsFooter
          statistics={statistics}
          model={model}
          requestTokenUsageIn={requestTokenUsageIn}
          requestTokenUsageOut={requestTokenUsageOut}
        />
      )}
    </div>
  );
};

SubagentBlock.displayName = 'SubagentBlock';
