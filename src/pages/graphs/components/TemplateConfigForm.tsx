import { ExpandOutlined } from '@ant-design/icons';
import Form from '@rjsf/antd';
import type {
  FieldProps,
  FieldTemplateProps,
  ObjectFieldTemplateProps,
  RJSFSchema,
  UiSchema,
  WidgetProps,
} from '@rjsf/utils';
import validator from '@rjsf/validator-ajv8';
import { Button, Input, InputNumber, Select, Switch, Typography } from 'antd';
import React, { useMemo } from 'react';

import type { LiteLlmModelDto } from '../../../autogenerated';
import { GitHubAuthMethod } from '../../github-app/types';
import type { KeyValuePair, SchemaProperty } from '../types';
import { getSchemaTypeName } from '../utils/schemaUtils';
import { ArrayTagInput } from './ArrayTagInput';
import { KeyValuePairsInput } from './KeyValuePairsInput';

type FormData = Record<string, unknown>;
type RjsfSchema = RJSFSchema;
type UiSchemaShape = UiSchema<FormData, RJSFSchema, FormContext>;

type FormContext = {
  liteLlmModels: LiteLlmModelDto[];
  litellmModelsLoading: boolean;
  openExpandedTextarea: (fieldKey: string, value: string) => void;
  openAiSuggestion: (
    fieldKey: string,
    fieldLabel: string,
    value?: unknown,
  ) => void;
  aiSuggestionEnabled: boolean;
  githubAppEnabled: boolean;
  formData: FormData;
};

const handleNumberWheel: React.WheelEventHandler<HTMLElement> = (event) => {
  if (event.target instanceof HTMLInputElement) {
    event.target.blur();
  }
};

const getFormContext = (props: {
  formContext?: unknown;
  registry?: { formContext?: unknown };
}): FormContext => {
  const ctx = props.formContext ?? props.registry?.formContext ?? {};

  // Provide safe defaults for all required context properties
  const defaultContext: FormContext = {
    liteLlmModels: [],
    litellmModelsLoading: false,
    openExpandedTextarea: () => {},
    openAiSuggestion: () => {},
    aiSuggestionEnabled: false,
    githubAppEnabled: false,
    formData: {},
  };

  if (ctx && typeof ctx === 'object') {
    return { ...defaultContext, ...(ctx as Partial<FormContext>) };
  }

  return defaultContext;
};

const buildUiSchema = (schema: RjsfSchema): UiSchemaShape => {
  const props = (schema as { properties?: unknown })?.properties;
  if (!props || typeof props !== 'object') {
    return {};
  }

  const ui: UiSchemaShape = {};

  const getAdditionalProperties = (prop: SchemaProperty): unknown => {
    const direct = (prop as { additionalProperties?: unknown })
      .additionalProperties;
    if (direct !== undefined) {
      return direct;
    }

    if (Array.isArray(prop.allOf) && prop.allOf.length === 1) {
      return (prop.allOf[0] as { additionalProperties?: unknown } | undefined)
        ?.additionalProperties;
    }

    return undefined;
  };

  for (const [key, propUnknown] of Object.entries(
    props as Record<string, unknown>,
  )) {
    const prop = propUnknown as SchemaProperty;

    const fieldUi: UiSchemaShape = {};

    const uiLabel =
      typeof prop['x-ui:label'] === 'string'
        ? String(prop['x-ui:label'])
        : undefined;
    if (uiLabel) {
      fieldUi['ui:title'] = uiLabel;
    }

    if (prop['x-ui:textarea'] === true) {
      fieldUi['ui:widget'] = 'textareaWithExpand';
    }

    if (prop['x-ui:litellm-models-list-select'] === true) {
      fieldUi['ui:widget'] = 'litellmModelsSelect';
    }

    if (
      prop['x-ui:ai-suggestions'] === true &&
      prop['x-ui:textarea'] !== true &&
      prop['x-ui:litellm-models-list-select'] !== true
    ) {
      fieldUi['ui:widget'] = 'textWithAi';
    }

    const typeName = getSchemaTypeName(prop);

    if (typeName === 'array') {
      fieldUi['ui:field'] = 'arrayAsTextarea';
    }

    const isObjectWithAdditionalProps =
      typeName === 'object' && Boolean(getAdditionalProperties(prop));
    if (isObjectWithAdditionalProps) {
      fieldUi['ui:field'] = 'keyValueObject';
    }

    ui[key] = fieldUi;
  }

  return ui;
};

// --- Hoisted RJSF templates ---

const RjsfObjectFieldTemplate = (
  props: ObjectFieldTemplateProps<FormData, RJSFSchema, FormContext>,
) => {
  // RJSF AntD default wraps objects in a panel/card which doesn't match our sidebar.
  return (
    <div>
      {props.properties.map((p) => (
        <div key={p.name}>{p.content}</div>
      ))}
    </div>
  );
};

const RjsfFieldTemplate = (
  props: FieldTemplateProps<FormData, RJSFSchema, FormContext>,
) => {
  const ctx = getFormContext(props);

  // Hide patToken field when authMethod is 'github_app'
  if (
    props.id?.endsWith('_patToken') &&
    ctx.formData?.authMethod === GitHubAuthMethod.GitHubApp
  ) {
    return null;
  }

  const schemaType = (props.schema as { type?: unknown } | undefined)?.type;
  const isBooleanField = schemaType === 'boolean';
  // RJSF often sets displayLabel=false for boolean widgets (checkbox),
  // but we render a Switch and still want the label visible.
  const showLabel =
    Boolean(props.label) && (props.displayLabel !== false || isBooleanField);
  const descriptionText =
    typeof props.rawDescription === 'string' ? props.rawDescription : '';

  return (
    <div style={{ marginBottom: 15 }}>
      {showLabel && (
        <div style={{ display: 'flex', alignItems: 'center', gap: 5 }}>
          <Typography.Text style={{ fontSize: 15 }}>
            {props.label}
          </Typography.Text>
          {props.required && (
            <span
              style={{
                color: 'gray',
                fontSize: 11,
                position: 'relative',
                top: '1px',
              }}>
              (required)
            </span>
          )}
        </div>
      )}

      <div style={{ marginTop: showLabel ? 4 : 0 }}>{props.children}</div>

      {descriptionText && (
        <Typography.Text
          type="secondary"
          style={{
            display: 'block',
            marginTop: 6,
            fontSize: 14,
            lineHeight: 1.25,
          }}>
          {descriptionText}
        </Typography.Text>
      )}

      {props.errors}
    </div>
  );
};

// --- Hoisted RJSF widgets ---

const RjsfSelectWidget = (
  props: WidgetProps<string, RJSFSchema, FormContext>,
) => {
  const ctx = getFormContext(props);

  let enumOptions = (
    (
      props.options as {
        enumOptions?: { label: string; value: unknown }[];
      }
    ).enumOptions ?? []
  ).map((opt) => ({
    label: opt.label,
    value: opt.value as string,
  }));

  // Filter out 'github_app' option from authMethod when GitHub App is not enabled
  const isAuthMethodField = props.id?.endsWith('_authMethod');
  if (isAuthMethodField && !ctx.githubAppEnabled) {
    enumOptions = enumOptions.filter(
      (opt) => opt.value !== GitHubAuthMethod.GitHubApp,
    );
  }

  const placeholder =
    props.placeholder ??
    (props.label ? `Select ${String(props.label).toLowerCase()}` : 'Select');

  return (
    <Select
      value={typeof props.value === 'string' ? props.value : undefined}
      onChange={(v) => props.onChange(v)}
      allowClear={!props.required}
      showSearch
      filterOption={(input, option) =>
        (option?.label ?? '')
          .toString()
          .toLowerCase()
          .includes(input.toLowerCase())
      }
      options={enumOptions}
      disabled={props.disabled || props.readonly}
      placeholder={placeholder}
      style={{ width: '100%' }}
    />
  );
};

const RjsfNumberWidget = (
  props: WidgetProps<number, RJSFSchema, FormContext>,
) => {
  const schema = props.schema as {
    minimum?: number;
    maximum?: number;
    multipleOf?: number;
  };
  const rawValue: unknown = props.value;
  const value =
    typeof rawValue === 'number' && Number.isFinite(rawValue)
      ? rawValue
      : undefined;

  return (
    <div onWheelCapture={handleNumberWheel}>
      <InputNumber
        value={value}
        onChange={(next) => {
          props.onChange(
            typeof next === 'number' && Number.isFinite(next)
              ? next
              : undefined,
          );
        }}
        min={schema.minimum}
        max={schema.maximum}
        step={schema.multipleOf}
        disabled={props.disabled || props.readonly}
        placeholder={props.placeholder}
        style={{ width: '100%' }}
      />
    </div>
  );
};

const RjsfUpDownWidget = (
  props: WidgetProps<number, RJSFSchema, FormContext>,
) => (
  <div onWheelCapture={handleNumberWheel}>
    <InputNumber
      value={
        typeof props.value === 'number' && Number.isFinite(props.value)
          ? props.value
          : undefined
      }
      onChange={(next) => {
        props.onChange(
          typeof next === 'number' && Number.isFinite(next) ? next : undefined,
        );
      }}
      min={(props.schema as { minimum?: number }).minimum}
      max={(props.schema as { maximum?: number }).maximum}
      step={(props.schema as { multipleOf?: number }).multipleOf}
      disabled={props.disabled || props.readonly}
      placeholder={props.placeholder}
      style={{ width: '100%' }}
    />
  </div>
);

const RjsfCheckboxWidget = (
  props: WidgetProps<boolean, RJSFSchema, FormContext>,
) => (
  <Switch
    checked={Boolean(props.value)}
    onChange={(checked) => props.onChange(checked)}
    disabled={props.disabled || props.readonly}
  />
);

const RjsfTextWithAiWidget = (
  props: WidgetProps<string, RJSFSchema, FormContext>,
) => {
  const ctx = getFormContext(props);
  const schemaForField = props.schema as unknown as SchemaProperty;
  const hasAiSuggestions = schemaForField?.['x-ui:ai-suggestions'] === true;

  return (
    <div style={{ display: 'flex', flexDirection: 'column' }}>
      <Input
        value={typeof props.value === 'string' ? props.value : ''}
        onChange={(e) => props.onChange(e.target.value)}
        disabled={props.disabled || props.readonly}
        placeholder={props.placeholder}
      />
      {hasAiSuggestions && ctx.aiSuggestionEnabled === true && (
        <Button
          type="link"
          size="small"
          style={{ padding: 0, height: 'auto', fontSize: 12 }}
          disabled={ctx.aiSuggestionEnabled !== true}
          onClick={() =>
            ctx.openAiSuggestion?.(
              props.name,
              props.label ?? props.name,
              props.value,
            )
          }>
          Improve with AI
        </Button>
      )}
    </div>
  );
};

const RjsfTextareaWithExpandWidget = (
  props: WidgetProps<string, RJSFSchema, FormContext>,
) => {
  const ctx = getFormContext(props);
  const schemaForField = props.schema as unknown as SchemaProperty;
  const hasAiSuggestions = schemaForField?.['x-ui:ai-suggestions'] === true;

  return (
    <div style={{ position: 'relative' }}>
      <Input.TextArea
        value={typeof props.value === 'string' ? props.value : ''}
        onChange={(e) => props.onChange(e.target.value)}
        rows={4}
        style={{ paddingRight: '32px', resize: 'none' }}
        disabled={props.disabled || props.readonly}
        placeholder={props.placeholder}
      />
      <Button
        type="text"
        icon={<ExpandOutlined />}
        size="small"
        style={{
          position: 'absolute',
          right: '4px',
          top: '4px',
          zIndex: 1,
        }}
        onClick={() =>
          ctx.openExpandedTextarea?.(
            props.name,
            typeof props.value === 'string' ? props.value : '',
          )
        }
        disabled={props.disabled || props.readonly}
      />
      {hasAiSuggestions && ctx.aiSuggestionEnabled === true && (
        <Button
          type="link"
          size="small"
          style={{ padding: 0, height: 'auto', fontSize: 12 }}
          disabled={ctx.aiSuggestionEnabled !== true}
          onClick={() =>
            ctx.openAiSuggestion?.(
              props.name,
              props.label ?? props.name,
              props.value,
            )
          }>
          Improve with AI
        </Button>
      )}
    </div>
  );
};

const RjsfLitellmModelsSelectWidget = (
  props: WidgetProps<string, RJSFSchema, FormContext>,
) => {
  const ctx = getFormContext(props);
  const options = (ctx.liteLlmModels ?? []).map((model: LiteLlmModelDto) => ({
    label: model.ownedBy ? `${model.id} (${model.ownedBy})` : model.id,
    value: model.id,
  }));
  return (
    <Select
      value={typeof props.value === 'string' ? props.value : undefined}
      onChange={(v) => props.onChange(v)}
      allowClear={!props.required}
      showSearch
      loading={ctx.litellmModelsLoading === true}
      notFoundContent={
        ctx.litellmModelsLoading === true
          ? 'Loading models...'
          : 'No models available'
      }
      filterOption={(input, option) =>
        (option?.label ?? '')
          .toString()
          .toLowerCase()
          .includes(input.toLowerCase())
      }
      options={options}
      disabled={props.disabled || props.readonly}
      placeholder={props.placeholder}
      style={{ width: '100%' }}
    />
  );
};

// --- Hoisted RJSF fields ---

const RjsfArrayAsTextareaField = (
  props: FieldProps<string[], RJSFSchema, FormContext>,
) => {
  const current = Array.isArray(props.formData)
    ? (props.formData as string[])
    : [];
  return (
    <div>
      <Typography.Text strong>
        {props.schema.title ?? props.name}
      </Typography.Text>
      {props.schema.description && (
        <Typography.Text
          type="secondary"
          style={{ display: 'block', fontSize: 12, marginBottom: 8 }}>
          {props.schema.description}
        </Typography.Text>
      )}
      <ArrayTagInput
        value={current}
        onChange={(lines) => {
          props.onChange(lines, props.fieldPathId.path);
        }}
        disabled={props.disabled || props.readonly}
        placeholder="Enter item and press Enter"
      />
    </div>
  );
};

const RjsfKeyValueObjectField = (
  props: FieldProps<Record<string, string>, RJSFSchema, FormContext>,
) => {
  const record =
    props.formData &&
    typeof props.formData === 'object' &&
    !Array.isArray(props.formData)
      ? (props.formData as Record<string, unknown>)
      : {};

  const pairs: KeyValuePair[] = Object.entries(record).map(([k, v]) => ({
    key: k,
    value: v === undefined || v === null ? '' : String(v),
  }));

  return (
    <div>
      <Typography.Text strong>
        {props.schema.title ?? props.name}
      </Typography.Text>
      {props.schema.description && (
        <Typography.Text
          type="secondary"
          style={{ display: 'block', fontSize: 12 }}>
          {props.schema.description}
        </Typography.Text>
      )}
      <KeyValuePairsInput
        value={pairs}
        onChange={(nextPairs) => {
          const next: Record<string, string> = {};
          for (const pair of nextPairs) {
            const k = pair.key.trim();
            if (!k) continue;
            next[k] = pair.value;
          }
          props.onChange(next, props.fieldPathId.path);
        }}
      />
    </div>
  );
};

// --- Stable RJSF config objects (module-level, never re-created) ---

const RJSF_TEMPLATES = {
  ObjectFieldTemplate: RjsfObjectFieldTemplate,
  FieldTemplate: RjsfFieldTemplate,
};

const RJSF_WIDGETS = {
  SelectWidget: RjsfSelectWidget,
  NumberWidget: RjsfNumberWidget,
  UpDownWidget: RjsfUpDownWidget,
  CheckboxWidget: RjsfCheckboxWidget,
  textWithAi: RjsfTextWithAiWidget,
  textareaWithExpand: RjsfTextareaWithExpandWidget,
  litellmModelsSelect: RjsfLitellmModelsSelectWidget,
};

const RJSF_FIELDS = {
  arrayAsTextarea: RjsfArrayAsTextareaField,
  keyValueObject: RjsfKeyValueObjectField,
};

// --- Component ---

export interface TemplateConfigFormProps {
  schema: RjsfSchema;
  formData: FormData;
  onChange: (next: FormData) => void;
  liteLlmModels: LiteLlmModelDto[];
  litellmModelsLoading: boolean;
  onOpenExpandedTextarea: (fieldKey: string, value: string) => void;
  onOpenAiSuggestion: (
    fieldKey: string,
    fieldLabel: string,
    value?: unknown,
  ) => void;
  aiSuggestionEnabled: boolean;
  githubAppEnabled?: boolean;
}

export const TemplateConfigForm: React.FC<TemplateConfigFormProps> = ({
  schema,
  formData,
  onChange,
  liteLlmModels,
  litellmModelsLoading,
  onOpenExpandedTextarea,
  onOpenAiSuggestion,
  aiSuggestionEnabled,
  githubAppEnabled = false,
}) => {
  const uiSchema = useMemo(() => buildUiSchema(schema), [schema]);

  const formContext: FormContext = useMemo(
    () => ({
      liteLlmModels,
      litellmModelsLoading,
      openExpandedTextarea: onOpenExpandedTextarea,
      openAiSuggestion: onOpenAiSuggestion,
      aiSuggestionEnabled,
      githubAppEnabled,
      formData,
    }),
    [
      aiSuggestionEnabled,
      formData,
      githubAppEnabled,
      liteLlmModels,
      litellmModelsLoading,
      onOpenAiSuggestion,
      onOpenExpandedTextarea,
    ],
  );

  return (
    <Form
      schema={schema}
      uiSchema={uiSchema}
      formData={formData}
      formContext={formContext}
      validator={validator}
      showErrorList={false}
      noHtml5Validate
      liveValidate={false}
      templates={RJSF_TEMPLATES}
      widgets={RJSF_WIDGETS}
      fields={RJSF_FIELDS}
      onChange={(e) => {
        const next = (e.formData ?? {}) as FormData;
        onChange(next);
      }}>
      {/* No submit button in this UI (changes are propagated live) */}
      <></>
    </Form>
  );
};
