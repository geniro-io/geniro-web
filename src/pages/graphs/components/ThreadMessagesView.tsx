// ThreadMessagesView.tsx
import { ToolOutlined } from '@ant-design/icons';
import JsonView from '@uiw/react-json-view';
import { lightTheme } from '@uiw/react-json-view/light';
import { Popover, Space, Spin, Typography } from 'antd';
import isPlainObject from 'lodash/isPlainObject';
import React, {
  useCallback,
  useEffect,
  useLayoutEffect,
  useMemo,
  useRef,
} from 'react';
import type { JsonValue } from 'type-fest';

import type {
  ThreadMessageDto,
  ThreadMessageDtoRequestTokenUsage,
} from '../../../autogenerated';
import { MarkdownContent } from '../../../components/markdown/MarkdownContent';
import { getAgentAvatarDataUri } from '../../../utils/agentAvatars';
import type { PendingMessage } from '../types/messages';
import { ChatBubble } from './threadMessages/ChatBubble';
import { CommunicationBlock } from './threadMessages/CommunicationBlock';
import { InlineReasoningMessage } from './threadMessages/InlineReasoningMessage';
import {
  formatMessageContent,
  isBlankContent,
} from './threadMessages/messageUtils';
import { prepareReadyMessages } from './threadMessages/prepareMessages';
import { renderFooterLineWithUsage } from './threadMessages/renderFooterLineWithUsage';
import { ShellToolDisplay } from './threadMessages/ShellToolDisplay';
import { SubagentBlock } from './threadMessages/SubagentBlock';
import type {
  PreparedMessage,
  ToolRenderStatus,
} from './threadMessages/threadMessagesTypes';
import {
  centeredStateStyle,
  ensureThinkingIndicatorStyles,
  extractDurationMs,
  extractToolErrorText,
  fullHeightColumnStyle,
  getAdditionalKwargs,
  getMessageString,
  getMessageTitle,
  isToolLikeRole,
  messageBlockStyle,
  parseJsonSafe,
  scrollContainerStyle,
} from './threadMessages/threadMessagesViewUtils';
import { TokenUsagePopoverIcon } from './threadMessages/TokenUsagePopoverIcon';

const { Text } = Typography;

/** Stable style references for MarkdownContent to enable React.memo effectiveness. */
const MARKDOWN_DEFAULT_STYLE: React.CSSProperties = {
  fontSize: '14px',
  lineHeight: '1.4',
  color: '#000000',
};

const MARKDOWN_COMPACT_STYLE: React.CSSProperties = {
  fontSize: '13px',
  lineHeight: '1.4',
  color: '#333',
};

export interface ThreadMessagesViewProps {
  messages: ThreadMessageDto[];
  messagesLoading: boolean;
  selectedThreadId?: string;
  nodeId?: string;
  nodeDisplayNames?: Record<string, string>;
  showNodeHeadings?: boolean;
  isAgentNode?: boolean;
  nodeTemplateKind?: string;
  onLoadMoreMessages?: () => void;
  hasMoreMessages?: boolean;
  loadingMore?: boolean;
  isNodeRunning?: boolean;
  /**
   * When true, the thread was explicitly stopped by the user. In this state we
   * must never render tool calls as "in progress" (e.g. with a spinner).
   */
  isThreadStopped?: boolean;
  /**
   * Current thread run identifier. Tool calls from a different run must never
   * render as "in progress".
   */
  currentThreadLastRunId?: string | null;
  pendingMessages?: PendingMessage[];
  newMessageMode?: 'inject_after_tool_call' | 'wait_for_completion';
}

const ThreadMessagesView: React.FC<ThreadMessagesViewProps> = React.memo(
  ({
    messages,
    messagesLoading,
    selectedThreadId,
    nodeId,
    nodeDisplayNames,
    showNodeHeadings = false,
    isAgentNode = true,
    nodeTemplateKind,
    onLoadMoreMessages,
    hasMoreMessages,
    loadingMore,
    isNodeRunning = false,
    isThreadStopped = false,
    currentThreadLastRunId,
    pendingMessages = [],
    newMessageMode,
  }) => {
    const scrollContainerRef = useRef<HTMLDivElement | null>(null);
    const prevScrollHeightRef = useRef<number>(0);
    const prevScrollTopRef = useRef<number>(0);
    const isPrependingRef = useRef<boolean>(false);
    const pendingAutoScrollRef = useRef<boolean>(false);
    const autoScrollDisabledRef = useRef<boolean>(false);
    const lastMessageCountRef = useRef<number>(0);

    // Helper to identify working group items.
    const isWorkGroupItem = useCallback((item: PreparedMessage): boolean => {
      if (item.type === 'reasoning') return true;
      // Finish tool calls should render as standalone bubbles, not inside
      // the "Working..." block.
      if (
        item.type === 'tool' &&
        item.name?.toLowerCase() !== 'finish' &&
        item.name?.toLowerCase() !== 'proxy_finish'
      )
        return true;
      // AI text content that accompanies tool calls belongs in the working block.
      if (item.type === 'chat' && item.isToolCallContent) return true;
      return false;
    }, []);

    useEffect(() => {
      ensureThinkingIndicatorStyles();
    }, []);

    useEffect(() => {
      pendingAutoScrollRef.current = true;
    }, [selectedThreadId, nodeId]);

    // Restore scroll position synchronously before paint when older messages
    // are prepended at the top (load-more pagination).  Using useLayoutEffect
    // prevents the visible flicker / jump that occurs when the adjustment
    // happens in a regular useEffect (which runs *after* the browser paints).
    //
    // We use the scrollHeight and scrollTop captured at the moment the user
    // triggered load-more (in handleScroll) rather than the current scrollTop,
    // because intermediate renders (e.g. the loadingMore spinner appearing /
    // disappearing) can shift the scroll position between the trigger and the
    // moment new messages actually arrive.
    useLayoutEffect(() => {
      if (!isPrependingRef.current) return;
      if (messages.length === lastMessageCountRef.current) return;

      const el = scrollContainerRef.current;
      if (el) {
        const newContentHeight = el.scrollHeight - prevScrollHeightRef.current;
        el.scrollTop = prevScrollTopRef.current + newContentHeight;
      }
      isPrependingRef.current = false;
      lastMessageCountRef.current = messages.length;
    }, [messages.length]);

    // Auto-scroll to bottom on initial load, thread switch, or when the user
    // is already scrolled near the bottom and new messages arrive.
    useEffect(() => {
      if (isPrependingRef.current) return;
      if (messagesLoading) return;
      const el = scrollContainerRef.current;
      if (!el) return;

      const isInitiallyEmpty = lastMessageCountRef.current === 0;
      const shouldAutoScroll =
        pendingAutoScrollRef.current ||
        isInitiallyEmpty ||
        !autoScrollDisabledRef.current;

      if (shouldAutoScroll) {
        el.scrollTop = el.scrollHeight;
      }

      pendingAutoScrollRef.current = false;
      lastMessageCountRef.current = messages.length;
    }, [messagesLoading, messages.length]);

    useEffect(() => {
      if (!pendingMessages || pendingMessages.length === 0) return;
      const el = scrollContainerRef.current;
      if (!el) return;
      if (!autoScrollDisabledRef.current) {
        el.scrollTop = el.scrollHeight;
      }
    }, [pendingMessages]);

    useEffect(() => {
      const styleId = 'shell-scrollbar-styles';
      if (document.getElementById(styleId)) return;

      const style = document.createElement('style');
      style.id = styleId;
      style.textContent = `
      .shell-output-container::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      .shell-output-container::-webkit-scrollbar-track {
        background: #2a2a2a;
        border-radius: 4px;
      }
      .shell-output-container::-webkit-scrollbar-thumb {
        background: #555;
        border-radius: 4px;
      }
      .shell-output-container::-webkit-scrollbar-thumb:hover {
        background: #666;
      }
    `;
      document.head.appendChild(style);

      return () => {
        const existingStyle = document.getElementById(styleId);
        if (existingStyle) {
          existingStyle.remove();
        }
      };
    }, []);

    const handleScroll = useCallback(() => {
      const el = scrollContainerRef.current;
      if (!el) return;
      const nearTop = el.scrollTop <= 100;
      if (
        nearTop &&
        hasMoreMessages &&
        !loadingMore &&
        typeof onLoadMoreMessages === 'function'
      ) {
        prevScrollHeightRef.current = el.scrollHeight;
        prevScrollTopRef.current = el.scrollTop;
        isPrependingRef.current = true;
        onLoadMoreMessages();
      }
      const nearBottom = el.scrollHeight - el.scrollTop - el.clientHeight <= 48;
      autoScrollDisabledRef.current = !nearBottom;
    }, [hasMoreMessages, loadingMore, onLoadMoreMessages]);

    const renderToolPopoverContent = (
      value: unknown,
      toolOptions?: Record<string, JsonValue>,
      toolLabel?: string,
      requestTokenUsageIn?: ThreadMessageDtoRequestTokenUsage | null,
      requestTokenUsageOut?: ThreadMessageDtoRequestTokenUsage | null,
      durationMs?: number,
    ): React.ReactNode => {
      let parsed: JsonValue | null = null;
      if (typeof value === 'string') {
        parsed = parseJsonSafe(value) as JsonValue | null;
      } else if (
        value !== null &&
        (typeof value === 'object' ||
          typeof value === 'number' ||
          typeof value === 'boolean')
      ) {
        parsed = value as JsonValue;
      }

      const hasRequestTokenUsage = requestTokenUsageIn || requestTokenUsageOut;

      const containerStyle: React.CSSProperties = { maxWidth: 520 };
      const innerStyle: React.CSSProperties = {
        maxHeight: 300,
        overflow: 'auto',
        background: '#f5f5f5',
        border: '1px solid #eee',
        borderRadius: 6,
        padding: 12,
        fontFamily:
          'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace',
        fontSize: 12,
        whiteSpace: 'pre-wrap',
      };

      const sectionStyle: React.CSSProperties = {
        marginBottom: 16,
      };

      const sectionTitleStyle: React.CSSProperties = {
        fontWeight: 'bold',
        fontSize: 13,
        marginBottom: 8,
        color: '#333',
        borderBottom: '1px solid #ddd',
        paddingBottom: 4,
      };

      return (
        <div style={containerStyle}>
          {(toolLabel && toolLabel.trim().length > 0) ||
          hasRequestTokenUsage ? (
            <div
              style={{
                marginBottom: 12,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
                gap: 8,
              }}>
              {toolLabel && toolLabel.trim().length > 0 ? (
                <Text strong style={{ fontSize: 13 }}>
                  Tool: {toolLabel}
                </Text>
              ) : (
                <span />
              )}
              {hasRequestTokenUsage && (
                <TokenUsagePopoverIcon
                  requestTokenUsageIn={requestTokenUsageIn}
                  requestTokenUsageOut={requestTokenUsageOut}
                  durationMs={durationMs}
                />
              )}
            </div>
          ) : null}
          {toolOptions && Object.keys(toolOptions).length > 0 && (
            <div style={sectionStyle}>
              <div style={sectionTitleStyle}>Tool Options:</div>
              <div style={innerStyle}>
                <JsonView value={toolOptions} style={lightTheme} />
              </div>
            </div>
          )}

          {(parsed || (value !== undefined && value !== null)) && (
            <div style={sectionStyle}>
              <div style={sectionTitleStyle}>Output:</div>
              <div style={innerStyle}>
                {parsed ? (
                  <JsonView value={parsed as object} style={lightTheme} />
                ) : (
                  <pre
                    style={{
                      margin: 0,
                      whiteSpace: 'pre-wrap',
                      wordBreak: 'break-word',
                    }}>
                    {String(value ?? '')}
                  </pre>
                )}
              </div>
            </div>
          )}
        </div>
      );
    };

    const buildToolBlockPopover = (
      rawResult: unknown,
      rawArgs: unknown,
      toolLabel: string,
      tokenUsageIn?: ThreadMessageDtoRequestTokenUsage | null,
      tokenUsageOut?: ThreadMessageDtoRequestTokenUsage | null,
    ): React.ReactNode =>
      renderToolPopoverContent(
        rawResult,
        rawArgs && typeof rawArgs === 'object'
          ? (rawArgs as Record<string, JsonValue>)
          : undefined,
        toolLabel,
        tokenUsageIn,
        tokenUsageOut,
      );

    const preparedMessagesResult = useMemo(() => {
      return prepareReadyMessages(messages, {
        isNodeRunning,
        isThreadStopped,
        currentThreadLastRunId,
      });
    }, [messages, isNodeRunning, isThreadStopped, currentThreadLastRunId]);

    const isThinkingVisible = isNodeRunning && isAgentNode && !isThreadStopped;

    const lastAgentNodeId = useMemo(() => {
      for (let k = preparedMessagesResult.length - 1; k >= 0; k--) {
        const pm = preparedMessagesResult[k];
        const nid = pm.sourceAgentNodeId || pm.nodeId;
        if (nid) return nid;
      }
      return nodeId;
    }, [preparedMessagesResult, nodeId]);

    const lastAgentAvatarSrc = lastAgentNodeId
      ? getAgentAvatarDataUri(lastAgentNodeId)
      : undefined;

    const lastAgentName = lastAgentNodeId
      ? nodeDisplayNames?.[lastAgentNodeId] ||
        `Node ${lastAgentNodeId.slice(-6)}`
      : 'Agent';

    const renderFullHeightState = (content: React.ReactNode) => (
      <div style={fullHeightColumnStyle}>
        <div style={centeredStateStyle}>{content}</div>
      </div>
    );

    const renderSystemMessage = (message: ThreadMessageDto) => {
      const content = formatMessageContent(message.message?.content);

      const textContainerStyle: React.CSSProperties = {
        fontSize: '12px',
        color: '#afafaf',
        textAlign: 'center',
      };

      return (
        <div style={{ width: '90%', margin: '0 auto' }}>
          <div style={textContainerStyle}>
            <MarkdownContent content={content} allowHorizontalScroll={true} />
          </div>
        </div>
      );
    };

    const renderFinishTool = (
      status: ToolRenderStatus,
      resultContent?: unknown,
      requestTokenUsage?: ThreadMessageDtoRequestTokenUsage | null,
      metadata?: { nodeId?: string; createdAt?: string; roleLabel?: string },
      durationMs?: number,
    ) => {
      if (status !== 'executed') {
        return undefined;
      }

      let finishMessage = 'Task completed.';
      let needsMoreInfo = false;
      if (resultContent) {
        if (typeof resultContent === 'string') {
          finishMessage = resultContent;
        } else if (isPlainObject(resultContent)) {
          const obj = resultContent as Record<string, unknown>;
          finishMessage =
            (typeof obj.message === 'string' ? obj.message : '') ||
            (typeof obj.content === 'string' ? obj.content : '') ||
            (typeof obj.result === 'string' ? obj.result : '') ||
            'Task completed.';
          needsMoreInfo = Boolean(obj.needsMoreInfo);
        }
      }

      const messageColor = needsMoreInfo ? '#faad14' : '#52c41a';
      const statusTag = needsMoreInfo ? '⚠ Need more info' : '✓ Finished';
      const avatarSrc = metadata?.nodeId
        ? getAgentAvatarDataUri(metadata.nodeId)
        : undefined;

      const finishAgentName =
        (metadata?.nodeId && nodeDisplayNames?.[metadata.nodeId]) ||
        (metadata?.nodeId ? `Node ${metadata.nodeId.slice(-6)}` : 'Agent');

      const bubbleStyle: React.CSSProperties = {
        backgroundColor: '#f3f3f3',
        borderLeft: `3px solid ${messageColor}`,
      };

      return (
        <ChatBubble
          isHuman={false}
          avatarLabel="AI"
          avatarColor={messageColor}
          avatarSrc={avatarSrc}
          avatarTooltip={finishAgentName}
          containerStyle={{ marginBottom: '8px' }}
          bubbleStyle={bubbleStyle}
          footer={
            <Text
              type="secondary"
              style={{
                fontSize: '11px',
                marginTop: '4px',
                color: '#8c8c8c',
                display: 'block',
              }}>
              {renderFooterLineWithUsage(
                formatMetadataLine(
                  metadata?.createdAt,
                  metadata?.roleLabel,
                  metadata?.nodeId,
                ) ?? '',
                requestTokenUsage,
                undefined,
                undefined,
                durationMs,
              )}
            </Text>
          }>
          <Text
            type="secondary"
            style={{
              fontSize: '11px',
              marginBottom: '5px',
              display: 'block',
              color: messageColor,
              fontWeight: 'bold',
            }}>
            {statusTag}
          </Text>

          <MarkdownContent
            content={finishMessage}
            style={MARKDOWN_DEFAULT_STYLE}
          />
        </ChatBubble>
      );
    };

    const renderToolStatusLine = (opts: {
      name: string;
      status: ToolRenderStatus;
      resultContent?: unknown;
      toolOptions?: Record<string, JsonValue>;
      titleText?: string;
      align?: 'left' | 'center';
      requestTokenUsageIn?: ThreadMessageDtoRequestTokenUsage | null;
      requestTokenUsageOut?: ThreadMessageDtoRequestTokenUsage | null;
      durationMs?: number;
    }) => {
      const {
        name,
        status,
        resultContent,
        toolOptions,
        titleText,
        align = 'center',
        requestTokenUsageIn,
        requestTokenUsageOut,
        durationMs,
      } = opts;
      const hasToolOptions =
        toolOptions !== undefined &&
        toolOptions !== null &&
        Object.keys(toolOptions).length > 0;
      const isClickable =
        (status === 'executed' && resultContent !== undefined) ||
        hasToolOptions;
      const isCalling = status === 'calling';
      const errorText =
        status === 'executed' ? extractToolErrorText(resultContent) : undefined;
      const hasError = Boolean(errorText);
      const statusText =
        status === 'calling'
          ? 'calling...'
          : status === 'stopped'
            ? 'stopped'
            : 'executed';
      const displayTitleBase =
        (titleText && titleText.trim().length > 0 ? titleText : undefined) ??
        (toolOptions?.purpose
          ? `${name} | ${String(toolOptions.purpose)}`
          : `tool ${name} is ${statusText}`);
      const needsEllipsis =
        resultContent === undefined && status !== 'executed';
      const displayTitleRaw = hasError
        ? `${displayTitleBase} - ${errorText}`
        : needsEllipsis
          ? `${displayTitleBase}...`
          : displayTitleBase;
      // Show only the first line; truncate the rest with "…"
      const firstNewline = displayTitleRaw.indexOf('\n');
      const displayTitle =
        firstNewline >= 0
          ? `${displayTitleRaw.slice(0, firstNewline)}…`
          : displayTitleRaw;
      const accessibleName = displayTitle || name;
      const line = (
        <div
          className="hoverable-chat-message"
          style={{
            cursor: isClickable ? 'pointer' : 'default',
            animation: isCalling
              ? 'messages-tab-thinking-pulse 1.6s ease-in-out infinite'
              : undefined,
            textAlign: align,
            ...(hasError ? { color: '#ff4d4f' } : null),
          }}
          aria-label={
            status === 'executed'
              ? `View tool result for ${accessibleName}`
              : status === 'stopped'
                ? `Tool ${accessibleName} is stopped`
                : `Tool ${accessibleName} is calling`
          }
          tabIndex={isClickable ? 0 : -1}>
          <div
            style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: align === 'left' ? 'flex-start' : 'center',
              gap: 4,
            }}>
            <ToolOutlined
              style={{
                fontSize: 10,
                color: hasError ? 'inherit' : '#8c8c8c',
                flexShrink: 0,
              }}
            />
            <Text
              type="secondary"
              className="tool-status-line__text"
              style={{
                fontSize: '12px',
                color: 'inherit',
                fontWeight: hasError ? 600 : undefined,
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                whiteSpace: 'nowrap',
                maxWidth: '100%',
              }}>
              {displayTitle}
            </Text>
          </div>
        </div>
      );

      let baseLine: React.ReactNode = line;
      if (isClickable) {
        const contentNode = renderToolPopoverContent(
          resultContent,
          toolOptions,
          name,
          requestTokenUsageIn,
          requestTokenUsageOut,
          durationMs,
        );
        baseLine = (
          <Popover
            content={contentNode}
            trigger={['click']}
            placement="topLeft">
            {line}
          </Popover>
        );
      }

      return baseLine;
    };

    const renderShellStatusLine = (opts: {
      name: string;
      status: ToolRenderStatus;
      resultContent?: unknown;
      shellCommand?: string;
      toolOptions?: Record<string, JsonValue>;
      metadata?: { nodeId?: string; createdAt?: string; roleLabel?: string };
      titleText?: string;
      requestTokenUsageIn?: ThreadMessageDtoRequestTokenUsage | null;
      requestTokenUsageOut?: ThreadMessageDtoRequestTokenUsage | null;
      durationMs?: number;
    }) => {
      return (
        <ShellToolDisplay
          name={opts.name}
          status={opts.status}
          resultContent={opts.resultContent}
          shellCommand={opts.shellCommand}
          toolOptions={opts.toolOptions}
          title={opts.titleText}
          metadata={opts.metadata}
          requestTokenUsageIn={opts.requestTokenUsageIn}
          requestTokenUsageOut={opts.requestTokenUsageOut}
          durationMs={opts.durationMs}
        />
      );
    };

    const renderNonAgentNodeInfo = () => {
      if (isAgentNode) return null;

      return (
        <div style={{ padding: '16px', textAlign: 'center' }}>
          <Space direction="vertical" size="large">
            <ToolOutlined style={{ fontSize: '32px', color: '#1890ff' }} />
            <div>
              <Text strong style={{ fontSize: '16px' }}>
                {nodeTemplateKind || 'Tool'} Node
              </Text>
              <br />
              <Text type="secondary" style={{ fontSize: '14px' }}>
                This node executes tool calls and doesn't participate in
                conversations.
              </Text>
            </div>
            <div
              style={{
                backgroundColor: '#f8f9fa',
                border: '1px solid #e9ecef',
                borderRadius: '8px',
                padding: '12px',
                textAlign: 'left',
              }}>
              <Text strong style={{ fontSize: '13px', color: '#495057' }}>
                Tool Call Information:
              </Text>
              <br />
              <Text type="secondary" style={{ fontSize: '12px' }}>
                • Tool calls are executed when this node is triggered
                <br />
                • Results are passed to connected nodes
                <br />• Check the execution logs for detailed information
              </Text>
            </div>
          </Space>
        </div>
      );
    };

    const renderMessage = (message: ThreadMessageDto) => {
      const role = (message.message?.role as string) || '';
      const content = formatMessageContent(message.message?.content);
      const metadataText =
        formatMetadataLine(message.createdAt, role, message.nodeId) ||
        (role ? `from ${role}` : undefined);

      if (isToolLikeRole(role)) {
        const name = getMessageString(message.message, 'name') || 'tool';
        const title = getMessageTitle(message.message);
        const resultContent = message.message?.content;
        return renderToolStatusLine({
          name,
          status: 'executed',
          resultContent,
          titleText: title,
          requestTokenUsageOut: message.requestTokenUsage,
          durationMs: extractDurationMs(message.message),
        });
      }

      if (isBlankContent(message.message?.content)) return null;

      // Check if this is an agent instruction message
      const additional = getAdditionalKwargs(message.message);
      const isAgentInstruction = Boolean(
        additional?.__isAgentInstructionMessage ??
        additional?.isAgentInstructionMessage,
      );
      const isReportingMessage = Boolean(
        additional?.__isReportingMessage ?? additional?.isReportingMessage,
      );

      const isHuman = role === 'human';
      const avatarSeedNodeId = message.nodeId || nodeId;
      const avatarSrc =
        !isHuman && avatarSeedNodeId
          ? getAgentAvatarDataUri(avatarSeedNodeId)
          : undefined;
      const avatarColor = isHuman
        ? '#1890ff'
        : role === 'ai'
          ? '#52c41a'
          : role === 'system'
            ? '#722ed1'
            : '#d9d9d9';

      // Get agent name for tooltip
      const agentName =
        (message.nodeId && nodeDisplayNames?.[message.nodeId]) ||
        (message.nodeId ? `Node ${message.nodeId.slice(-6)}` : 'Agent');

      const avatarTooltip = isHuman ? 'You' : agentName;

      // Special rendering for agent instruction messages
      if (isAgentInstruction) {
        // For agent instruction messages, show only date (no "from ..." part)
        const dateOnlyText = message.createdAt
          ? new Date(message.createdAt).toLocaleString()
          : undefined;

        return (
          <ChatBubble
            isHuman={isHuman}
            avatarLabel={isHuman ? 'ME' : 'AI'}
            avatarColor="#722ed1"
            avatarSrc={avatarSrc}
            avatarTooltip={avatarTooltip}
            bubbleStyle={{
              backgroundColor: '#f9f0ff',
              border: '2px solid #d3adf7',
              borderRadius: '8px',
              padding: '12px 16px',
            }}
            copyContent={content}
            footer={
              dateOnlyText ? (
                <Text
                  type="secondary"
                  style={{
                    fontSize: '11px',
                    marginTop: '4px',
                    color: '#8c8c8c',
                  }}>
                  {renderFooterLineWithUsage(
                    dateOnlyText,
                    message.requestTokenUsage,
                    undefined,
                    undefined,
                    extractDurationMs(message.message),
                  )}
                </Text>
              ) : undefined
            }>
            <div>
              <div
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: '8px',
                  marginBottom: '8px',
                  paddingBottom: '8px',
                  borderBottom: '1px solid #d3adf7',
                }}>
                <span
                  style={{
                    fontSize: '12px',
                    fontWeight: 600,
                    color: '#722ed1',
                    textTransform: 'uppercase',
                    letterSpacing: '0.5px',
                  }}>
                  Providing Instructions for {agentName}
                </span>
              </div>
              <MarkdownContent
                content={content}
                style={MARKDOWN_DEFAULT_STYLE}
              />
            </div>
          </ChatBubble>
        );
      }

      if (isReportingMessage) {
        return (
          <ChatBubble
            isHuman={isHuman}
            avatarLabel={isHuman ? 'ME' : 'AI'}
            avatarColor="#1890ff"
            avatarSrc={avatarSrc}
            avatarTooltip={avatarTooltip}
            bubbleStyle={{
              backgroundColor: '#e6f7ff',
              border: '1px solid #91d5ff',
              borderRadius: '8px',
              padding: '12px 16px',
            }}
            copyContent={content}
            footer={
              metadataText ? (
                <Text
                  type="secondary"
                  style={{
                    fontSize: '11px',
                    marginTop: '4px',
                    color: '#8c8c8c',
                  }}>
                  {renderFooterLineWithUsage(
                    metadataText,
                    message.requestTokenUsage,
                    undefined,
                    undefined,
                    extractDurationMs(message.message),
                  )}
                </Text>
              ) : undefined
            }>
            <div>
              <div
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: '8px',
                  marginBottom: '8px',
                  paddingBottom: '8px',
                  borderBottom: '1px solid #91d5ff',
                }}>
                <span
                  style={{
                    fontSize: '12px',
                    fontWeight: 600,
                    color: '#1890ff',
                    textTransform: 'uppercase',
                    letterSpacing: '0.5px',
                  }}>
                  Status report
                </span>
              </div>
              <MarkdownContent
                content={content}
                style={MARKDOWN_DEFAULT_STYLE}
              />
            </div>
          </ChatBubble>
        );
      }

      return (
        <ChatBubble
          isHuman={isHuman}
          avatarLabel={isHuman ? 'ME' : 'AI'}
          avatarColor={avatarColor}
          avatarSrc={avatarSrc}
          avatarTooltip={avatarTooltip}
          bubbleStyle={undefined}
          copyContent={content}
          footer={
            metadataText ? (
              <Text
                type="secondary"
                style={{
                  fontSize: '11px',
                  marginTop: '4px',
                  color: '#8c8c8c',
                }}>
                {renderFooterLineWithUsage(
                  metadataText,
                  message.requestTokenUsage,
                  undefined,
                  undefined,
                  extractDurationMs(message.message),
                )}
              </Text>
            ) : undefined
          }>
          <MarkdownContent content={content} style={MARKDOWN_DEFAULT_STYLE} />
        </ChatBubble>
      );
    };

    const renderPendingMessage = (message: PendingMessage) => {
      const isHuman = message.role === 'human';
      const content = message.content;
      const avatarSrc =
        !isHuman && nodeId ? getAgentAvatarDataUri(nodeId) : undefined;

      const sendTimeText =
        newMessageMode === 'inject_after_tool_call'
          ? 'Will be sent after next tool execution'
          : newMessageMode === 'wait_for_completion'
            ? 'Will be sent after agent completes current task'
            : 'Pending';

      const pendingAgentName =
        (nodeId && nodeDisplayNames?.[nodeId]) ||
        (nodeId ? `Node ${nodeId.slice(-6)}` : 'Agent');
      const pendingAvatarTooltip = isHuman ? 'You' : pendingAgentName;

      return (
        <ChatBubble
          isHuman={isHuman}
          avatarLabel={isHuman ? 'ME' : 'AI'}
          avatarColor={isHuman ? '#1890ff' : '#52c41a'}
          avatarSrc={avatarSrc}
          avatarTooltip={pendingAvatarTooltip}
          containerStyle={{ opacity: 0.6 }}
          bubbleStyle={{ border: '2px dashed #d9d9d9' }}
          copyContent={content}
          footer={
            <Text
              type="secondary"
              style={{
                fontSize: '11px',
                marginTop: '4px',
                color: '#8c8c8c',
                fontStyle: 'italic',
              }}>
              {sendTimeText}
            </Text>
          }>
          <MarkdownContent content={content} style={MARKDOWN_DEFAULT_STYLE} />
        </ChatBubble>
      );
    };

    const formatNodeLabel = (nodeIdentifier?: string): string | undefined => {
      if (!nodeIdentifier) {
        return undefined;
      }
      const mapped = nodeDisplayNames?.[nodeIdentifier];
      if (mapped && mapped.trim().length > 0) {
        return mapped;
      }
      if (nodeIdentifier.length <= 10) {
        return nodeIdentifier;
      }
      return `Node ${nodeIdentifier.slice(-6)}`;
    };

    const resolveSenderLabel = (
      roleLabel?: string,
      sourceNodeId?: string,
    ): string | undefined => {
      if (roleLabel === 'human') {
        return 'Human';
      }
      if (showNodeHeadings) {
        const label = formatNodeLabel(sourceNodeId || nodeId);
        if (label) {
          return label;
        }
      }
      return roleLabel;
    };

    const formatMetadataLine = (
      createdAt?: string,
      roleLabel?: string,
      sourceNodeId?: string,
    ): string | undefined => {
      const datePart = createdAt
        ? new Date(createdAt).toLocaleString()
        : undefined;
      const descriptorParts: string[] = [];
      const senderLabel = resolveSenderLabel(roleLabel, sourceNodeId);
      if (senderLabel) {
        descriptorParts.push(`from ${senderLabel}`);
      }
      const descriptor = descriptorParts.join(' ');
      const parts = [datePart, descriptor].filter(
        (part) => part && part.length,
      );
      if (!parts.length) {
        return undefined;
      }
      return parts.join(' | ');
    };

    // Shared item renderer for working blocks and subagent blocks.
    // Not wrapped in useCallback — only called during render, so memoisation
    // would add overhead without benefit, and listing all closure deps is impractical.
    const renderWorkingItem = (
      it: PreparedMessage,
      idx: number,
    ): React.ReactNode => {
      if (it.type === 'reasoning') {
        if (isBlankContent(it.message.message?.content)) return null;
        return (
          <div key={`work-reasoning-${it.id}-${idx}`}>
            <InlineReasoningMessage message={it.message} />
          </div>
        );
      }

      if (it.type === 'tool') {
        if (it.toolKind === 'shell') {
          return (
            <div key={`work-shell-${it.id}-${idx}`}>
              {renderShellStatusLine({
                name: it.name,
                status: it.status,
                resultContent: it.result,
                shellCommand: it.shellCommand,
                toolOptions: it.toolOptions,
                metadata: {
                  nodeId: it.nodeId,
                  createdAt: it.createdAt,
                  roleLabel: it.roleLabel ?? it.name,
                },
                titleText: it.title,
                requestTokenUsageIn: it.requestTokenUsageIn,
                requestTokenUsageOut: it.requestTokenUsageOut,
                durationMs: it.durationMs,
              })}
            </div>
          );
        }

        if (it.name && it.name.toLowerCase() === 'finish') {
          return (
            <div key={`work-finish-${it.id}-${idx}`}>
              {renderFinishTool(
                it.status,
                it.result,
                it.requestTokenUsage,
                {
                  nodeId: it.nodeId,
                  createdAt: it.createdAt,
                  roleLabel: 'ai',
                },
                it.durationMs,
              )}
            </div>
          );
        }

        return (
          <div key={`work-tool-${it.id}-${idx}`}>
            {renderToolStatusLine({
              name: it.name,
              status: it.status,
              resultContent: it.result,
              toolOptions: it.toolOptions,
              titleText: it.title,
              align: 'left',
              requestTokenUsageIn: it.requestTokenUsageIn,
              requestTokenUsageOut: it.requestTokenUsageOut,
              durationMs: it.durationMs,
            })}
          </div>
        );
      }

      if (it.type === 'system') {
        const sysContent = formatMessageContent(it.message.message?.content);
        return (
          <div
            key={`work-system-${it.id}-${idx}`}
            style={{ fontSize: '12px', color: '#afafaf' }}>
            <MarkdownContent
              content={sysContent}
              allowHorizontalScroll={true}
            />
          </div>
        );
      }

      if (it.type === 'chat') {
        const content = formatMessageContent(it.message.message?.content);
        if (isBlankContent(it.message.message?.content)) return null;
        return (
          <div
            key={`work-chat-${it.id}-${idx}`}
            style={{
              padding: '6px 10px',
              backgroundColor: '#ffffff',
              borderRadius: 6,
              border: '1px solid #f0f0f0',
            }}>
            <MarkdownContent content={content} style={MARKDOWN_COMPACT_STYLE} />
          </div>
        );
      }

      if (it.type === 'subagent') {
        const subPopover =
          it.status !== 'calling'
            ? buildToolBlockPopover(
                it.rawToolResult,
                it.rawToolArgs,
                'subagents_run_task',
                it.requestTokenUsageIn,
                it.requestTokenUsageOut,
              )
            : undefined;
        return (
          <div
            key={`work-subagent-${it.id}-${idx}`}
            style={{
              backgroundColor: '#ffffff',
              border: '1px solid #e5e7eb',
              borderRadius: 8,
              padding: '10px 12px',
            }}>
            <SubagentBlock
              purpose={it.purpose}
              taskDescription={it.taskDescription}
              model={it.model}
              status={it.status}
              innerMessages={it.innerMessages}
              statistics={it.statistics}
              resultText={it.resultText}
              errorText={it.errorText}
              popoverContent={subPopover}
              requestTokenUsageIn={it.requestTokenUsageIn}
              requestTokenUsageOut={it.requestTokenUsageOut}
              renderItem={renderWorkingItem}
            />
          </div>
        );
      }

      if (it.type === 'communication') {
        const commTargetName =
          it.targetAgentName ||
          (it.targetNodeId && nodeDisplayNames?.[it.targetNodeId]) ||
          (it.targetNodeId ? `Node ${it.targetNodeId.slice(-6)}` : undefined);
        const innerNodeId =
          it.innerMessages.find((im) => im.nodeId)?.nodeId ?? undefined;
        const targetAvatar = innerNodeId
          ? getAgentAvatarDataUri(innerNodeId)
          : undefined;
        const commPopover =
          it.status !== 'calling'
            ? buildToolBlockPopover(
                it.rawToolResult,
                it.rawToolArgs,
                'communication_exec',
                it.requestTokenUsageIn,
                it.requestTokenUsageOut,
              )
            : undefined;
        return (
          <div
            key={`work-comm-${it.id}-${idx}`}
            style={{
              backgroundColor: '#ffffff',
              border: '1px solid #e5e7eb',
              borderRadius: 8,
              padding: '10px 12px',
            }}>
            <CommunicationBlock
              targetAgentName={commTargetName}
              targetAvatarSrc={targetAvatar}
              parentMessage={it.parentMessage}
              instructionMessage={it.instructionMessage}
              status={it.status}
              innerMessages={it.innerMessages}
              statistics={it.statistics}
              resultText={it.resultText}
              errorText={it.errorText}
              model={it.model}
              popoverContent={commPopover}
              requestTokenUsageIn={it.requestTokenUsageIn}
              requestTokenUsageOut={it.requestTokenUsageOut}
              renderItem={renderWorkingItem}
            />
          </div>
        );
      }

      return null;
    };

    const renderPreparedMessages = () => {
      const rows: React.ReactNode[] = [];
      let i = 0;

      const pushRow = (
        key: React.Key,
        content: React.ReactNode,
        extraStyle?: React.CSSProperties,
      ) => {
        rows.push(
          <div key={key} style={{ ...messageBlockStyle, ...extraStyle }}>
            {content}
          </div>,
        );
      };

      // isWorkGroupItem is now defined at component level for reuse

      const getAvatarInitials = (label?: string): string => {
        if (!label) return 'AI';
        const trimmed = label.trim();
        if (!trimmed) return 'AI';
        const words = trimmed.split(/\s+/).filter(Boolean);
        if (words.length === 1) {
          return words[0].slice(0, 2).toUpperCase();
        }
        return words
          .slice(0, 2)
          .map((w) => w[0])
          .join('')
          .toUpperCase();
      };

      const renderWorkingBlock = (items: PreparedMessage[]) => {
        const avatarSeedNodeId =
          items.find((it) => it.nodeId)?.nodeId ?? nodeId ?? undefined;
        const avatarLabel = getAvatarInitials(
          formatNodeLabel(avatarSeedNodeId) ?? undefined,
        );
        const avatarSrc = avatarSeedNodeId
          ? getAgentAvatarDataUri(avatarSeedNodeId)
          : undefined;

        const workingAgentName =
          (avatarSeedNodeId && nodeDisplayNames?.[avatarSeedNodeId]) ||
          (avatarSeedNodeId ? `Node ${avatarSeedNodeId.slice(-6)}` : 'Agent');

        const bubbleStyle: React.CSSProperties = {
          backgroundColor: '#ffffff',
          border: '1px solid #e5e7eb',
          borderRadius: 8,
          padding: '10px 12px',
        };

        return (
          <ChatBubble
            isHuman={false}
            avatarLabel={avatarLabel}
            avatarColor="#8c8c8c"
            avatarSrc={avatarSrc}
            avatarTooltip={workingAgentName}
            containerStyle={{ marginBottom: '8px', width: '100%' }}
            bubbleStyle={bubbleStyle}>
            <div
              style={{
                display: 'flex',
                flexDirection: 'column',
                gap: 5,
                width: '100%',
              }}>
              <Text
                type="secondary"
                style={{
                  fontSize: 12,
                  fontWeight: 600,
                  color: '#8c8c8c',
                  textAlign: 'left',
                }}>
                Working...
              </Text>

              <div style={{ display: 'flex', flexDirection: 'column', gap: 5 }}>
                {items.map((it, idx) => renderWorkingItem(it, idx))}
              </div>
            </div>
          </ChatBubble>
        );
      };

      while (i < preparedMessagesResult.length) {
        const item = preparedMessagesResult[i];

        if (item.type === 'system') {
          pushRow(item.id, renderSystemMessage(item.message));
          i++;
          continue;
        }

        if (item.type === 'reasoning') {
          const group: PreparedMessage[] = [item];
          let j = i + 1;
          while (
            j < preparedMessagesResult.length &&
            isWorkGroupItem(preparedMessagesResult[j])
          ) {
            group.push(preparedMessagesResult[j]);
            j++;
          }
          pushRow(`working-${item.id}`, renderWorkingBlock(group));
          i = j;
          continue;
        }

        if (item.type === 'chat') {
          // Chat content that accompanies tool calls should start/join a working group
          if (item.isToolCallContent && isWorkGroupItem(item)) {
            const group: PreparedMessage[] = [item];
            let j = i + 1;
            while (
              j < preparedMessagesResult.length &&
              isWorkGroupItem(preparedMessagesResult[j])
            ) {
              group.push(preparedMessagesResult[j]);
              j++;
            }
            // If the only collected item is the chat text itself (no actual
            // work items followed), render it as a normal message instead of
            // wrapping it in a "Working..." block.  This happens when the AI
            // text accompanies only a finish tool call (which is excluded from
            // the working group).
            if (group.length === 1) {
              pushRow(item.id, renderMessage(item.message));
              i++;
              continue;
            }
            pushRow(`working-${item.id}`, renderWorkingBlock(group));
            i = j;
            continue;
          }
          pushRow(item.id, renderMessage(item.message));
          i++;
          continue;
        }

        if (item.type === 'subagent') {
          const avatarSeedNodeId = item.nodeId ?? nodeId ?? undefined;
          const subAvatarLabel = getAvatarInitials(
            formatNodeLabel(avatarSeedNodeId) ?? undefined,
          );
          const subAvatarSrc = avatarSeedNodeId
            ? getAgentAvatarDataUri(avatarSeedNodeId)
            : undefined;
          const subAgentName =
            (avatarSeedNodeId && nodeDisplayNames?.[avatarSeedNodeId]) ||
            (avatarSeedNodeId ? `Node ${avatarSeedNodeId.slice(-6)}` : 'Agent');

          const subBubbleStyle: React.CSSProperties = {
            backgroundColor: '#ffffff',
            border: '1px solid #e5e7eb',
            borderRadius: 8,
            padding: '10px 12px',
            width: '100%',
          };

          const topSubPopover =
            item.status !== 'calling'
              ? buildToolBlockPopover(
                  item.rawToolResult,
                  item.rawToolArgs,
                  'subagents_run_task',
                  item.requestTokenUsageIn,
                  item.requestTokenUsageOut,
                )
              : undefined;

          pushRow(
            item.id,
            <ChatBubble
              isHuman={false}
              avatarLabel={subAvatarLabel}
              avatarColor="#722ed1"
              avatarSrc={subAvatarSrc}
              avatarTooltip={subAgentName}
              containerStyle={{ width: '100%' }}
              bubbleStyle={subBubbleStyle}>
              <SubagentBlock
                purpose={item.purpose}
                taskDescription={item.taskDescription}
                model={item.model}
                status={item.status}
                innerMessages={item.innerMessages}
                statistics={item.statistics}
                resultText={item.resultText}
                errorText={item.errorText}
                popoverContent={topSubPopover}
                requestTokenUsageIn={item.requestTokenUsageIn}
                requestTokenUsageOut={item.requestTokenUsageOut}
                renderItem={renderWorkingItem}
              />
            </ChatBubble>,
          );
          i++;
          continue;
        }

        if (item.type === 'communication') {
          const commAvatarSeedNodeId = item.nodeId ?? nodeId ?? undefined;
          const commAvatarLabel = getAvatarInitials(
            formatNodeLabel(commAvatarSeedNodeId) ?? undefined,
          );
          const commAvatarSrc = commAvatarSeedNodeId
            ? getAgentAvatarDataUri(commAvatarSeedNodeId)
            : undefined;
          const commAgentName =
            (commAvatarSeedNodeId &&
              nodeDisplayNames?.[commAvatarSeedNodeId]) ||
            (commAvatarSeedNodeId
              ? `Node ${commAvatarSeedNodeId.slice(-6)}`
              : 'Agent');
          const commTargetName =
            item.targetAgentName ||
            (item.targetNodeId && nodeDisplayNames?.[item.targetNodeId]) ||
            (item.targetNodeId
              ? `Node ${item.targetNodeId.slice(-6)}`
              : undefined);
          const targetInnerNodeId =
            item.innerMessages.find((im) => im.nodeId)?.nodeId ?? undefined;
          const commTargetAvatarSrc = targetInnerNodeId
            ? getAgentAvatarDataUri(targetInnerNodeId)
            : undefined;

          const commBubbleStyle: React.CSSProperties = {
            backgroundColor: '#ffffff',
            border: '1px solid #e5e7eb',
            borderRadius: 8,
            padding: '10px 12px',
            width: '100%',
          };

          const topCommPopover =
            item.status !== 'calling'
              ? buildToolBlockPopover(
                  item.rawToolResult,
                  item.rawToolArgs,
                  'communication_exec',
                  item.requestTokenUsageIn,
                  item.requestTokenUsageOut,
                )
              : undefined;

          pushRow(
            item.id,
            <ChatBubble
              isHuman={false}
              avatarLabel={commAvatarLabel}
              avatarColor="#722ed1"
              avatarSrc={commAvatarSrc}
              avatarTooltip={commAgentName}
              containerStyle={{ width: '100%' }}
              bubbleStyle={commBubbleStyle}>
              <CommunicationBlock
                targetAgentName={commTargetName}
                targetAvatarSrc={commTargetAvatarSrc}
                parentMessage={item.parentMessage}
                instructionMessage={item.instructionMessage}
                status={item.status}
                innerMessages={item.innerMessages}
                statistics={item.statistics}
                resultText={item.resultText}
                errorText={item.errorText}
                model={item.model}
                popoverContent={topCommPopover}
                requestTokenUsageIn={item.requestTokenUsageIn}
                requestTokenUsageOut={item.requestTokenUsageOut}
                renderItem={renderWorkingItem}
              />
            </ChatBubble>,
          );
          i++;
          continue;
        }

        if (item.type === 'tool') {
          if (isWorkGroupItem(item)) {
            const group: PreparedMessage[] = [item];
            let j = i + 1;
            while (
              j < preparedMessagesResult.length &&
              isWorkGroupItem(preparedMessagesResult[j])
            ) {
              group.push(preparedMessagesResult[j]);
              j++;
            }
            pushRow(`working-${item.id}`, renderWorkingBlock(group));
            i = j;
            continue;
          }
          if (item.name && item.name.toLowerCase() === 'finish') {
            pushRow(
              item.id || `finish-${i}`,
              renderFinishTool(
                item.status,
                item.result,
                item.requestTokenUsage,
                {
                  nodeId: item.nodeId,
                  createdAt: item.createdAt,
                  roleLabel: 'ai',
                },
                item.durationMs,
              ),
            );
            i++;
            continue;
          }

          if (item.toolKind === 'shell') {
            pushRow(
              item.id || `shell-${i}`,
              renderShellStatusLine({
                name: item.name,
                status: item.status,
                resultContent: item.result,
                shellCommand: item.shellCommand,
                toolOptions: item.toolOptions,
                metadata: {
                  nodeId: item.nodeId,
                  createdAt: item.createdAt,
                  roleLabel: item.roleLabel ?? item.name,
                },
                titleText: item.title,
                requestTokenUsageIn: item.requestTokenUsageIn,
                requestTokenUsageOut: item.requestTokenUsageOut,
                durationMs: item.durationMs,
              }),
            );
            i++;
            continue;
          }

          pushRow(
            item.id || `generic-tool-${i}`,
            renderToolStatusLine({
              name: item.name,
              status: item.status,
              resultContent: item.result,
              toolOptions: item.toolOptions,
              titleText: item.title,
              requestTokenUsageIn: item.requestTokenUsageIn,
              requestTokenUsageOut: item.requestTokenUsageOut,
              durationMs: item.durationMs,
            }),
          );
          i++;
          continue;
        }

        i++;
      }

      return rows;
    };

    if (!selectedThreadId) {
      return renderFullHeightState(
        <Text type="secondary">
          Select a thread from the header to view messages.
        </Text>,
      );
    }

    if (!isAgentNode) {
      return (
        <div style={fullHeightColumnStyle}>
          <div
            style={{
              ...scrollContainerStyle,
              overflowX: 'auto',
            }}>
            {renderNonAgentNodeInfo()}
          </div>
        </div>
      );
    }

    if (messagesLoading) {
      return renderFullHeightState(
        <Space direction="vertical" align="center" size="small">
          <Spin />
          <Text type="secondary">Loading messages...</Text>
        </Space>,
      );
    }

    if (messages.length === 0) {
      return renderFullHeightState(
        <Text type="secondary">No messages found for this thread.</Text>,
      );
    }

    return (
      <div style={fullHeightColumnStyle}>
        <div
          ref={scrollContainerRef}
          onScroll={handleScroll}
          style={scrollContainerStyle}>
          {loadingMore && (
            <div
              style={{
                padding: '8px 12px',
                textAlign: 'center',
                fontSize: '12px',
                color: '#8c8c8c',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                gap: '8px',
              }}>
              <Spin size="small" />
              <Text
                type="secondary"
                style={{ fontSize: '12px', color: '#8c8c8c' }}>
                Loading more messages...
              </Text>
            </div>
          )}

          {renderPreparedMessages()}
          {isThinkingVisible && !messagesLoading && (
            <div
              style={{
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                gap: 8,
                padding: '4px 0',
                animation:
                  'messages-tab-thinking-pulse 1.6s ease-in-out infinite',
              }}>
              {lastAgentAvatarSrc && (
                <img
                  src={lastAgentAvatarSrc}
                  alt=""
                  style={{
                    width: 20,
                    height: 20,
                    borderRadius: '50%',
                    flexShrink: 0,
                    display: 'block',
                  }}
                />
              )}
              <div
                style={{
                  fontSize: '12px',
                  color: '#8c8c8c',
                  lineHeight: '1.5',
                }}>
                {lastAgentName} is thinking...
              </div>
            </div>
          )}
          {pendingMessages && pendingMessages.length > 0 && (
            <div
              style={{
                borderTop: '1px solid #ebebeb',
                paddingTop: '10px',
                marginTop: '8px',
              }}>
              {pendingMessages.map((msg, idx) => (
                <div
                  key={`pending-${msg.content}-${idx}`}
                  style={messageBlockStyle}>
                  {renderPendingMessage(msg)}
                </div>
              ))}
            </div>
          )}
        </div>
      </div>
    );
  },
  (prevProps, nextProps) => {
    const messagesEqual =
      prevProps.messages === nextProps.messages ||
      (prevProps.messages.length === nextProps.messages.length &&
        prevProps.messages.every(
          (msg, idx) =>
            msg.id === nextProps.messages[idx]?.id &&
            msg.message === nextProps.messages[idx]?.message,
        ));

    const pendingMessagesEqual =
      prevProps.pendingMessages === nextProps.pendingMessages ||
      (prevProps.pendingMessages?.length ===
        nextProps.pendingMessages?.length &&
        (prevProps.pendingMessages?.every(
          (msg, idx) =>
            msg.content === nextProps.pendingMessages?.[idx]?.content &&
            msg.role === nextProps.pendingMessages?.[idx]?.role,
        ) ??
          false));

    return (
      messagesEqual &&
      prevProps.messagesLoading === nextProps.messagesLoading &&
      prevProps.selectedThreadId === nextProps.selectedThreadId &&
      prevProps.nodeId === nextProps.nodeId &&
      prevProps.nodeDisplayNames === nextProps.nodeDisplayNames &&
      prevProps.showNodeHeadings === nextProps.showNodeHeadings &&
      prevProps.isAgentNode === nextProps.isAgentNode &&
      prevProps.nodeTemplateKind === nextProps.nodeTemplateKind &&
      prevProps.hasMoreMessages === nextProps.hasMoreMessages &&
      prevProps.loadingMore === nextProps.loadingMore &&
      prevProps.isNodeRunning === nextProps.isNodeRunning &&
      prevProps.isThreadStopped === nextProps.isThreadStopped &&
      prevProps.currentThreadLastRunId === nextProps.currentThreadLastRunId &&
      pendingMessagesEqual &&
      prevProps.newMessageMode === nextProps.newMessageMode &&
      prevProps.onLoadMoreMessages === nextProps.onLoadMoreMessages
    );
  },
);

ThreadMessagesView.displayName = 'ThreadMessagesView';

export default ThreadMessagesView;
