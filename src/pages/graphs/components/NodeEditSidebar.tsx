import {
  CheckOutlined,
  CloseOutlined,
  EditOutlined,
  ExclamationCircleOutlined,
  FileTextOutlined,
  InfoCircleOutlined,
  PlayCircleOutlined,
  ToolOutlined,
} from '@ant-design/icons';
import $RefParser from '@apidevtools/json-schema-ref-parser';
import JsonView from '@uiw/react-json-view';
import { lightTheme } from '@uiw/react-json-view/light';
import {
  Avatar,
  Button,
  Input,
  Layout,
  message,
  Popover,
  Space,
  Tag,
  Tooltip,
  Typography,
} from 'antd';
import { createTwoFilesPatch } from 'diff';
import { isEqual } from 'lodash';
import React, {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'react';

import { graphsApi, litellmApi } from '../../../api';
import {
  GraphDtoStatusEnum,
  GraphNodeWithStatusDto,
  LiteLlmModelDto,
  TemplateDto,
} from '../../../autogenerated';
import { getAgentAvatarDataUri } from '../../../utils/agentAvatars';
import { extractApiErrorMessage } from '../../../utils/errors';
import type { GraphNode, SchemaProperty } from '../types';
import {
  flattenAllOfInSchema,
  getDefaultEmptyValue,
  getNodeData,
  getSchemaTypeName,
  isTrulyEmptyValue,
  processValueByType,
} from '../utils/schemaUtils';
import { NodeAiSuggestionModal } from './NodeAiSuggestionModal';
import { NodeExpandedTextareaModal } from './NodeExpandedTextareaModal';
import { NodeInstructionsModal } from './NodeInstructionsModal';
import { NodeToolsModal } from './NodeToolsModal';
import { TemplateConfigForm } from './TemplateConfigForm';

const { Sider } = Layout;
const { Title, Text } = Typography;

interface NodeEditSidebarProps {
  node: GraphNode | null;
  visible: boolean;
  onClose: () => void;
  /**
   * Called whenever the user makes a real change to the node form.
   * GraphPage should use this to update draftGraph immediately.
   */
  onNodeDraftChange: (
    nodeId: string,
    updates: { name?: string; config?: Record<string, unknown> },
  ) => void;
  templates: TemplateDto[];
  graphStatus?: GraphDtoStatusEnum;
  /**
   * Global graph-level unsaved changes flag, computed in GraphPage.
   * NodeEditSidebar should NOT modify this.
   */
  hasGlobalUnsavedChanges?: boolean;
  onTriggerClick?: (nodeId: string) => void;
  compiledNode?: GraphNodeWithStatusDto;
  compiledNodesLoading?: boolean;
  graphId?: string;
  /**
   * Snapshot version of the node config from draftGraph.
   * Used to reset the local config form baseline when the parent saves/updates draftGraph externally.
   */
  draftNodeConfigVersion?: number;
  /**
   * True when the currently opened node in the draft differs from the server baseline.
   * This should be computed in GraphPage (single source of truth).
   */
  hasNodeUnsavedChangesFromServer?: boolean;
  /** Whether the GitHub App integration is enabled (for conditional form fields). */
  githubAppEnabled?: boolean;
}

export type AiSuggestionState = {
  fieldKey: string;
  fieldLabel: string;
  initialInstructions: string;
  currentInstructions: string;
  suggestedInstructions?: string;
  lastSuggestedInstructions?: string;
  manualSuggestedOverride?: string;
  isEditingSuggestion?: boolean;
  editSuggestionDraft?: string;
  userRequest: string;
  threadId?: string;
  model?: string;
  loading: boolean;
};

const STATUS_TAG_COLOR_MAP: Record<string, string> = {
  running: 'green',
  idle: 'blue',
  starting: 'geekblue',
  stopped: 'red',
};

export const NodeEditSidebar = React.memo(
  ({
    node,
    visible,
    onClose,
    onNodeDraftChange,
    templates,
    graphStatus,
    hasGlobalUnsavedChanges = false,
    onTriggerClick,
    compiledNode,
    compiledNodesLoading,
    graphId,
    draftNodeConfigVersion,
    hasNodeUnsavedChangesFromServer,
    githubAppEnabled = false,
  }: NodeEditSidebarProps) => {
    const isHydratingRef = useRef(false);
    const nodeRef = useRef<GraphNode | null>(null);
    const [nodeName, setNodeName] = useState('');
    const [isEditingName, setIsEditingName] = useState(false);
    const [editingName, setEditingName] = useState('');
    const [templateSchema, setTemplateSchema] = useState<Record<
      string,
      unknown
    > | null>(null);
    const [configFormData, setConfigFormData] = useState<
      Record<string, unknown>
    >({});
    const [expandedTextarea, setExpandedTextarea] = useState<{
      fieldKey: string;
      value: string;
    } | null>(null);
    const [initialConfigFormData, setInitialConfigFormData] = useState<
      Record<string, unknown>
    >({});
    const [hasLocalUnsavedChanges, setHasLocalUnsavedChanges] = useState(false);
    const [liteLlmModels, setLiteLlmModels] = useState<LiteLlmModelDto[]>([]);
    const [litellmModelsLoading, setLitellmModelsLoading] = useState(false);
    const [aiSuggestionState, setAiSuggestionState] =
      useState<AiSuggestionState | null>(null);

    const computeHasLocalUnsavedChanges = useCallback(
      (nextData?: Record<string, unknown>) => {
        const currentValues = nextData ?? configFormData;
        const keys = new Set([
          ...Object.keys(initialConfigFormData),
          ...Object.keys(currentValues),
        ]);

        const formChanged = Array.from(keys).some((key) => {
          return !isEqual(currentValues[key], initialConfigFormData[key]);
        });

        const expandedChanged = expandedTextarea
          ? !isEqual(
              expandedTextarea.value,
              initialConfigFormData[expandedTextarea.fieldKey],
            )
          : false;

        return formChanged || expandedChanged;
      },
      [configFormData, expandedTextarea, initialConfigFormData],
    );

    // For AI suggestion modal, we need to warn if there are unsaved changes that AI won't see
    const nodeDirtyWarning = useMemo(() => {
      return hasLocalUnsavedChanges || Boolean(hasNodeUnsavedChangesFromServer);
    }, [hasLocalUnsavedChanges, hasNodeUnsavedChangesFromServer]);

    // Track the previous node ID to detect node switches
    const prevNodeIdRef = useRef<string | undefined>(undefined);

    const selectedNodeId = node?.id;
    const selectedNodeTemplateId = getNodeData(node)?.template;

    useEffect(() => {
      nodeRef.current = node;
    }, [node, selectedNodeId]);

    // Reset local unsaved changes when the parent signals that the graph was saved
    useEffect(() => {
      if (!hasGlobalUnsavedChanges && !isHydratingRef.current) {
        setInitialConfigFormData(configFormData);
        setHasLocalUnsavedChanges(false);
      }
    }, [configFormData, hasGlobalUnsavedChanges]);

    // Update baseline when the draftNodeConfigVersion changes (after parent save)
    useEffect(() => {
      if (draftNodeConfigVersion !== undefined && !isHydratingRef.current) {
        setInitialConfigFormData(configFormData);
        setHasLocalUnsavedChanges(false);
      }
    }, [configFormData, draftNodeConfigVersion]);

    useEffect(() => {
      if (expandedTextarea) {
        const hasChanges = computeHasLocalUnsavedChanges();
        if (hasChanges) {
          setHasLocalUnsavedChanges(true);
        }
      }
    }, [
      computeHasLocalUnsavedChanges,
      expandedTextarea,
      expandedTextarea?.value,
    ]);

    const schemaProperties = useMemo(() => {
      const propsUnknown = (templateSchema as { properties?: unknown } | null)
        ?.properties;
      if (!propsUnknown || typeof propsUnknown !== 'object') {
        return {} as Record<string, SchemaProperty>;
      }
      return propsUnknown as Record<string, SchemaProperty>;
    }, [templateSchema]);

    const schemaPropertyKeys = useMemo(
      () => Object.keys(schemaProperties),
      [schemaProperties],
    );

    const hasLiteLlmSelectField = useMemo(
      () =>
        Object.values(schemaProperties).some(
          (field) => field['x-ui:litellm-models-list-select'] === true,
        ),
      [schemaProperties],
    );
    const liteLlmModelOptions = useMemo(
      () =>
        liteLlmModels.map((model) => ({
          label: model.ownedBy ? `${model.id} (${model.ownedBy})` : model.id,
          value: model.id,
        })),
      [liteLlmModels],
    );

    const nodeData = getNodeData(node);
    const nodeTemplate = templates.find((t) => t.id === nodeData?.template);
    const templateKind = nodeTemplate?.kind ?? nodeData?.templateKind;
    const templateKindLower = (templateKind || '').toLowerCase();
    const isAgentNode = templateKindLower === 'simpleagent';
    const isGraphRunning = graphStatus === GraphDtoStatusEnum.Running;
    const showNodeStatus = ['runtime', 'simpleagent', 'trigger'].includes(
      templateKindLower,
    );
    const [instructionsVisible, setInstructionsVisible] = useState(false);
    const [toolsVisible, setToolsVisible] = useState(false);
    const agentInstructionsText = useMemo(() => {
      const instructions = (
        compiledNode?.additionalNodeMetadata as unknown as {
          instructions?: unknown;
        }
      )?.instructions;
      if (instructions === undefined || instructions === null) {
        return '';
      }
      if (typeof instructions === 'string') {
        return instructions;
      }
      if (Array.isArray(instructions)) {
        return instructions.map((item) => String(item)).join('\n\n');
      }
      try {
        return JSON.stringify(instructions, null, 2);
      } catch {
        return String(instructions);
      }
    }, [compiledNode?.additionalNodeMetadata]);

    const connectedTools = useMemo(() => {
      return (
        (
          compiledNode?.additionalNodeMetadata as unknown as {
            connectedTools?: {
              name: string;
              description: string;
              schema: Record<string, unknown>;
            }[];
          }
        )?.connectedTools || []
      );
    }, [compiledNode?.additionalNodeMetadata]);
    const instructionsAvailable = Boolean(agentInstructionsText);
    const instructionsButtonDisabled =
      !isGraphRunning || compiledNodesLoading || !instructionsAvailable;
    const instructionsTooltip = !isGraphRunning
      ? 'Start the graph to view live instructions'
      : compiledNodesLoading
        ? 'Loading instructions...'
        : instructionsAvailable
          ? 'View current agent instructions'
          : 'Instructions are not available for this node yet';

    const toolsAvailable = connectedTools.length > 0;
    const toolsButtonDisabled =
      !isGraphRunning || compiledNodesLoading || !toolsAvailable;
    const toolsTooltip = !isGraphRunning
      ? 'Start the graph to view connected tools'
      : compiledNodesLoading
        ? 'Loading tools...'
        : toolsAvailable
          ? 'View connected agent tools'
          : 'No tools are connected to this node';

    const expandedTextareaField = useMemo(() => {
      if (!expandedTextarea) return undefined;
      const prop = schemaProperties[expandedTextarea.fieldKey];
      if (!prop) return undefined;
      const label =
        (typeof prop['x-ui:label'] === 'string'
          ? prop['x-ui:label']
          : undefined) ??
        prop.title ??
        expandedTextarea.fieldKey;
      return { prop, label };
    }, [expandedTextarea, schemaProperties]);

    const formatInstructionsValue = useCallback((value: unknown) => {
      if (value === undefined || value === null) {
        return '';
      }
      if (typeof value === 'string') {
        return value;
      }
      if (Array.isArray(value)) {
        return value.map((item) => String(item)).join('\n\n');
      }
      try {
        return JSON.stringify(value, null, 2);
      } catch {
        return String(value);
      }
    }, []);

    const aiInitialInstructions = aiSuggestionState?.initialInstructions ?? '';
    const aiLastSuggestedInstructions =
      aiSuggestionState?.lastSuggestedInstructions;
    const aiManualSuggestedOverride =
      aiSuggestionState?.manualSuggestedOverride;

    const suggestionDiffMarkdown = useMemo(() => {
      if (!aiLastSuggestedInstructions && !aiManualSuggestedOverride) {
        return null;
      }

      const suggested =
        aiManualSuggestedOverride ?? aiLastSuggestedInstructions ?? '';
      const diffString = createTwoFilesPatch(
        'AI Suggestion',
        'AI Suggestion',
        aiInitialInstructions,
        suggested,
        '',
        '',
        { context: Number.MAX_SAFE_INTEGER },
      );

      const trimmed = diffString.trimEnd();
      return `\`\`\`diff\n${trimmed}\n\`\`\``;
    }, [
      aiInitialInstructions,
      aiLastSuggestedInstructions,
      aiManualSuggestedOverride,
    ]);

    const openAiSuggestionModal = useCallback(
      (fieldKey: string, fieldLabel: string, initialValue?: unknown) => {
        if (!isGraphRunning) {
          message.warning('Start the graph to use AI suggestions');
          return;
        }

        const valueToUse: unknown =
          initialValue !== undefined
            ? initialValue
            : (configFormData[fieldKey] ?? '');
        const formattedValue = formatInstructionsValue(valueToUse);
        setAiSuggestionState({
          fieldKey,
          fieldLabel,
          initialInstructions: formattedValue,
          currentInstructions: formattedValue,
          suggestedInstructions: undefined,
          lastSuggestedInstructions: undefined,
          manualSuggestedOverride: undefined,
          isEditingSuggestion: false,
          editSuggestionDraft: undefined,
          userRequest: '',
          threadId: undefined,
          model: undefined,
          loading: false,
        });
      },
      [configFormData, formatInstructionsValue, isGraphRunning],
    );

    const closeAiSuggestionModal = useCallback(() => {
      setAiSuggestionState(null);
    }, []);

    const rawStatus = compiledNode?.status;

    const statusLabel = !isGraphRunning
      ? 'Not running'
      : compiledNodesLoading
        ? 'Loading...'
        : rawStatus
          ? `${rawStatus.charAt(0).toUpperCase()}${rawStatus.slice(1)}`
          : 'Unknown';

    const statusTagColor = !isGraphRunning
      ? 'default'
      : compiledNodesLoading
        ? 'geekblue'
        : STATUS_TAG_COLOR_MAP[rawStatus ?? ''] || 'default';

    const normalizeJsonViewValue = (value: unknown): object | undefined => {
      if (value === undefined) {
        return undefined;
      }
      if (value !== null && typeof value === 'object') {
        return value as object;
      }
      return { value } as Record<string, unknown>;
    };

    const metadataJsonValue = normalizeJsonViewValue(compiledNode?.metadata);
    const configJsonValue = normalizeJsonViewValue(compiledNode?.config);
    const hasInfoData = Boolean(metadataJsonValue || configJsonValue);

    const infoContent = (
      <div style={{ maxWidth: 360 }}>
        {compiledNodesLoading && (
          <Text
            type="secondary"
            style={{
              display: 'block',
              marginBottom: hasInfoData ? 8 : 0,
            }}>
            Loading latest node information...
          </Text>
        )}
        {metadataJsonValue && (
          <div style={{ marginBottom: configJsonValue ? 16 : 0 }}>
            <Text strong style={{ display: 'block', marginBottom: 8 }}>
              Metadata
            </Text>
            <div
              style={{
                maxHeight: 240,
                overflow: 'auto',
                border: '1px solid #f0f0f0',
                borderRadius: 6,
                padding: 8,
                background: '#fafafa',
              }}>
              <JsonView
                value={metadataJsonValue as object}
                style={lightTheme}
              />
            </div>
          </div>
        )}
        {configJsonValue && (
          <div>
            <Text strong style={{ display: 'block', marginBottom: 8 }}>
              Configuration
            </Text>
            <div
              style={{
                maxHeight: 240,
                overflow: 'auto',
                border: '1px solid #f0f0f0',
                borderRadius: 6,
                padding: 8,
                background: '#fafafa',
              }}>
              <JsonView value={configJsonValue as object} style={lightTheme} />
            </div>
          </div>
        )}
        {!compiledNodesLoading && !hasInfoData && (
          <Text type="secondary">No metadata or configuration available.</Text>
        )}
      </div>
    );

    useEffect(() => {
      if (!visible) {
        setAiSuggestionState(null);
      }
    }, [visible]);

    useEffect(() => {
      setAiSuggestionState(null);
    }, [node?.id]);

    const shouldLoadLiteLlmModels =
      hasLiteLlmSelectField || Boolean(aiSuggestionState);

    useEffect(() => {
      if (!shouldLoadLiteLlmModels) {
        return;
      }
      if (liteLlmModels.length > 0) {
        return;
      }

      let isActive = true;

      const fetchLiteLlmModels = async () => {
        try {
          setLitellmModelsLoading(true);
          const response = await litellmApi.listModels();
          if (!isActive) {
            return;
          }
          setLiteLlmModels(response.data ?? []);
        } catch (error) {
          if (!isActive) {
            return;
          }
          console.error('Failed to load LiteLLM models:', error);
          const errorMessage = extractApiErrorMessage(
            error,
            'Failed to load LiteLLM models',
          );
          message.error(errorMessage);
        } finally {
          if (isActive) {
            setLitellmModelsLoading(false);
          }
        }
      };

      fetchLiteLlmModels();

      return () => {
        isActive = false;
      };
    }, [liteLlmModels.length, shouldLoadLiteLlmModels]);

    // Hydrate form ONLY when switching nodes or switching templates.
    useEffect(() => {
      const nodeForInit = nodeRef.current;
      if (!nodeForInit) {
        setTemplateSchema(null);
        setConfigFormData({});
        setInitialConfigFormData({});
        setHasLocalUnsavedChanges(false);
        prevNodeIdRef.current = undefined;
        return;
      }

      const currentNodeData = getNodeData(nodeForInit);
      if (!currentNodeData) {
        setTemplateSchema(null);
        setConfigFormData({});
        setInitialConfigFormData({});
        setHasLocalUnsavedChanges(false);
        prevNodeIdRef.current = undefined;
        return;
      }

      const template = templates.find((t) => t.id === currentNodeData.template);

      isHydratingRef.current = true;

      let didCancel = false;

      const hydrateForm = async () => {
        const rawSchema = template?.schema as unknown;
        if (!rawSchema) {
          setTemplateSchema(null);
          setConfigFormData({});
          setInitialConfigFormData({});
          setHasLocalUnsavedChanges(false);
          requestAnimationFrame(() => {
            isHydratingRef.current = false;
          });
          return;
        }

        let schema: unknown = rawSchema;
        try {
          schema = await $RefParser.dereference(rawSchema, {
            mutateInputSchema: false,
          });
          // Flatten allOf structures to help RJSF understand enum fields
          if (schema && typeof schema === 'object') {
            schema = flattenAllOfInSchema(schema as Record<string, unknown>);
          }
        } catch (error) {
          console.error('Failed to dereference template schema:', error);
          schema = rawSchema;
        }

        if (didCancel) return;

        const schemaPropertiesUnknown = (schema as { properties?: unknown })
          ?.properties;
        if (
          !schemaPropertiesUnknown ||
          typeof schemaPropertiesUnknown !== 'object'
        ) {
          setTemplateSchema(null);
          setConfigFormData({});
          setInitialConfigFormData({});
          setHasLocalUnsavedChanges(false);
          requestAnimationFrame(() => {
            isHydratingRef.current = false;
          });
          return;
        }

        const schemaPropsLocal = schemaPropertiesUnknown as Record<
          string,
          SchemaProperty
        >;
        const initialValues: Record<string, unknown> = {};
        for (const [key, prop] of Object.entries(schemaPropsLocal)) {
          if (prop.const !== undefined) {
            initialValues[key] = prop.const;
            continue;
          }

          const resolvedType = getSchemaTypeName(prop);
          const fallbackEmptyValue = getDefaultEmptyValue(resolvedType);

          initialValues[key] =
            (currentNodeData.config as Record<string, unknown>)?.[key] ??
            prop.default ??
            fallbackEmptyValue;
        }

        setTemplateSchema(schema as Record<string, unknown>);
        setConfigFormData(initialValues);
        setInitialConfigFormData(initialValues);
        setHasLocalUnsavedChanges(false);

        requestAnimationFrame(() => {
          isHydratingRef.current = false;
        });
      };

      void hydrateForm();

      const label = (currentNodeData.label as string) || '';
      setNodeName(label);
      setEditingName(label);
      prevNodeIdRef.current = nodeForInit.id;

      return () => {
        didCancel = true;
      };
    }, [selectedNodeId, selectedNodeTemplateId, templates]);

    /**
     * Build the processed config from current form values.
     */
    const buildProcessedConfig = useCallback(
      (overrideFormData?: Record<string, unknown>): Record<string, unknown> => {
        const currentConfig: Record<string, unknown> =
          getNodeData(node)?.config ?? {};
        const effectiveFormData = overrideFormData ?? configFormData;

        // Preserve keys that are NOT in the current template schema (backward/forward compat).
        const schemaKeys = new Set(schemaPropertyKeys);
        const configValues: Record<string, unknown> = {};
        Object.keys(currentConfig).forEach((key) => {
          if (!schemaKeys.has(key)) {
            configValues[key] = currentConfig[key];
          }
        });

        for (const key of schemaPropertyKeys) {
          const prop = schemaProperties[key];
          if (!prop) continue;

          if (prop.const !== undefined) {
            configValues[key] = prop.const as unknown;
            continue;
          }

          const rawValue: unknown = effectiveFormData[key];
          // Only fall back to the saved config when the key is entirely absent
          // from the form data (i.e. the form doesn't manage this field).
          // When the user clears a select, RJSF emits the key as undefined â€”
          // falling back to the old value would silently discard the change.
          const effectiveValue: unknown =
            key in effectiveFormData ? rawValue : currentConfig[key];

          const typeName = getSchemaTypeName(prop);

          if (isTrulyEmptyValue(effectiveValue, typeName)) {
            configValues[key] = null;
            continue;
          }

          const processedValue = processValueByType(effectiveValue, typeName);

          if (processedValue !== undefined) {
            configValues[key] = processedValue;
          }
        }

        return configValues;
      },
      [configFormData, node, schemaProperties, schemaPropertyKeys],
    );

    /**
     * Push draft changes to the parent (GraphPage).
     */
    const pushDraftChange = useCallback(
      (overrideFormData?: Record<string, unknown>) => {
        if (!node) return;
        if (isHydratingRef.current) return;

        const configValues = buildProcessedConfig(overrideFormData);
        const currentNodeData = getNodeData(node);
        const currentConfig: Record<string, unknown> =
          currentNodeData?.config ?? {};
        const currentLabel = currentNodeData?.label;

        const labelUnchanged = nodeName === currentLabel;
        const configUnchanged = isEqual(configValues, currentConfig);

        if (labelUnchanged && configUnchanged) {
          return;
        }

        onNodeDraftChange(node.id, {
          name: nodeName,
          config: configValues,
        });
      },
      [node, nodeName, buildProcessedConfig, onNodeDraftChange],
    );

    const handleExpandedTextareaSave = useCallback(() => {
      if (expandedTextarea) {
        const nextFormData: Record<string, unknown> = {
          ...configFormData,
          [expandedTextarea.fieldKey]: expandedTextarea.value,
        };
        setConfigFormData(nextFormData);
        const hasChanges = computeHasLocalUnsavedChanges(nextFormData);
        setHasLocalUnsavedChanges(hasChanges);
        if (hasChanges) {
          pushDraftChange(nextFormData);
        }
      }
      setExpandedTextarea(null);
    }, [
      expandedTextarea,
      configFormData,
      computeHasLocalUnsavedChanges,
      pushDraftChange,
    ]);

    const handleExpandedTextareaCancel = useCallback(() => {
      setExpandedTextarea(null);
    }, []);

    const handleConfigFormChange = useCallback(
      (nextFormData: Record<string, unknown>) => {
        if (isHydratingRef.current) {
          return;
        }

        setConfigFormData(nextFormData);
        pushDraftChange(nextFormData);

        const hasChanges = computeHasLocalUnsavedChanges(nextFormData);
        setHasLocalUnsavedChanges(hasChanges);
      },
      [computeHasLocalUnsavedChanges, pushDraftChange],
    );

    const handleClose = useCallback(() => {
      if (hasLocalUnsavedChanges) {
        pushDraftChange();
      }
      onClose();
    }, [hasLocalUnsavedChanges, pushDraftChange, onClose]);

    const handleStartEditSuggested = useCallback(() => {
      setAiSuggestionState((prev) => {
        if (!prev) return prev;
        const currentDraft =
          prev.manualSuggestedOverride ??
          prev.lastSuggestedInstructions ??
          prev.currentInstructions ??
          '';
        return {
          ...prev,
          isEditingSuggestion: true,
          editSuggestionDraft: currentDraft,
        };
      });
    }, []);

    const handleCancelEditSuggested = useCallback(() => {
      setAiSuggestionState((prev) =>
        prev
          ? {
              ...prev,
              isEditingSuggestion: false,
              editSuggestionDraft: undefined,
            }
          : prev,
      );
    }, []);

    const handleApplyEditSuggested = useCallback(() => {
      setAiSuggestionState((prev) =>
        prev && prev.editSuggestionDraft !== undefined
          ? {
              ...prev,
              manualSuggestedOverride: prev.editSuggestionDraft,
              suggestedInstructions: prev.editSuggestionDraft,
              isEditingSuggestion: false,
            }
          : prev,
      );
    }, []);

    const handleNameEdit = () => {
      setIsEditingName(true);
      setEditingName(nodeName);
    };

    const handleNameSave = () => {
      if (editingName !== nodeName) {
        setNodeName(editingName);
        if (node) {
          onNodeDraftChange(node.id, {
            name: editingName,
          });
          setHasLocalUnsavedChanges(true);
        }
      }
      setIsEditingName(false);
    };

    const handleNameCancel = () => {
      setEditingName(nodeName);
      setIsEditingName(false);
    };

    const handleAiSuggestionSubmit = useCallback(async () => {
      if (!aiSuggestionState) return;

      if (!isGraphRunning) {
        message.warning('Start the graph to use AI suggestions');
        return;
      }

      const userRequest = aiSuggestionState.userRequest.trim();
      if (!userRequest) {
        message.warning('Enter a request for the AI suggestion');
        return;
      }

      if (!graphId || !node?.id) {
        message.error('Graph or node is missing for suggestions');
        return;
      }

      setAiSuggestionState((prev) =>
        prev ? { ...prev, loading: true } : prev,
      );

      try {
        const response = await graphsApi.suggestAgentInstructions(
          graphId,
          node.id,
          {
            userRequest,
            threadId: aiSuggestionState.threadId,
            model: aiSuggestionState.model,
          },
        );

        setAiSuggestionState((prev) =>
          prev
            ? {
                ...prev,
                loading: false,
                suggestedInstructions:
                  response.data?.instructions ?? prev.suggestedInstructions,
                lastSuggestedInstructions:
                  response.data?.instructions ?? prev.lastSuggestedInstructions,
                manualSuggestedOverride: undefined,
                isEditingSuggestion: false,
                editSuggestionDraft: undefined,
                threadId: response.data?.threadId ?? prev.threadId,
                userRequest: '',
              }
            : prev,
        );
      } catch (error) {
        setAiSuggestionState((prev) =>
          prev ? { ...prev, loading: false } : prev,
        );
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to fetch AI suggestion',
        );
        message.error(errorMessage);
      }
    }, [aiSuggestionState, graphId, isGraphRunning, node?.id]);

    const handleApplyAiSuggestion = useCallback(() => {
      if (
        !aiSuggestionState?.suggestedInstructions &&
        !aiSuggestionState?.manualSuggestedOverride
      )
        return;

      const suggestedInstructions =
        aiSuggestionState.manualSuggestedOverride ??
        aiSuggestionState.suggestedInstructions ??
        '';

      const nextFormData: Record<string, unknown> = {
        ...configFormData,
        [aiSuggestionState.fieldKey]: suggestedInstructions,
      };
      setConfigFormData(nextFormData);

      if (
        expandedTextarea?.fieldKey &&
        expandedTextarea.fieldKey === aiSuggestionState.fieldKey
      ) {
        setExpandedTextarea((prev) =>
          prev ? { ...prev, value: suggestedInstructions } : prev,
        );
      }

      setAiSuggestionState(null);

      const hasChanges = computeHasLocalUnsavedChanges(nextFormData);
      setHasLocalUnsavedChanges(hasChanges);
      pushDraftChange(nextFormData);
    }, [
      aiSuggestionState,
      computeHasLocalUnsavedChanges,
      configFormData,
      expandedTextarea?.fieldKey,
      pushDraftChange,
    ]);

    const isTriggerNode = templateKindLower === 'trigger';
    const canTrigger = isTriggerNode && isGraphRunning;

    const renderOptionsTabContent = useCallback(() => {
      return (
        <div
          style={{
            flex: 1,
            minHeight: 0,
            display: 'flex',
            flexDirection: 'column',
          }}>
          <div
            style={{
              flexShrink: 0,
              padding: '8px 4px 0 4px',
            }}>
            <div
              style={{
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
                gap: 8,
              }}>
              <Title level={5} style={{ margin: 0 }}>
                Configuration
              </Title>
            </div>
          </div>

          <div
            style={{
              flex: 1,
              minHeight: 0,
              overflow: 'auto',
              padding: '0 4px 8px 4px',
            }}>
            {templateSchema && schemaPropertyKeys.length > 0 ? (
              <TemplateConfigForm
                schema={templateSchema}
                formData={configFormData}
                onChange={handleConfigFormChange}
                liteLlmModels={liteLlmModels}
                litellmModelsLoading={litellmModelsLoading}
                onOpenExpandedTextarea={(fieldKey, value) =>
                  setExpandedTextarea({ fieldKey, value })
                }
                onOpenAiSuggestion={(fieldKey, fieldLabel, value) =>
                  openAiSuggestionModal(fieldKey, fieldLabel, value)
                }
                aiSuggestionEnabled={Boolean(
                  isGraphRunning && graphId && node?.id,
                )}
                githubAppEnabled={githubAppEnabled}
              />
            ) : (
              <Text type="secondary">
                No configuration options available for this template.
              </Text>
            )}
          </div>
        </div>
      );
    }, [
      configFormData,
      githubAppEnabled,
      graphId,
      handleConfigFormChange,
      isGraphRunning,
      liteLlmModels,
      litellmModelsLoading,
      node?.id,
      openAiSuggestionModal,
      schemaPropertyKeys.length,
      templateSchema,
    ]);

    if (!visible) {
      return null;
    }

    return (
      <Sider
        width={400}
        style={{
          background: '#fff',
          borderLeft: '1px solid #f0f0f0',
          height: '100%',
          display: 'flex',
          flexDirection: 'column',
        }}>
        <div
          style={{
            padding: '16px',
            height: '100%',
            display: 'flex',
            flexDirection: 'column',
            minHeight: 0,
          }}>
          <div
            style={{
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              marginBottom: 16,
              paddingBottom: 16,
              borderBottom: '1px solid #f0f0f0',
              flexShrink: 0,
            }}>
            <Title level={4} style={{ margin: 0 }}>
              Edit Node
            </Title>
            <Space>
              {isTriggerNode && (
                <Button
                  type="primary"
                  icon={<PlayCircleOutlined />}
                  disabled={!canTrigger}
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    onTriggerClick?.(node?.id || '');
                  }}
                  size="small">
                  Trigger
                </Button>
              )}
              <Button
                onClick={handleClose}
                icon={<CloseOutlined />}
                size="small"></Button>
            </Space>
          </div>

          <div style={{ flexShrink: 0, marginBottom: 16 }}>
            {isEditingName ? (
              <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                <Input
                  value={editingName}
                  onChange={(e) => setEditingName(e.target.value)}
                  onPressEnter={handleNameSave}
                  onBlur={handleNameSave}
                  autoFocus
                  style={{ flex: 1 }}
                />
                <Button
                  type="text"
                  icon={<CheckOutlined />}
                  onClick={handleNameSave}
                  size="small"
                />
                <Button
                  type="text"
                  icon={<CloseOutlined />}
                  onClick={handleNameCancel}
                  size="small"
                />
              </div>
            ) : (
              <div
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: 4,
                }}>
                {isAgentNode && node?.id && (
                  <Avatar
                    size={30}
                    src={getAgentAvatarDataUri(node.id, 64)}
                    style={{ flexShrink: 0 }}
                  />
                )}
                <Text
                  strong
                  style={{
                    flex: 1,
                    overflow: 'hidden',
                    textOverflow: 'ellipsis',
                    whiteSpace: 'nowrap',
                    display: 'block',
                  }}>
                  {nodeName}
                </Text>
                {isAgentNode && (
                  <>
                    <Tooltip title={instructionsTooltip} placement="bottom">
                      <Button
                        type="text"
                        size="small"
                        icon={<FileTextOutlined />}
                        disabled={instructionsButtonDisabled}
                        onClick={() => setInstructionsVisible(true)}
                        aria-label="View agent instructions"
                      />
                    </Tooltip>
                    <Tooltip title={toolsTooltip} placement="bottom">
                      <Button
                        type="text"
                        size="small"
                        icon={<ToolOutlined />}
                        disabled={toolsButtonDisabled}
                        onClick={() => setToolsVisible(true)}
                        aria-label="View connected tools"
                      />
                    </Tooltip>
                  </>
                )}
                <Popover
                  content={infoContent}
                  trigger="click"
                  placement="bottomRight">
                  <Button
                    type="text"
                    size="small"
                    icon={<InfoCircleOutlined />}
                    aria-label="View node metadata and configuration"
                  />
                </Popover>
                <Button
                  type="text"
                  icon={<EditOutlined />}
                  onClick={handleNameEdit}
                  size="small"
                />
              </div>
            )}

            <div
              style={{
                fontSize: '11px',
                color: '#bfbfbf',
              }}>
              {nodeData?.template} ({templateKind})
            </div>
            {showNodeStatus && (
              <div
                style={{
                  marginTop: 8,
                  display: 'flex',
                  alignItems: 'center',
                  gap: 8,
                  flexWrap: 'wrap',
                }}>
                <Space size={2} wrap align="center">
                  <Tag
                    color={statusTagColor}
                    style={{ margin: 0, fontSize: 12 }}
                    bordered={statusTagColor === 'default'}>
                    {statusLabel}
                  </Tag>
                  {compiledNode?.error && (
                    <Tooltip title={compiledNode.error} placement="top">
                      <ExclamationCircleOutlined
                        style={{ color: '#ff4d4f', fontSize: 14 }}
                      />
                    </Tooltip>
                  )}
                </Space>
              </div>
            )}
          </div>

          <div
            style={{
              flex: 1,
              minHeight: 0,
              overflow: 'hidden',
              display: 'flex',
              flexDirection: 'column',
            }}>
            {renderOptionsTabContent()}
          </div>
        </div>

        {/* Extracted modal components */}
        <NodeAiSuggestionModal
          aiSuggestionState={aiSuggestionState}
          setAiSuggestionState={setAiSuggestionState}
          nodeDirtyWarning={nodeDirtyWarning}
          suggestionDiffMarkdown={suggestionDiffMarkdown}
          liteLlmModelOptions={liteLlmModelOptions}
          litellmModelsLoading={litellmModelsLoading}
          isGraphRunning={isGraphRunning}
          graphId={graphId}
          nodeId={node?.id}
          onClose={closeAiSuggestionModal}
          onSubmit={handleAiSuggestionSubmit}
          onApply={handleApplyAiSuggestion}
          onStartEditSuggested={handleStartEditSuggested}
          onCancelEditSuggested={handleCancelEditSuggested}
          onApplyEditSuggested={handleApplyEditSuggested}
        />

        <NodeInstructionsModal
          visible={instructionsVisible}
          onClose={() => setInstructionsVisible(false)}
          instructionsText={agentInstructionsText}
        />

        <NodeToolsModal
          visible={toolsVisible}
          onClose={() => setToolsVisible(false)}
          tools={connectedTools}
        />

        <NodeExpandedTextareaModal
          expandedTextarea={expandedTextarea}
          onSave={handleExpandedTextareaSave}
          onCancel={handleExpandedTextareaCancel}
          onChange={setExpandedTextarea}
          showAiSuggestion={
            expandedTextareaField?.prop['x-ui:ai-suggestions'] === true
          }
          isGraphRunning={isGraphRunning}
          onOpenAiSuggestion={() => {
            if (expandedTextarea && expandedTextareaField) {
              openAiSuggestionModal(
                expandedTextarea.fieldKey,
                expandedTextareaField.label || expandedTextarea.fieldKey,
                expandedTextarea.value,
              );
            }
          }}
        />
      </Sider>
    );
  },
  (prevProps, nextProps) => {
    const prevNodeData = getNodeData(prevProps.node);
    const nextNodeData = getNodeData(nextProps.node);

    const prevConfig = prevNodeData?.config;
    const nextConfig = nextNodeData?.config;
    const configEqual =
      prevConfig === nextConfig || isEqual(prevConfig, nextConfig);

    return (
      prevProps.visible === nextProps.visible &&
      prevProps.node?.id === nextProps.node?.id &&
      prevNodeData?.label === nextNodeData?.label &&
      prevNodeData?.template === nextNodeData?.template &&
      configEqual &&
      prevProps.graphStatus === nextProps.graphStatus &&
      prevProps.hasGlobalUnsavedChanges === nextProps.hasGlobalUnsavedChanges &&
      prevProps.hasNodeUnsavedChangesFromServer ===
        nextProps.hasNodeUnsavedChangesFromServer &&
      prevProps.graphId === nextProps.graphId &&
      prevProps.compiledNodesLoading === nextProps.compiledNodesLoading &&
      prevProps.compiledNode?.status === nextProps.compiledNode?.status &&
      prevProps.compiledNode?.error === nextProps.compiledNode?.error &&
      prevProps.compiledNode?.additionalNodeMetadata ===
        nextProps.compiledNode?.additionalNodeMetadata &&
      prevProps.templates === nextProps.templates &&
      prevProps.onTriggerClick === nextProps.onTriggerClick &&
      prevProps.onClose === nextProps.onClose &&
      prevProps.onNodeDraftChange === nextProps.onNodeDraftChange &&
      prevProps.draftNodeConfigVersion === nextProps.draftNodeConfigVersion &&
      prevProps.githubAppEnabled === nextProps.githubAppEnabled
    );
  },
);

NodeEditSidebar.displayName = 'NodeEditSidebar';
