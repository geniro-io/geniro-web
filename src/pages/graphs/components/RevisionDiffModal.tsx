import { Modal, Typography } from 'antd';
import { createTwoFilesPatch } from 'diff';
import { useMemo } from 'react';

import type { GraphRevisionDto } from '../../../autogenerated';
import { DiffHtmlView } from '../../../components/markdown/DiffHtmlView';

/**
 * Expand multiline string values in JSON.stringify output so that each
 * embedded `\n` becomes a real newline. This lets the diff engine compare
 * individual lines within long text fields (e.g. `instructions`) instead
 * of treating the entire value as one changed line.
 *
 * The output is not valid JSON -- it is a human-readable representation
 * intended only for display in the diff viewer.
 */
function expandMultilineStrings(jsonText: string): string {
  // Match a full JSON string-value that contains at least one literal \n.
  // The regex captures:
  //   1. leading whitespace + key + ": "  (everything before the opening quote)
  //   2. the string content between quotes (may contain escaped chars)
  //   3. trailing comma (if any)
  //
  // We only expand values that sit on a single line produced by JSON.stringify
  // (indent 2), so we process line-by-line.
  return jsonText
    .split('\n')
    .flatMap((line) => {
      // Only process lines that look like `  "key": "...\\n..."` or bare `  "...\\n..."` (array element).
      // The \\n in the JSON output is a literal backslash-n (two chars) representing a newline.
      if (!line.includes('\\n')) return [line];

      // Try to match a key-value line:  <indent>"key": "value"<optional comma>
      const kvMatch = line.match(
        /^(\s*"[^"]*":\s*)"((?:[^"\\]|\\.)*)("(?:,?)\s*)$/,
      );
      // Or a bare string element in an array:  <indent>"value"<optional comma>
      const bareMatch =
        !kvMatch &&
        line.match(/^(\s*)"((?:[^"\\]|\\.)*\\n(?:[^"\\]|\\.)*)("(?:,?)\s*)$/);

      const match = kvMatch || bareMatch;
      if (!match) return [line];

      const prefix = match[1]; // indent + key + colon (or just indent for bare)
      const content = match[2];
      const suffix = match[3]; // closing quote + optional comma

      // Split the string content on literal \n sequences.
      const parts = content.split('\\n');
      if (parts.length <= 1) return [line];

      // Continuation lines are indented relative to the opening quote.
      const continuationIndent = ' '.repeat(prefix.length + 1);

      return parts.map((part, i) => {
        if (i === 0) return `${prefix}"${part}`;
        if (i === parts.length - 1)
          return `${continuationIndent}${part}${suffix}`;
        return `${continuationIndent}${part}`;
      });
    })
    .join('\n');
}

interface RevisionDiffModalProps {
  revision: GraphRevisionDto | null;
  /** Config from the previous version to diff against. When null, the previous version is unavailable. */
  previousConfig: GraphRevisionDto['newConfig'] | null;
  visible: boolean;
  onClose: () => void;
}

export const RevisionDiffModal = ({
  revision,
  previousConfig,
  visible,
  onClose,
}: RevisionDiffModalProps) => {
  const diffPatch = useMemo(() => {
    if (!revision || !previousConfig) return '';
    const prevJson = expandMultilineStrings(
      JSON.stringify(previousConfig, null, 2),
    );
    const newJson = expandMultilineStrings(
      JSON.stringify(revision.newConfig, null, 2),
    );
    if (prevJson === newJson) return '';
    return createTwoFilesPatch(
      `v${revision.baseVersion}`,
      `v${revision.toVersion}`,
      prevJson,
      newJson,
      '',
      '',
      { context: 6 },
    ).trimEnd();
  }, [revision, previousConfig]);

  return (
    <Modal
      open={visible}
      onCancel={onClose}
      footer={null}
      title={
        revision
          ? `Revision v${revision.baseVersion} â†’ v${revision.toVersion} diff`
          : 'Revision diff'
      }
      width={720}
      destroyOnClose>
      {revision ? (
        !previousConfig ? (
          <Typography.Text type="secondary">
            Previous version not available for comparison.
          </Typography.Text>
        ) : diffPatch ? (
          <div style={{ maxHeight: '60vh', overflow: 'auto' }}>
            <DiffHtmlView diff={diffPatch} />
          </div>
        ) : (
          <Typography.Text type="secondary">
            No configuration changes.
          </Typography.Text>
        )
      ) : null}
      {revision?.error && (
        <Typography.Text
          type="danger"
          style={{ display: 'block', marginTop: 12 }}>
          Error: {revision.error}
        </Typography.Text>
      )}
    </Modal>
  );
};
