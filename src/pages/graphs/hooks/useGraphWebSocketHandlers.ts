import type { Viewport } from '@xyflow/react';
import { App } from 'antd';
import type { Dispatch, MutableRefObject, SetStateAction } from 'react';

import { graphsApi } from '../../../api';
import {
  type GraphDto,
  GraphDtoStatusEnum,
  type GraphNodeWithStatusDto,
  GraphNodeWithStatusDtoStatusEnum,
  type GraphRevisionDto,
} from '../../../autogenerated';
import type { UseGraphDraftStateReturn } from '../../../hooks/useGraphDraftState';
import { useWebSocket } from '../../../hooks/useWebSocket';
import {
  type GraphDiffState,
  GraphStorageService,
} from '../../../services/GraphStorageService';
import type {
  GraphNodeUpdateNotification,
  GraphRevisionNotification,
  GraphRevisionProgressNotification,
  GraphUpdateNotification,
} from '../../../services/WebSocketTypes';
import type { GraphNode, GraphNodeData } from '../types';

// ---------------------------------------------------------------------------
// Options interface
// ---------------------------------------------------------------------------

interface GraphState {
  id: string;
  nodes: GraphNode[];
}

interface GraphSetters {
  setGraph: Dispatch<SetStateAction<GraphDto | null>>;
  setCompiledNodesMap: Dispatch<
    SetStateAction<Record<string, GraphNodeWithStatusDto>>
  >;
  setServerGraphState: Dispatch<SetStateAction<GraphDiffState>>;
}

interface RevisionActions {
  upsertRevision: (revision: GraphRevisionDto) => void;
  rebuildStateFromGraph: (graphData: GraphDto) => GraphDiffState;
  handleDraftStateChange: (newState: GraphDiffState) => void;
  fetchCompiledNodes: (options?: {
    graphStatusOverride?: GraphDtoStatusEnum | null;
  }) => Promise<void>;
}

interface Refs {
  draftStateRef: MutableRefObject<UseGraphDraftStateReturn>;
  viewportRef: MutableRefObject<Viewport>;
}

function inferNodeType(
  templateKind: string | undefined,
): GraphNodeWithStatusDto['type'] {
  const normalized = (templateKind ?? '').toLowerCase();
  if (normalized === 'tool') return 'tool';
  if (normalized === 'simpleagent') return 'simpleAgent';
  if (normalized === 'trigger') return 'trigger';
  if (normalized === 'resource') return 'resource';
  return 'runtime';
}

export interface UseGraphWebSocketHandlersOptions {
  graphState: GraphState;
  setters: GraphSetters;
  revisionActions: RevisionActions;
  refs: Refs;
}

// ---------------------------------------------------------------------------
// Hook
// ---------------------------------------------------------------------------

export const useGraphWebSocketHandlers = ({
  graphState,
  setters,
  revisionActions,
  refs,
}: UseGraphWebSocketHandlersOptions): void => {
  const { message } = App.useApp();
  const { id, nodes } = graphState;

  const { setGraph, setCompiledNodesMap, setServerGraphState } = setters;

  const {
    upsertRevision,
    rebuildStateFromGraph,
    handleDraftStateChange,
    fetchCompiledNodes,
  } = revisionActions;

  const { draftStateRef, viewportRef } = refs;

  useWebSocket({
    autoConnect: true,
    graphId: id,
    handlers: {
      'graph.update': (notification) => {
        const data = notification as GraphUpdateNotification;
        if (data.graphId !== id) return;

        const newStatus = data.data.status;

        if (
          newStatus === GraphDtoStatusEnum.Compiling ||
          newStatus === GraphDtoStatusEnum.Stopped
        ) {
          setCompiledNodesMap((prev) => {
            // Only update if not already empty to prevent unnecessary rerenders
            return Object.keys(prev).length === 0 ? prev : {};
          });
        }

        setGraph((prev) => {
          if (!prev) {
            return prev;
          }

          return {
            ...prev,
            status: newStatus,
          };
        });
      },

      'graph.node.update': (notification) => {
        const data = notification as GraphNodeUpdateNotification;
        if (data.graphId !== id) return;

        setCompiledNodesMap((prev) => {
          const existing = prev[data.nodeId];
          const nextStatus = data.data.status;
          const nextError = data.data.error ?? existing?.error ?? null;
          const nextMetadata = data.data.metadata ?? existing?.metadata;
          const nextAdditionalNodeMetadata =
            data.data.additionalNodeMetadata ??
            existing?.additionalNodeMetadata;

          if (!existing) {
            const graphNode = nodes.find(
              (n: GraphNode) => n.id === data.nodeId,
            );
            if (!graphNode) {
              return prev;
            }

            const nodeData = graphNode.data as unknown as GraphNodeData;

            return {
              ...prev,
              [data.nodeId]: {
                id: data.nodeId,
                name:
                  (nodeData.label as string) ||
                  (nodeData.template as string) ||
                  data.nodeId,
                template: (nodeData.template as string) || '',
                type: inferNodeType(
                  nodeData.templateKind as string | undefined,
                ),
                status: nextStatus,
                config: nodeData.config ?? {},
                error: nextError,
                metadata: nextMetadata,
                additionalNodeMetadata: nextAdditionalNodeMetadata,
              },
            };
          }

          return {
            ...prev,
            [data.nodeId]: {
              ...existing,
              status: nextStatus,
              error: nextError,
              metadata: nextMetadata,
              additionalNodeMetadata: nextAdditionalNodeMetadata,
            },
          };
        });
      },

      'graph.revision.create': (notification) => {
        const data = notification as GraphRevisionNotification;
        if (data.graphId !== id) return;

        upsertRevision(data.data);
      },

      'graph.revision.applying': (notification) => {
        const data = notification as GraphRevisionNotification;
        if (data.graphId !== id) return;

        const revision = data.data;
        upsertRevision(revision);

        message.open({
          key: `graph-revision-${revision.id}`,
          type: 'loading',
          content: `Applying revision ${revision.toVersion}`,
          duration: 0,
        });
      },

      'graph.revision.applied': async (notification) => {
        const data = notification as GraphRevisionNotification;
        if (data.graphId !== id) return;

        const revision = data.data;
        upsertRevision(revision);
        GraphStorageService.clearPendingRevision(id);

        // Refetch the graph to get the updated data
        try {
          const res = await graphsApi.findGraphById(id);
          const updatedGraph = res.data;

          // Check if there are local unsaved changes
          const hasLocalChanges = draftStateRef.current.hasUnsavedChanges;

          if (hasLocalChanges) {
            // User has local changes - warn them that the server was updated
            message.warning({
              key: `graph-revision-${revision.id}`,
              content: `Revision ${revision.toVersion} applied.`,
              duration: 8,
            });
            // Update the graph metadata but don't override local changes
            setGraph(updatedGraph);

            // Fetch updated node states
            void fetchCompiledNodes({
              graphStatusOverride: updatedGraph.status,
            });
          } else {
            // No local changes - safely update everything
            const refreshedState = rebuildStateFromGraph(updatedGraph);

            // Preserve the current viewport â€” the server response contains a
            // round-tripped viewport that may be stale relative to the user's
            // current pan/zoom position.
            refreshedState.viewport = viewportRef.current;

            // Clear any potential draft state
            draftStateRef.current.clearAllChanges();

            // Update server baseline and apply the new state
            setServerGraphState(refreshedState);
            draftStateRef.current.updateServerBaseline(refreshedState);

            // Force update the visual state immediately
            handleDraftStateChange(refreshedState);

            setGraph(updatedGraph);

            message.success({
              key: `graph-revision-${revision.id}`,
              content: `Revision ${revision.toVersion} applied`,
              duration: 3,
            });

            // Fetch updated node states
            void fetchCompiledNodes({
              graphStatusOverride: updatedGraph.status,
            });
          }
        } catch (error) {
          console.error(
            'Error refetching graph after revision applied:',
            error,
          );
          // Fallback: just update the version
          setGraph((prev) =>
            prev ? { ...prev, version: revision.toVersion } : prev,
          );
          message.open({
            key: `graph-revision-${revision.id}`,
            type: 'success',
            content: `Revision ${revision.toVersion} applied`,
            duration: 3,
          });
        }
      },

      'graph.revision.failed': (notification) => {
        const data = notification as GraphRevisionNotification;
        if (data.graphId !== id) return;

        const revision = data.data;
        upsertRevision(revision);
        message.open({
          key: `graph-revision-${revision.id}`,
          type: 'error',
          content: revision.error
            ? `Revision ${revision.toVersion} failed: ${revision.error}`
            : `Revision ${revision.toVersion} failed`,
          duration: 5,
        });
      },

      'graph.revision.progress': (notification) => {
        const data = notification as GraphRevisionProgressNotification;
        if (data.graphId !== id) return;

        const progressData = data.data;

        if (progressData.phase === 'rebuilding') {
          setCompiledNodesMap((prev) => {
            const existing = prev[progressData.nodeId];

            if (
              existing?.status === GraphNodeWithStatusDtoStatusEnum.Starting
            ) {
              return prev;
            }

            if (existing) {
              return {
                ...prev,
                [progressData.nodeId]: {
                  ...existing,
                  status: GraphNodeWithStatusDtoStatusEnum.Starting,
                },
              };
            }

            const graphNode = nodes.find(
              (n: GraphNode) => n.id === progressData.nodeId,
            );
            if (!graphNode) {
              return prev;
            }

            const nodeData = graphNode.data as unknown as GraphNodeData;

            return {
              ...prev,
              [progressData.nodeId]: {
                id: progressData.nodeId,
                name:
                  (nodeData.label as string) ||
                  (nodeData.template as string) ||
                  progressData.nodeId,
                template: (nodeData.template as string) || '',
                type: inferNodeType(
                  nodeData.templateKind as string | undefined,
                ),
                status: GraphNodeWithStatusDtoStatusEnum.Starting,
                config: nodeData.config ?? {},
                error: null,
              },
            };
          });

          message.open({
            key: `graph-revision-${progressData.revisionId}`,
            type: 'loading',
            content: `Applying revision ${progressData.toVersion}: rebuilding node ${progressData.currentNode}/${progressData.totalNodes}`,
            duration: 0,
          });
        }
      },
    },
  });
};
