import { App, Button, Space, Spin, Tag, Typography } from 'antd';
import { createTwoFilesPatch } from 'diff';
import {
  type MutableRefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'react';

import { graphRevisionsApi } from '../../../api';
import {
  type GraphDto,
  type GraphRevisionDto,
  GraphRevisionDtoStatusEnum,
} from '../../../autogenerated';
import type { UseGraphDraftStateReturn } from '../../../hooks/useGraphDraftState';
import type { GraphDiffState } from '../../../services/GraphStorageService';
import { extractApiErrorMessage } from '../../../utils/errors';
import {
  normalizeGraphDiffSnapshot,
  REVISION_FETCH_LIMIT,
  REVISION_STATUS_STYLES,
  sortRevisions,
} from '../utils/graphPageUtils';

const REVISION_STATUS_RANK: Record<GraphRevisionDtoStatusEnum, number> = {
  [GraphRevisionDtoStatusEnum.Pending]: 0,
  [GraphRevisionDtoStatusEnum.Applying]: 1,
  [GraphRevisionDtoStatusEnum.Applied]: 2,
  [GraphRevisionDtoStatusEnum.Failed]: 2,
};

interface UseGraphRevisionsOptions {
  graphId: string | undefined;
  graph: GraphDto | null;
  serverGraphState: GraphDiffState;
  draftState: {
    draftState: GraphDiffState;
  };
  draftStateRef: MutableRefObject<UseGraphDraftStateReturn>;
  saving: boolean;
  onRevisionComplete?: (revision: GraphRevisionDto) => void;
}

export const useGraphRevisions = ({
  graphId,
  graph,
  serverGraphState,
  draftState,
  draftStateRef,
  saving,
  onRevisionComplete,
}: UseGraphRevisionsOptions) => {
  const { message, modal } = App.useApp();
  // Store onRevisionComplete in a ref so the polling interval doesn't restart
  // when the callback identity changes.
  const onRevisionCompleteRef = useRef(onRevisionComplete);
  useEffect(() => {
    onRevisionCompleteRef.current = onRevisionComplete;
  }, [onRevisionComplete]);
  const [revisions, setRevisions] = useState<GraphRevisionDto[]>([]);
  const [revisionsLoading, setRevisionsLoading] = useState(false);
  const [revisionPopoverVisible, setRevisionPopoverVisible] = useState(false);
  const [revisionDiffRevision, setRevisionDiffRevision] =
    useState<GraphRevisionDto | null>(null);
  const [localDiffModalVisible, setLocalDiffModalVisible] = useState(false);
  const [hoveredRevisionId, setHoveredRevisionId] = useState<string | null>(
    null,
  );

  const loadRevisions = useCallback(
    async (options?: { silent?: boolean }) => {
      if (!graphId) return;
      try {
        setRevisionsLoading(true);
        const response = await graphRevisionsApi.getGraphRevisions(
          graphId,
          undefined,
          REVISION_FETCH_LIMIT,
        );
        const revisionList = response.data || [];
        setRevisions(
          sortRevisions(revisionList).slice(0, REVISION_FETCH_LIMIT),
        );
      } catch (error) {
        console.error('Error loading graph revisions:', error);
        if (!options?.silent) {
          const errorMessage = extractApiErrorMessage(
            error,
            'Failed to load graph revisions',
          );
          message.error(errorMessage);
        }
      } finally {
        setRevisionsLoading(false);
      }
    },
    [graphId, message],
  );

  useEffect(() => {
    void loadRevisions({ silent: true });
  }, [loadRevisions]);

  const upsertRevision = useCallback((revision: GraphRevisionDto) => {
    setRevisions((prev) => {
      const next = prev.slice();
      const index = next.findIndex((item) => item.id === revision.id);
      if (index === -1) {
        next.push(revision);
      } else {
        const existing = next[index];
        const existingRank =
          REVISION_STATUS_RANK[existing.status as GraphRevisionDtoStatusEnum] ??
          0;
        const incomingRank =
          REVISION_STATUS_RANK[revision.status as GraphRevisionDtoStatusEnum] ??
          0;
        if (incomingRank >= existingRank) {
          next[index] = revision;
        }
      }
      return sortRevisions(next).slice(0, REVISION_FETCH_LIMIT);
    });
  }, []);

  // Derive a stable key for the active (Pending/Applying) revision.
  // Only changes when the active revision identity or status changes, avoiding
  // unnecessary polling interval restarts when unrelated revisions update.
  const activeRevKey = useMemo(() => {
    const activeRev = revisions.find(
      (r) =>
        r.status === GraphRevisionDtoStatusEnum.Pending ||
        r.status === GraphRevisionDtoStatusEnum.Applying,
    );
    return activeRev ? `${activeRev.id}:${activeRev.status}` : null;
  }, [revisions]);

  // Polling fallback for pending/applying revisions — catches missed WebSocket events.
  // When an active revision is detected, poll its status every 3 seconds for up to 60 seconds.
  useEffect(() => {
    if (!graphId || !activeRevKey) return;

    const [revId] = activeRevKey.split(':');

    const poll = async () => {
      try {
        const response = await graphRevisionsApi.getGraphRevision(
          graphId,
          revId,
        );
        const updated = response.data;
        if (
          updated.status === GraphRevisionDtoStatusEnum.Applied ||
          updated.status === GraphRevisionDtoStatusEnum.Failed
        ) {
          upsertRevision(updated);
          onRevisionCompleteRef.current?.(updated);
        }
      } catch {
        // Silently ignore polling errors — WebSocket is the primary channel
      }
    };

    const POLL_INTERVAL_MS = 3000;
    const POLL_TIMEOUT_MS = 60000;

    const interval = setInterval(() => void poll(), POLL_INTERVAL_MS);
    const timeout = setTimeout(() => clearInterval(interval), POLL_TIMEOUT_MS);

    return () => {
      clearInterval(interval);
      clearTimeout(timeout);
    };
  }, [graphId, activeRevKey, upsertRevision]);

  const activeRevision = useMemo(() => {
    if (!revisions.length) {
      return null;
    }

    const applyingRevision = revisions.find(
      (revision) => revision.status === GraphRevisionDtoStatusEnum.Applying,
    );
    if (applyingRevision) {
      return applyingRevision;
    }

    const pendingRevision = revisions.find(
      (revision) => revision.status === GraphRevisionDtoStatusEnum.Pending,
    );
    if (pendingRevision) {
      return pendingRevision;
    }

    if (graph?.version) {
      const matchingApplied = revisions.find(
        (revision) =>
          revision.toVersion === graph.version &&
          revision.status === GraphRevisionDtoStatusEnum.Applied,
      );
      if (matchingApplied) {
        return matchingApplied;
      }
    }

    const appliedRevision = revisions.find(
      (revision) => revision.status === GraphRevisionDtoStatusEnum.Applied,
    );
    if (appliedRevision) {
      return appliedRevision;
    }

    return revisions[0];
  }, [revisions, graph?.version]);

  // The most recent failed revision (if it's newer than the active/applied one)
  const lastFailedRevision = useMemo(() => {
    if (!revisions.length) return null;
    // revisions are sorted newest-first; check if the latest is failed
    const latest = revisions[0];
    if (latest.status !== GraphRevisionDtoStatusEnum.Failed) return null;
    // Only show if it's different from the active revision (i.e. active is an older Applied one)
    if (activeRevision && activeRevision.id === latest.id) return null;
    return latest;
  }, [revisions, activeRevision]);

  const isRevisionApplying = useMemo(
    () =>
      revisions.some(
        (revision) => revision.status === GraphRevisionDtoStatusEnum.Applying,
      ),
    [revisions],
  );

  const handleResetAllLocalChanges = useCallback(() => {
    if (saving || isRevisionApplying) return;

    modal.confirm({
      title: 'Reset all local changes?',
      content:
        'This will discard all unsaved changes and restore the last saved version from the server.',
      okText: 'Reset changes',
      okButtonProps: { danger: true },
      cancelText: 'Cancel',
      onOk: () => {
        draftStateRef.current.resetToServer();
        message.success('Local changes reset');
      },
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [saving, isRevisionApplying, modal, message]);

  const handleOpenLocalDiff = useCallback(() => {
    setLocalDiffModalVisible(true);
    setRevisionPopoverVisible(false);
  }, []);

  const handleCloseLocalDiff = useCallback(() => {
    setLocalDiffModalVisible(false);
  }, []);

  const unsavedChangesPopoverContent = useMemo(() => {
    return (
      <Space direction="vertical" size={8}>
        <Typography.Text>You have unsaved changes.</Typography.Text>
        <Button
          type="link"
          size="small"
          onClick={handleOpenLocalDiff}
          style={{ padding: 0, height: 'auto' }}>
          View local changes
        </Button>
        <Button
          danger
          size="small"
          onClick={handleResetAllLocalChanges}
          disabled={saving || isRevisionApplying}>
          Reset all local changes
        </Button>
      </Space>
    );
  }, [
    handleOpenLocalDiff,
    handleResetAllLocalChanges,
    saving,
    isRevisionApplying,
  ]);

  const displayedRevisionMeta: {
    label: string;
    color: string;
    pulse?: boolean;
  } | null = useMemo(() => {
    if (activeRevision) {
      const meta =
        REVISION_STATUS_STYLES[
          activeRevision.status as GraphRevisionDtoStatusEnum
        ] ?? null;

      if (
        activeRevision.status === GraphRevisionDtoStatusEnum.Applying &&
        meta
      ) {
        return { ...meta, label: `Applying` };
      }
      if (meta) {
        return meta;
      }
    }
    if (graph) {
      return {
        label: 'Applied',
        color: '#52c41a',
      };
    }
    return null;
  }, [activeRevision, graph]);

  const displayedVersion = useMemo(() => {
    if (activeRevision) {
      const isAppliedActive =
        activeRevision.status === GraphRevisionDtoStatusEnum.Applied;
      if (!isAppliedActive || activeRevision.toVersion !== graph?.version) {
        return activeRevision.toVersion;
      }
    }
    return graph?.version ?? '—';
  }, [activeRevision, graph?.version]);

  const localDiffPatch = useMemo(() => {
    if (!graph) return '';
    const baseline = normalizeGraphDiffSnapshot(serverGraphState);
    const draft = normalizeGraphDiffSnapshot(draftState.draftState);
    const baselineJson = JSON.stringify(baseline, null, 2);
    const draftJson = JSON.stringify(draft, null, 2);
    if (baselineJson === draftJson) {
      return '';
    }
    const baseVersionLabel = serverGraphState.baseVersion ?? graph.version;
    const baseTitle = baseVersionLabel ? `v${baseVersionLabel}` : 'Server';
    return createTwoFilesPatch(
      baseTitle,
      'Local draft',
      baselineJson,
      draftJson,
      '',
      '',
      { context: 6 },
    ).trimEnd();
  }, [draftState.draftState, graph, serverGraphState]);

  const handleOpenRevisionDiff = useCallback((revision: GraphRevisionDto) => {
    setRevisionDiffRevision(revision);
    setRevisionPopoverVisible(false);
  }, []);

  const handleDownloadGraphBackup = useCallback(() => {
    if (!graph) {
      message.warning('Graph is not loaded yet');
      return;
    }

    try {
      const backupPayload = {
        exportedAt: new Date().toISOString(),
        graph,
        viewport: draftStateRef.current.draftState.viewport,
      };

      const blob = new Blob([JSON.stringify(backupPayload, null, 2)], {
        type: 'application/json',
      });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      const safeVersion = graph.version ? `v${graph.version}` : 'draft';
      link.href = url;
      link.download = `graph-${graph.id ?? 'graph'}-${safeVersion}.json`;
      document.body.appendChild(link);
      link.click();
      link.remove();
      URL.revokeObjectURL(url);
    } catch (error) {
      console.error('Failed to export graph backup', error);
      message.error('Failed to download graph backup');
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [graph, message]);

  const handleCloseRevisionDiff = useCallback(() => {
    setRevisionDiffRevision(null);
  }, []);

  const revisionDiffModalVisible = revisionDiffRevision !== null;

  // Find the previous version's config to diff against.
  // A revision's baseVersion points to the version it was based on,
  // so we look for a revision whose toVersion matches the selected revision's baseVersion.
  const revisionDiffPreviousConfig = useMemo(() => {
    if (!revisionDiffRevision) return null;
    const prevRevision = revisions.find(
      (r) => r.toVersion === revisionDiffRevision.baseVersion,
    );
    return prevRevision?.newConfig ?? null;
  }, [revisionDiffRevision, revisions]);

  const revisionPopoverContent = useMemo(() => {
    if (revisionsLoading) {
      return (
        <div
          style={{
            minWidth: 280,
            minHeight: 80,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
          }}>
          <Spin size="small" />
        </div>
      );
    }

    if (revisions.length === 0) {
      return (
        <div style={{ minWidth: 280 }}>
          <Typography.Text type="secondary" style={{ fontSize: 12 }}>
            No revisions available yet.
          </Typography.Text>
        </div>
      );
    }

    return (
      <div style={{ minWidth: 320, maxHeight: 320, overflowY: 'auto' }}>
        <Space direction="vertical" size="small" style={{ width: '100%' }}>
          {revisions.map((revision) => {
            const meta = REVISION_STATUS_STYLES[
              revision.status as GraphRevisionDtoStatusEnum
            ] ?? {
              label: revision.status,
              color: '#d9d9d9',
            };
            const isActive = activeRevision?.id === revision.id;
            const isHovered = hoveredRevisionId === revision.id;
            const timestamp = new Date(
              revision.updatedAt || revision.createdAt,
            ).toLocaleString();

            return (
              <div
                key={revision.id}
                onMouseEnter={() => setHoveredRevisionId(revision.id)}
                onMouseLeave={() =>
                  setHoveredRevisionId((prev) =>
                    prev === revision.id ? null : prev,
                  )
                }
                style={{
                  border: '1px solid #f0f0f0',
                  borderRadius: 6,
                  padding: '8px 12px',
                  background: isActive
                    ? '#fffbe6'
                    : isHovered
                      ? '#f0f5ff'
                      : '#fff',
                  display: 'flex',
                  flexDirection: 'column',
                  gap: 4,
                  transition:
                    'background-color 0.2s ease, border-color 0.2s ease',
                }}>
                <div
                  style={{
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between',
                    gap: 8,
                  }}>
                  <Typography.Text strong style={{ fontSize: 13 }}>
                    v{revision.toVersion}
                  </Typography.Text>
                  <div
                    style={{
                      display: 'flex',
                      alignItems: 'center',
                      gap: 8,
                      marginLeft: 'auto',
                    }}>
                    <Button
                      type="link"
                      size="small"
                      onClick={() => handleOpenRevisionDiff(revision)}
                      style={{
                        padding: 0,
                        height: 'auto',
                        fontSize: 12,
                      }}>
                      View diff
                    </Button>
                    <Tag
                      color={meta.color}
                      style={{
                        margin: 0,
                        borderRadius: 999,
                        fontSize: 11,
                        lineHeight: '18px',
                        padding: '0 8px',
                      }}>
                      {meta.label}
                    </Tag>
                  </div>
                </div>
                <Typography.Text
                  type="secondary"
                  style={{ fontSize: 12, display: 'block' }}>
                  From v{revision.baseVersion}
                </Typography.Text>
                <Typography.Text
                  type="secondary"
                  style={{ fontSize: 12, display: 'block' }}>
                  Updated {timestamp}
                </Typography.Text>
                {revision.error && (
                  <Typography.Text
                    type="danger"
                    style={{ fontSize: 12, display: 'block', marginTop: 2 }}>
                    {revision.error}
                  </Typography.Text>
                )}
              </div>
            );
          })}
        </Space>
      </div>
    );
  }, [
    revisionsLoading,
    revisions,
    activeRevision?.id,
    hoveredRevisionId,
    handleOpenRevisionDiff,
  ]);

  return {
    revisionPopoverVisible,
    setRevisionPopoverVisible,
    revisionDiffRevision,
    revisionDiffPreviousConfig,
    localDiffModalVisible,
    loadRevisions,
    upsertRevision,
    isRevisionApplying,
    displayedVersion,
    displayedRevisionMeta,
    lastFailedRevision,
    localDiffPatch,
    handleCloseLocalDiff,
    unsavedChangesPopoverContent,
    revisionPopoverContent,
    handleDownloadGraphBackup,
    handleCloseRevisionDiff,
    revisionDiffModalVisible,
  };
};
