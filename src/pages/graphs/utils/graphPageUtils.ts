import type { Viewport } from '@xyflow/react';

import type {
  GraphDto,
  GraphRevisionDto,
  GraphRevisionDtoStatusEnum,
  TemplateDto,
} from '../../../autogenerated';
import type { GraphDiffState } from '../../../services/GraphStorageService';
import type {
  GraphEdge,
  GraphMetadata,
  GraphNode,
  NodeMetadata,
} from '../types';
import { createEdge, resolveHandlesForNodes } from './graphCanvasUtils';

export const REVISION_FETCH_LIMIT = 10;

export const ensureRevisionStatusPulseStyle = (() => {
  let injected = false;
  return () => {
    if (injected || typeof document === 'undefined') return;
    if (document.getElementById('revision-status-pulse-style')) {
      injected = true;
      return;
    }
    const style = document.createElement('style');
    style.id = 'revision-status-pulse-style';
    style.textContent = `
      @keyframes revision-status-pulse {
        0% { box-shadow: 0 0 0 0 rgba(250, 173, 20, 0.45); }
        70% { box-shadow: 0 0 0 8px rgba(250, 173, 20, 0); }
        100% { box-shadow: 0 0 0 0 rgba(250, 173, 20, 0); }
      }
    `;
    document.head.appendChild(style);
    injected = true;
  };
})();

export const REVISION_STATUS_STYLES: Record<
  GraphRevisionDtoStatusEnum,
  { label: string; color: string; pulse?: boolean }
> = {
  pending: {
    label: 'Pending',
    color: '#d9d9d9',
  },
  applying: {
    label: 'Applying',
    color: '#faad14',
    pulse: true,
  },
  applied: {
    label: 'Applied',
    color: '#52c41a',
  },
  failed: {
    label: 'Failed',
    color: '#ff4d4f',
  },
} as const;

export const deepSortKeys = (value: unknown): unknown => {
  if (value === null || value === undefined) return value;
  if (typeof value !== 'object') return value;
  if (Array.isArray(value)) return value.map(deepSortKeys);

  const sorted: Record<string, unknown> = {};
  Object.keys(value as Record<string, unknown>)
    .sort()
    .forEach((key) => {
      sorted[key] = deepSortKeys((value as Record<string, unknown>)[key]);
    });
  return sorted;
};

const stripNodeDataCallbacks = (data: unknown): Record<string, unknown> => {
  if (!data || typeof data !== 'object') {
    return {};
  }
  return data as Record<string, unknown>;
};

export const normalizeGraphDiffSnapshot = (state: GraphDiffState) => {
  return {
    graphName: state.graphName ?? '',
    nodes: state.nodes
      .map((node) => {
        const strippedData = stripNodeDataCallbacks(node.data);
        const normalizedData = {
          label: strippedData.label,
          template: strippedData.template,
          config: strippedData.config
            ? deepSortKeys(strippedData.config)
            : strippedData.config,
        };
        return {
          id: node.id,
          type: node.type,
          position: node.position,
          data: {
            ...normalizedData,
          },
        };
      })
      .sort((a, b) => a.id.localeCompare(b.id)),
    edges: state.edges
      .map((edge) => ({
        id: edge.id,
        source: edge.source,
        target: edge.target,
        sourceHandle: edge.sourceHandle,
        targetHandle: edge.targetHandle,
        label: typeof edge.label === 'string' ? edge.label : undefined,
      }))
      .sort((a, b) => a.id.localeCompare(b.id)),
  };
};

export const sortRevisions = (list: GraphRevisionDto[]): GraphRevisionDto[] => {
  return [...list].sort((a, b) => {
    const aTime = new Date(a.updatedAt || a.createdAt).getTime();
    const bTime = new Date(b.updatedAt || b.createdAt).getTime();
    if (bTime === aTime) {
      return b.toVersion.localeCompare(a.toVersion);
    }
    return bTime - aTime;
  });
};

/**
 * Converts a GraphDto (server response) into ReactFlow nodes, edges, and a
 * full GraphDiffState. Shared between useGraphLoader (initial load) and
 * rebuildStateFromGraph (revision applied / save completed).
 */
export const buildGraphDiffState = (
  graphData: GraphDto,
  templates: TemplateDto[],
  options?: {
    fallbackViewport?: Viewport;
  },
): GraphDiffState => {
  const metadata = (graphData.metadata as GraphMetadata) || {};
  const nodeMetadata = metadata.nodes || [];

  const nodeMetadataMap = nodeMetadata.reduce(
    (acc, nodeMeta) => {
      acc[nodeMeta.id] = nodeMeta;
      return acc;
    },
    {} as Record<string, NodeMetadata>,
  );

  const apiNodes = graphData.schema?.nodes || [];
  const reactFlowNodes: GraphNode[] = apiNodes.map((node, index) => {
    const nodeMeta = nodeMetadataMap[node.id];
    const template = templates.find((t) => t.id === node.template);
    return {
      id: node.id,
      type: 'custom',
      position: nodeMeta
        ? { x: nodeMeta.x, y: nodeMeta.y }
        : {
            x: 100 + (index % 3) * 250,
            y: 100 + Math.floor(index / 3) * 150,
          },
      data: {
        label: nodeMeta?.name || template?.name || node.template,
        template: node.template,
        templateKind: template?.kind,
        templateSchema: template?.schema,
        config: node.config || {},
      },
    };
  });

  const nodeById: Record<string, GraphNode> = Object.fromEntries(
    reactFlowNodes.map((n) => [n.id, n]),
  );

  const apiEdges = graphData.schema?.edges || [];
  const reactFlowEdges: GraphEdge[] = apiEdges.map((edge) => {
    const src = nodeById[edge.from];
    const dst = nodeById[edge.to];
    const { sourceHandle, targetHandle } = resolveHandlesForNodes(
      src,
      dst,
      templates,
    );
    return createEdge(
      edge.from,
      edge.to,
      sourceHandle,
      targetHandle,
      typeof edge.label === 'string' ? edge.label : undefined,
    );
  });

  const viewport: Viewport =
    metadata.x !== undefined &&
    metadata.y !== undefined &&
    metadata.zoom !== undefined
      ? { x: metadata.x, y: metadata.y, zoom: metadata.zoom }
      : (options?.fallbackViewport ?? { x: 0, y: 0, zoom: 1 });

  return {
    nodes: reactFlowNodes,
    edges: reactFlowEdges,
    viewport,
    graphName: graphData.name,
    baseVersion: graphData.version,
  };
};
