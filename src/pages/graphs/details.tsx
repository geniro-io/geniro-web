import { RightOutlined } from '@ant-design/icons';
import {
  NodeChange,
  useEdgesState,
  useNodesState,
  Viewport,
} from '@xyflow/react';
import { App, Button, Layout, Spin } from 'antd';
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { useNavigate, useParams } from 'react-router';

import { graphsApi } from '../../api';
import {
  ExecuteTriggerDto,
  GraphDto,
  GraphDtoStatusEnum,
  GraphNodeWithStatusDto,
  GraphRevisionDto,
  GraphRevisionDtoStatusEnum,
  TemplateDto,
} from '../../autogenerated';
import { useGraphDraftState } from '../../hooks/useGraphDraftState';
import { useSystemSettings } from '../../hooks/useSystemSettings';
import {
  type GraphDiffState,
  GraphStorageService,
} from '../../services/GraphStorageService';
import { GraphAiSuggestionModal } from './components/GraphAiSuggestionModal';
import { GraphCanvas } from './components/GraphCanvas';
import { GraphPageHeader } from './components/GraphPageHeader';
import { LocalDiffModal } from './components/LocalDiffModal';
import { NodeEditSidebar } from './components/NodeEditSidebar';
import { RevisionDiffModal } from './components/RevisionDiffModal';
import { TemplateModal } from './components/TemplateModal';
import { TemplateSidebar } from './components/TemplateSidebar';
import { TriggerModal } from './components/TriggerModal';
import { useGraphActions } from './hooks/useGraphActions';
import { useGraphAiSuggestions } from './hooks/useGraphAiSuggestions';
import { useGraphLoader } from './hooks/useGraphLoader';
import { useGraphRevisions } from './hooks/useGraphRevisions';
import { useGraphWebSocketHandlers } from './hooks/useGraphWebSocketHandlers';
import type { GraphEdge, GraphNode } from './types';
import {
  buildGraphDiffState,
  ensureRevisionStatusPulseStyle,
} from './utils/graphPageUtils';

const { Sider, Content } = Layout;

export const GraphPage = () => {
  const { message } = App.useApp();
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();

  useEffect(() => {
    ensureRevisionStatusPulseStyle();
  }, []);

  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [leftSidebarCollapsed, setLeftSidebarCollapsed] = useState(false);
  const [graph, setGraph] = useState<GraphDto | null>(null);

  // Server state for the draft hook (initialized with empty state, updated after load)
  const [serverGraphState, setServerGraphState] = useState<GraphDiffState>({
    nodes: [],
    edges: [],
    viewport: { x: 0, y: 0, zoom: 1 },
    graphName: '',
  });

  // React Flow state (will be synced with draft state via onStateChange)
  const [nodes, setNodes, baseOnNodesChange] = useNodesState<GraphNode>([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState<GraphEdge>([]);
  const [viewport, setViewport] = useState<Viewport>(() => {
    if (!id) return { x: 0, y: 0, zoom: 1 };
    // Always load viewport from the dedicated viewport key — it's written on
    // every pan/zoom and is always the most recent.  The structural draft's
    // viewport can be stale (only updated when nodes/edges change).
    return GraphStorageService.loadViewport(id) ?? { x: 0, y: 0, zoom: 1 };
  });
  const viewportRef = useRef<Viewport>(viewport);

  // Draft is our persisted source of truth, but ReactFlow is the immediate UI state.
  // When we update the draft *from* ReactFlow (onNodesChange/onEdgesChange), we must
  // not immediately "sync back" into ReactFlow, otherwise partial draft updates
  // (e.g. edges update arriving before nodes update) can resurrect deleted nodes.
  const nextDraftChangeOriginRef = useRef<'draft' | 'reactflow'>('draft');

  // Track whether the graph has been loaded at least once.  Before that,
  // draft state still holds the empty initial serverGraphState whose viewport
  // is {0,0,1}.  We must not let that overwrite the viewport we loaded from
  // localStorage on mount.
  const graphLoadedRef = useRef(false);

  // Callback to sync draft state changes to React Flow
  const handleDraftStateChange = useCallback(
    (newState: GraphDiffState) => {
      const origin = nextDraftChangeOriginRef.current;
      nextDraftChangeOriginRef.current = 'draft';
      if (origin === 'reactflow') {
        // ReactFlow already has the latest UI state; avoid overwriting it with a
        // partial draft update (which can be briefly out of sync).
        return;
      }

      isSyncingFromDraftRef.current = true;

      setNodes(newState.nodes);
      setEdges(newState.edges);

      // Only sync viewport once the graph has loaded.  Before that the draft
      // contains the empty initial state {0,0,1} which would overwrite the
      // viewport we correctly restored from localStorage on mount.
      // We detect "loaded" by checking if the draft has nodes — the initial
      // empty serverGraphState has zero nodes.
      if (graphLoadedRef.current || newState.nodes.length > 0) {
        graphLoadedRef.current = true;
        setViewport(newState.viewport);
        viewportRef.current = newState.viewport;
      }

      requestAnimationFrame(() => {
        isSyncingFromDraftRef.current = false;
      });
    },
    [setNodes, setEdges, setViewport],
  );

  // Central draft state management - single source of truth!
  const draftState = useGraphDraftState({
    graphId: id || '',
    serverState: serverGraphState,
    onStateChange: handleDraftStateChange,
    viewportRef,
  });

  // Ref for draft state to use in callbacks without recreating them
  const draftStateRef = useRef(draftState);
  useEffect(() => {
    draftStateRef.current = draftState;
  }, [draftState]);

  const isHydratingRef = useRef(true);
  const userInteractedRef = useRef(false);
  const isSyncingFromDraftRef = useRef(false);

  const [selectedTemplate, setSelectedTemplate] = useState<TemplateDto | null>(
    null,
  );
  const [templateModalVisible, setTemplateModalVisible] = useState(false);

  const [selectedNode, setSelectedNode] = useState<GraphNode | null>(null);
  const [nodeEditSidebarVisible, setNodeEditSidebarVisible] = useState(false);
  const [templates, setTemplates] = useState<TemplateDto[]>([]);
  const templatesById = useMemo(
    () =>
      templates.reduce<Record<string, TemplateDto>>((acc, template) => {
        acc[template.id] = template;
        return acc;
      }, {}),
    [templates],
  );

  const [triggerModalVisible, setTriggerModalVisible] = useState(false);
  const [triggerNodeId, setTriggerNodeId] = useState<string | null>(null);
  const [triggerNodeName, setTriggerNodeName] = useState<string | null>(null);
  const [triggerLoading, setTriggerLoading] = useState(false);

  const [editingName, setEditingName] = useState('');

  const { settings: systemSettings } = useSystemSettings();

  const isGraphRunning = graph?.status === GraphDtoStatusEnum.Running;
  const isGraphCompiling = graph?.status === GraphDtoStatusEnum.Compiling;

  const {
    graphAiModalOpen,
    graphAiUserRequest,
    setGraphAiUserRequest,
    graphAiLoading,
    graphAiSelectedNodeId,
    setGraphAiSelectedNodeId,
    graphAiModel,
    setGraphAiModel,
    graphAiModels,
    graphAiModelsLoading,
    graphAiUpdatesByNodeId,
    agentNodes,
    hasAgentNodes,
    canSubmitGraphAi,
    handleOpenGraphAiModal,
    handleCloseGraphAiModal,
    handleGraphAiSuggestionSubmit,
    handleApplyGraphAiSuggestions,
    getCurrentNodeInstructions,
  } = useGraphAiSuggestions({
    graph,
    isGraphRunning,
    nodes,
    templatesById,
    draftStateRef,
  });

  // Helper to rebuild state from server graph response
  // This is called after revision applied / save completed
  const rebuildStateFromGraph = useCallback(
    (graphData: GraphDto): GraphDiffState =>
      buildGraphDiffState(graphData, templates, {
        fallbackViewport: viewportRef.current,
      }),
    [templates],
  );

  // Use draft state flags - single source of truth!
  const hasUnsavedChanges = draftState.hasUnsavedChanges;
  const hasStructuralChanges = draftState.hasStructuralChanges;
  const handleViewportPersistChange = useCallback(
    (nextViewport: Viewport) => {
      // Only update the ref — avoid setState to prevent parent re-renders
      // (which cascade into GraphCanvas / MiniMap and cause flickering).
      viewportRef.current = nextViewport;

      if (!id) return;
      if (loading) return;
      if (isSyncingFromDraftRef.current) return;

      // Save synchronously so the viewport is never lost on reload.
      // localStorage.setItem is fast enough to call on every viewport change.
      GraphStorageService.saveViewport(id, nextViewport);
    },
    [id, loading],
  );
  const selectedNodeUnsavedFromServer = useMemo(() => {
    if (!selectedNode?.id) return false;
    return draftState.hasNodeChanges(selectedNode.id);
  }, [selectedNode?.id, draftState]);

  useGraphLoader({
    graphId: id,
    navigate,
    draftStateRef,
    setGraph,
    setEditingName,
    setTemplates,
    setLoading,
    setNodes,
    setEdges,
    setServerGraphState,
  });

  const [compiledNodesMap, setCompiledNodesMap] = useState<
    Record<string, GraphNodeWithStatusDto>
  >({});
  const [compiledNodesLoading, setCompiledNodesLoading] = useState(false);

  const fetchCompiledNodes = useCallback(
    async (options?: { graphStatusOverride?: GraphDtoStatusEnum | null }) => {
      if (!id) return;

      const currentGraphStatus =
        options &&
        Object.prototype.hasOwnProperty.call(options, 'graphStatusOverride')
          ? options.graphStatusOverride
          : (graph?.status ?? null);

      if (currentGraphStatus === GraphDtoStatusEnum.Compiling) {
        setCompiledNodesLoading(false);
        return;
      }

      if (currentGraphStatus !== GraphDtoStatusEnum.Running) {
        setCompiledNodesMap((prev) => {
          return Object.keys(prev).length === 0 ? prev : {};
        });
        setCompiledNodesLoading(false);
        return;
      }

      try {
        setCompiledNodesLoading(true);
        const response = await graphsApi.getCompiledNodes(id);
        const nodesWithStatus = response.data || [];
        setCompiledNodesMap((prevMap) => {
          const next = nodesWithStatus.reduce<
            Record<string, GraphNodeWithStatusDto>
          >((acc, node) => {
            acc[node.id] = node;
            return acc;
          }, {});

          const prevKeys = Object.keys(prevMap).sort();
          const nextKeys = Object.keys(next).sort();

          if (
            prevKeys.length !== nextKeys.length ||
            !prevKeys.every((key, i) => key === nextKeys[i])
          ) {
            return next;
          }

          const hasChanges = nextKeys.some((key) => {
            const prevNode = prevMap[key];
            const nextNode = next[key];
            return (
              !prevNode ||
              prevNode.status !== nextNode.status ||
              prevNode.error !== nextNode.error ||
              prevNode.name !== nextNode.name ||
              prevNode.template !== nextNode.template ||
              prevNode.type !== nextNode.type
            );
          });

          return hasChanges ? next : prevMap;
        });
      } catch (error) {
        console.error('Error loading compiled nodes:', error);
      } finally {
        setCompiledNodesLoading(false);
      }
    },
    [graph?.status, id],
  );

  useEffect(() => {
    fetchCompiledNodes();
  }, [fetchCompiledNodes]);

  // Polling fallback callback: refresh graph state when polling detects a
  // completed revision. Mirrors the WebSocket `graph.revision.applied` handler
  // in useGraphWebSocketHandlers so the graph version stays in sync.
  const refreshGraphAfterRevision = useCallback(
    async (revision: GraphRevisionDto) => {
      if (!id) return;

      // Only refresh for applied revisions — failed ones don't change graph state
      if (revision.status !== GraphRevisionDtoStatusEnum.Applied) return;

      GraphStorageService.clearPendingRevision(id);

      try {
        const res = await graphsApi.findGraphById(id);
        const updatedGraph = res.data;

        const hasLocalChanges = draftStateRef.current.hasUnsavedChanges;

        if (hasLocalChanges) {
          // User has local changes — update graph metadata (including version)
          // but don't override their draft
          setGraph(updatedGraph);
          void fetchCompiledNodes({
            graphStatusOverride: updatedGraph.status,
          });
        } else {
          // No local changes — safely rebuild everything from server
          const refreshedState = rebuildStateFromGraph(updatedGraph);
          refreshedState.viewport = viewportRef.current;

          draftStateRef.current.clearAllChanges();
          setServerGraphState(refreshedState);
          draftStateRef.current.updateServerBaseline(refreshedState);
          handleDraftStateChange(refreshedState);
          setGraph(updatedGraph);

          void fetchCompiledNodes({
            graphStatusOverride: updatedGraph.status,
          });
        }
      } catch (error) {
        console.error(
          'Error refetching graph after polling detected revision completion:',
          error,
        );
        // Fallback: at minimum update the graph version to prevent VERSION_CONFLICT
        setGraph((prev) =>
          prev ? { ...prev, version: revision.toVersion } : prev,
        );
      }
    },
    [
      id,
      setGraph,
      setServerGraphState,
      rebuildStateFromGraph,
      handleDraftStateChange,
      fetchCompiledNodes,
    ],
  );

  const {
    revisionPopoverVisible,
    setRevisionPopoverVisible,
    revisionDiffRevision,
    localDiffModalVisible,
    loadRevisions,
    upsertRevision,
    isRevisionApplying,
    displayedVersion,
    displayedRevisionMeta,
    lastFailedRevision,
    localDiffPatch,
    handleCloseLocalDiff,
    unsavedChangesPopoverContent,
    revisionPopoverContent,
    formatRevisionDiffValue,
    handleDownloadGraphBackup,
    handleCloseRevisionDiff,
    revisionDiffModalVisible,
  } = useGraphRevisions({
    graphId: id,
    graph,
    serverGraphState,
    draftState,
    draftStateRef,
    saving,
    onRevisionComplete: refreshGraphAfterRevision,
  });

  useEffect(() => {
    if (!loading) {
      const t = requestAnimationFrame(() => {
        isHydratingRef.current = false;
      });
      return () => cancelAnimationFrame(t);
    }
  }, [loading]);

  const selectedNodeId = selectedNode?.id;
  useEffect(() => {
    // Keep selectedNode in sync with the latest node data from nodes array
    // This ensures NodeEditSidebar always sees the current draftGraph state
    if (selectedNodeId) {
      const updatedNode = nodes.find((n) => n.id === selectedNodeId);
      if (updatedNode && updatedNode !== selectedNode) {
        // Only update if the node actually changed (by reference)
        setSelectedNode(updatedNode);
      } else if (!updatedNode) {
        // Node was deleted, clear selection
        setSelectedNode(null);
        setNodeEditSidebarVisible(false);
      }
    }
    // Depend on selectedNodeId (not selectedNode) to avoid re-running when
    // we update selectedNode to the latest reference from nodes array.
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [nodes, selectedNodeId]);

  const handleValidationError = useCallback(
    (error: string) => {
      message.error(`Connection validation failed: ${error}`);
    },
    [message],
  );

  const handleTemplateClick = useCallback((template: TemplateDto) => {
    setSelectedTemplate(template);
    setTemplateModalVisible(true);
  }, []);

  // Stabilize callbacks to prevent nodeTypes recreation
  // Use refs for draft state access to avoid dependencies
  // (draftStateRef is already defined earlier in the component)

  const handleNodeAdd = useCallback((node: GraphNode) => {
    const newNodes = [...draftStateRef.current.draftState.nodes, node];
    draftStateRef.current.updateNodes(newNodes);
  }, []);

  const handleNodeEdit = useCallback((node: GraphNode) => {
    setSelectedNode(node);
    setNodeEditSidebarVisible(true);
  }, []);

  const handleNodeSelect = useCallback((node: GraphNode | null) => {
    setSelectedNode(node);
    setNodeEditSidebarVisible(!!node);
  }, []);

  const handleNodeSave = useCallback(
    (
      nodeId: string,
      updates: { name?: string; config?: Record<string, unknown> },
    ) => {
      // Use the draft state's updateNodeConfig method
      draftStateRef.current.updateNodeConfig(nodeId, updates);
    },
    [],
  );

  const handleNodeDelete = useCallback((nodeId: string) => {
    const newNodes = draftStateRef.current.draftState.nodes.filter(
      (node) => node.id !== nodeId,
    );
    const newEdges = draftStateRef.current.draftState.edges.filter(
      (edge) => edge.source !== nodeId && edge.target !== nodeId,
    );
    draftStateRef.current.updateNodes(newNodes);
    draftStateRef.current.updateEdges(newEdges);
  }, []);

  // Store nodes and edges in refs to avoid recreating callbacks
  const nodesRef = useRef<GraphNode[]>([]);
  const edgesRef = useRef<GraphEdge[]>([]);
  useEffect(() => {
    nodesRef.current = nodes;
  }, [nodes]);
  useEffect(() => {
    edgesRef.current = edges;
  }, [edges]);

  const handleTriggerClick = useCallback((nodeId: string) => {
    const node = nodesRef.current.find((n) => n.id === nodeId);
    if (!node) return;
    setTriggerNodeId(nodeId);
    setTriggerNodeName(node.data.label as string);
    setTriggerModalVisible(true);
  }, []);

  useGraphWebSocketHandlers({
    graphState: {
      id: id!,
      nodes,
    },
    setters: {
      setGraph,
      setCompiledNodesMap,
      setServerGraphState,
    },
    revisionActions: {
      upsertRevision,
      rebuildStateFromGraph,
      handleDraftStateChange,
      fetchCompiledNodes,
    },
    refs: {
      draftStateRef,
      viewportRef,
    },
  });

  const {
    isSavingName,
    isEditingName,
    actionLoading,
    graphError,
    draftNodeConfigVersion,
    handleSave,
    handleNameEdit,
    handleNameSave,
    handleNameCancel,
    handleGraphAction,
    graphMenuItems,
    handleGraphMenuAction,
  } = useGraphActions({
    graphId: id,
    graph,
    setGraph,
    nodes,
    edges,
    templates,
    setEdges,
    viewportRef,
    draftStateRef,
    serverGraphState,
    setServerGraphState,
    rebuildStateFromGraph,
    handleDraftStateChange,
    upsertRevision,
    handleDownloadGraphBackup,
    handleOpenGraphAiModal,
    hasAgentNodes,
    userInteractedRef,
    fetchCompiledNodes,
    navigate,
    editingName,
    setEditingName,
    saving,
    setSaving,
  });

  const handleTriggerNode = useCallback(
    async (triggerMessage: string) => {
      if (!triggerNodeId || !id) return;

      try {
        setTriggerLoading(true);
        if (hasUnsavedChanges) {
          await handleSave();
        }

        const executeTriggerDto: ExecuteTriggerDto = {
          messages: [triggerMessage],
          async: true,
        };

        await graphsApi.executeTrigger(id, triggerNodeId, executeTriggerDto);

        message.success('Trigger sent successfully');
        setTriggerModalVisible(false);
        setTriggerNodeId(null);
        setTriggerNodeName(null);
      } catch (error) {
        console.error('Error triggering node:', error);
        const errorMessage =
          error instanceof Error ? error.message : 'Failed to trigger node';
        message.error(errorMessage);
        throw error;
      } finally {
        setTriggerLoading(false);
      }
    },
    [triggerNodeId, id, hasUnsavedChanges, handleSave, message],
  );

  // Track whether a drag is in progress so we can skip parent state updates
  // (which trigger full re-render cascades) until the drag ends.
  const isDraggingRef = useRef(false);

  const handleNodesChange = useCallback(
    (changes: NodeChange[]) => {
      // If nodes are being removed, also prune any incident edges immediately
      // to guarantee "delete node => delete all its edges".
      const removedNodeIds = changes
        .filter(
          (c): c is Extract<NodeChange, { type: 'remove' }> =>
            c.type === 'remove',
        )
        .map((c) => ('id' in c ? (c.id as string) : ''))
        .filter(Boolean);

      if (removedNodeIds.length > 0) {
        // Compute the next snapshots immediately from refs to avoid races where
        // nodesRef/edgesRef haven't updated yet when we persist the draft.
        const nextNodesSnapshot = nodesRef.current.filter(
          (n) => !removedNodeIds.includes(n.id),
        );
        const nextEdgesSnapshot = edgesRef.current.filter(
          (e) =>
            !removedNodeIds.includes(e.source) &&
            !removedNodeIds.includes(e.target),
        );

        // Ensure the UI drops incident edges even if ReactFlow doesn't emit edge removals.
        setEdges(nextEdgesSnapshot);

        // Persist node+edge deletion into the draft as a ReactFlow-origin change,
        // and prevent syncing back into ReactFlow (it already reflects the deletion).
        if (
          !isHydratingRef.current &&
          userInteractedRef.current &&
          !isSyncingFromDraftRef.current
        ) {
          setTimeout(() => {
            if (isSyncingFromDraftRef.current) return;
            nextDraftChangeOriginRef.current = 'reactflow';
            draftStateRef.current.updateEdges(nextEdgesSnapshot);
            draftStateRef.current.updateNodes(nextNodesSnapshot);
          }, 0);
        }
      }

      // Detect drag state from position changes.
      const isDragging = changes.some(
        (change) =>
          change.type === 'position' &&
          (change as Extract<NodeChange, { type: 'position' }>).dragging,
      );
      const wasDragging = isDraggingRef.current;
      isDraggingRef.current = isDragging;

      // Always apply ALL changes to ReactFlow state so nodes move visually.
      baseOnNodesChange(changes);

      if (isHydratingRef.current) return;
      if (!userInteractedRef.current) return;
      if (isSyncingFromDraftRef.current) return;
      if (removedNodeIds.length > 0) return;

      // While dragging, skip draft persistence entirely — it triggers
      // normalizeState + JSON.stringify + localStorage which is expensive.
      // We'll persist once when the drag ends.
      if (isDragging) return;

      // Persist to draft after drag ends or after non-drag changes.
      const persistToDraft = () => {
        if (isSyncingFromDraftRef.current) return;
        nextDraftChangeOriginRef.current = 'reactflow';
        draftStateRef.current.updateNodes(nodesRef.current);
      };

      // Wait one frame for React to commit the state update before reading nodesRef.
      requestAnimationFrame(persistToDraft);
    },
    [baseOnNodesChange, setEdges],
  );

  const handleEdgesChange = useCallback(
    (changes: Parameters<typeof onEdgesChange>[0]) => {
      onEdgesChange(changes);
      if (isHydratingRef.current) {
        return;
      }
      if (!userInteractedRef.current) {
        return;
      }
      if (isSyncingFromDraftRef.current) return; // Don't update draft if we're syncing FROM draft

      // Update draft state with the new edges after changes are applied.
      // Use requestAnimationFrame so the read of edgesRef.current happens after
      // ReactFlow has processed all pending changes for this frame.
      requestAnimationFrame(() => {
        if (isSyncingFromDraftRef.current) return;
        nextDraftChangeOriginRef.current = 'reactflow';
        draftStateRef.current.updateEdges(edgesRef.current);
      });
    },
    [onEdgesChange],
  );

  if (loading) {
    return (
      <div
        style={{
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          height: '100vh',
        }}>
        <Spin size="large" />
      </div>
    );
  }

  return (
    <Layout style={{ overflow: 'hidden' }}>
      <GraphPageHeader
        graphName={
          draftState.draftState.graphName || graph?.name || 'Graph Editor'
        }
        isEditingName={isEditingName}
        editingName={editingName}
        isSavingName={isSavingName}
        onEditingNameChange={setEditingName}
        onNameEdit={handleNameEdit}
        onNameSave={handleNameSave}
        onNameCancel={handleNameCancel}
        graph={graph}
        revisionPopoverVisible={revisionPopoverVisible}
        onRevisionPopoverChange={setRevisionPopoverVisible}
        onLoadRevisions={loadRevisions}
        revisionPopoverContent={revisionPopoverContent}
        displayedVersion={displayedVersion}
        displayedRevisionMeta={displayedRevisionMeta}
        lastFailedRevision={lastFailedRevision}
        graphError={graphError}
        saving={saving}
        isRevisionApplying={isRevisionApplying}
        hasStructuralChanges={hasStructuralChanges}
        unsavedChangesPopoverContent={unsavedChangesPopoverContent}
        onSave={handleSave}
        isGraphRunning={isGraphRunning}
        isGraphCompiling={isGraphCompiling}
        actionLoading={actionLoading}
        onGraphAction={handleGraphAction}
        graphMenuItems={graphMenuItems}
        onGraphMenuAction={handleGraphMenuAction}
      />

      <Layout
        style={{
          height: 'calc(100vh - 135px)',
          overflow: 'hidden',
          position: 'relative',
        }}>
        {leftSidebarCollapsed && (
          <Button
            type="default"
            shape="circle"
            icon={<RightOutlined />}
            aria-label="Expand template sidebar"
            onClick={() => setLeftSidebarCollapsed(false)}
            style={{
              position: 'absolute',
              top: 16,
              left: 16,
              zIndex: 100,
              width: 36,
              height: 36,
              minWidth: 36,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              border: '1px solid #d9d9d9',
              background: '#fff',
            }}
          />
        )}
        <Sider
          width={280}
          collapsible={true}
          defaultCollapsed={false}
          collapsed={leftSidebarCollapsed}
          collapsedWidth={0}
          trigger={null}
          style={{
            background: '#fff',
            borderRight: '1px solid #f0f0f0',
            overflow: 'auto',
            height: '100%',
          }}>
          <TemplateSidebar
            onTemplateClick={handleTemplateClick}
            onClose={() => setLeftSidebarCollapsed(true)}
            templates={templates}
            selectedNode={selectedNode ?? undefined}
            allNodes={nodes}
          />
        </Sider>

        <Content
          style={{
            background: '#f5f5f5',
            height: '100%',
            overflow: 'hidden',
            minHeight: '500px',
          }}>
          <div
            style={{ height: '100%' }}
            onPointerDown={() => {
              userInteractedRef.current = true;
            }}
            onWheel={() => {
              userInteractedRef.current = true;
            }}>
            <GraphCanvas
              nodes={nodes}
              edges={edges}
              onNodesChange={handleNodesChange}
              onEdgesChange={handleEdgesChange}
              onNodeAdd={handleNodeAdd}
              onNodeEdit={handleNodeEdit}
              onNodeDelete={handleNodeDelete}
              onNodeSelect={handleNodeSelect}
              onViewportChange={handleViewportPersistChange}
              initialViewport={viewport}
              templates={templates}
              graphStatus={graph?.status}
              onTriggerClick={handleTriggerClick}
              onValidationError={handleValidationError}
              compiledNodes={compiledNodesMap}
              compiledNodesLoading={compiledNodesLoading}
            />
          </div>
        </Content>

        <NodeEditSidebar
          node={selectedNode}
          visible={nodeEditSidebarVisible}
          onClose={() => setNodeEditSidebarVisible(false)}
          onNodeDraftChange={handleNodeSave}
          templates={templates}
          graphStatus={graph?.status}
          hasGlobalUnsavedChanges={hasUnsavedChanges}
          hasNodeUnsavedChangesFromServer={selectedNodeUnsavedFromServer}
          onTriggerClick={handleTriggerClick}
          compiledNode={
            selectedNode ? compiledNodesMap[selectedNode.id] : undefined
          }
          compiledNodesLoading={compiledNodesLoading}
          graphId={id}
          draftNodeConfigVersion={draftNodeConfigVersion}
          githubAppEnabled={systemSettings.githubAppEnabled}
        />
      </Layout>

      <TemplateModal
        template={selectedTemplate}
        visible={templateModalVisible}
        onClose={() => setTemplateModalVisible(false)}
        allTemplates={templates}
      />

      <TriggerModal
        visible={triggerModalVisible}
        onCancel={() => {
          setTriggerModalVisible(false);
          setTriggerNodeId(null);
          setTriggerNodeName(null);
        }}
        onTrigger={handleTriggerNode}
        nodeId={triggerNodeId || undefined}
        nodeName={triggerNodeName || undefined}
        loading={triggerLoading}
      />

      <GraphAiSuggestionModal
        open={graphAiModalOpen}
        agentNodes={agentNodes}
        selectedNodeId={graphAiSelectedNodeId}
        updatesByNodeId={graphAiUpdatesByNodeId}
        userRequest={graphAiUserRequest}
        loading={graphAiLoading}
        canSubmit={canSubmitGraphAi}
        showRunningWarning={!isGraphRunning}
        models={graphAiModels}
        modelsLoading={graphAiModelsLoading}
        selectedModel={graphAiModel}
        onClose={handleCloseGraphAiModal}
        onSelectNode={setGraphAiSelectedNodeId}
        onUserRequestChange={setGraphAiUserRequest}
        onModelChange={setGraphAiModel}
        onSubmit={handleGraphAiSuggestionSubmit}
        onApply={handleApplyGraphAiSuggestions}
        getCurrentInstructions={getCurrentNodeInstructions}
      />

      <LocalDiffModal
        visible={localDiffModalVisible}
        onClose={handleCloseLocalDiff}
        diffPatch={localDiffPatch}
        graphVersion={graph?.version}
      />

      <RevisionDiffModal
        revision={revisionDiffRevision}
        visible={revisionDiffModalVisible}
        onClose={handleCloseRevisionDiff}
        formatDiffValue={formatRevisionDiffValue}
      />
    </Layout>
  );
};
