import {
  DeleteOutlined,
  EditOutlined,
  EllipsisOutlined,
  EyeOutlined,
  PlusOutlined,
} from '@ant-design/icons';
import {
  Button,
  Card,
  Dropdown,
  Empty,
  Form,
  Input,
  message,
  Modal,
  Select,
  Space,
  Spin,
  Tag,
  Typography,
} from 'antd';
import { formatDistanceToNow } from 'date-fns';
import { useEffect, useMemo, useRef, useState } from 'react';
import { useParams } from 'react-router';

import { knowledgeApi, litellmApi } from '../../api';
import type { KnowledgeDocDto, LiteLlmModelDto } from '../../autogenerated';
import { MarkdownContent } from '../../components/markdown/MarkdownContent';
import { extractApiErrorMessage } from '../../utils/errors';
import {
  KnowledgeAiSuggestionModal,
  type KnowledgeSuggestionState,
} from './components/KnowledgeAiSuggestionModal';
import {
  KnowledgeEditorModal,
  type KnowledgeFormValues,
} from './components/KnowledgeEditorModal';

const { Title, Text, Paragraph } = Typography;
const { Search } = Input;

export const KnowledgeListPage = () => {
  const { projectId } = useParams<{ projectId: string }>();
  const [docs, setDocs] = useState<KnowledgeDocDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [deletingId, setDeletingId] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [searchInput, setSearchInput] = useState('');
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedTags, setSelectedTags] = useState<string[]>([]);
  const [form] = Form.useForm<KnowledgeFormValues>();
  const [editorValue, setEditorValue] = useState('');
  const [modalOpen, setModalOpen] = useState(false);
  const [viewOpen, setViewOpen] = useState(false);
  const [activeDoc, setActiveDoc] = useState<KnowledgeDocDto | null>(null);
  const [viewDoc, setViewDoc] = useState<KnowledgeDocDto | null>(null);
  const [aiSuggestionState, setAiSuggestionState] =
    useState<KnowledgeSuggestionState | null>(null);
  const [liteLlmModels, setLiteLlmModels] = useState<LiteLlmModelDto[]>([]);
  const [litellmModelsLoading, setLitellmModelsLoading] = useState(false);
  const requestIdRef = useRef(0);

  useEffect(() => {
    let mounted = true;
    const requestId = ++requestIdRef.current;
    setLoading(true);
    setError(null);

    knowledgeApi
      .listDocs(
        selectedTags.length > 0 ? selectedTags : undefined,
        searchTerm.trim() ? searchTerm.trim() : undefined,
      )
      .then((res) => {
        if (!mounted || requestId !== requestIdRef.current) return;
        const result = res.data as { items?: KnowledgeDocDto[] };
        setDocs(Array.isArray(result) ? result : result?.items || []);
      })
      .catch((err) => {
        if (!mounted || requestId !== requestIdRef.current) return;
        console.error('Error fetching knowledge docs:', err);
        setError(extractApiErrorMessage(err, 'Failed to load knowledge docs'));
      })
      .finally(() => {
        if (mounted && requestId === requestIdRef.current) {
          setLoading(false);
        }
      });

    return () => {
      mounted = false;
    };
  }, [searchTerm, selectedTags, projectId]);

  useEffect(() => {
    const handle = window.setTimeout(() => {
      const trimmed = searchInput.trim();
      if (trimmed !== searchTerm) {
        setSearchTerm(trimmed);
      }
    }, 400);

    return () => {
      window.clearTimeout(handle);
    };
  }, [searchInput, searchTerm]);

  const tagOptions = useMemo(() => {
    const unique = new Set<string>();
    docs.forEach((doc) => {
      (doc.tags || []).forEach((tag) => unique.add(tag));
    });
    return Array.from(unique).sort((a, b) => a.localeCompare(b));
  }, [docs]);

  const sortedDocs = useMemo(() => {
    return [...docs].sort((a, b) => {
      const aValue = Date.parse(a.updatedAt || a.createdAt || '');
      const bValue = Date.parse(b.updatedAt || b.createdAt || '');
      if (Number.isFinite(aValue) && Number.isFinite(bValue)) {
        return bValue - aValue;
      }
      return (b.updatedAt || '').localeCompare(a.updatedAt || '');
    });
  }, [docs]);

  const handleOpenCreate = () => {
    setActiveDoc(null);
    form.resetFields();
    setEditorValue('');
    setModalOpen(true);
  };

  const handleOpenEdit = (doc: KnowledgeDocDto) => {
    setActiveDoc(doc);
    form.setFieldsValue({
      title: doc.title || '',
      politic: doc.politic || '',
      tags: doc.tags || [],
    });
    setEditorValue(doc.content || '');
    setModalOpen(true);
  };

  const handleCloseModal = () => {
    setModalOpen(false);
    setActiveDoc(null);
    form.resetFields();
    setEditorValue('');
    setAiSuggestionState(null);
  };

  const handleOpenView = (doc: KnowledgeDocDto) => {
    setViewDoc(doc);
    setViewOpen(true);
  };

  const handleCloseView = () => {
    setViewOpen(false);
    setViewDoc(null);
  };

  const handleOpenAiSuggestion = () => {
    const values = form.getFieldsValue();
    const currentTags = Array.isArray(values.tags)
      ? values.tags.filter(Boolean)
      : [];
    setAiSuggestionState({
      currentTitle: values.title || '',
      currentContent: editorValue,
      currentTags,
      suggestedTitle: undefined,
      suggestedContent: undefined,
      suggestedTags: undefined,
      isEditingSuggestion: false,
      editSuggestionDraft: undefined,
      userRequest: '',
      threadId: undefined,
      model: undefined,
      loading: false,
    });
  };

  const handleCloseAiSuggestion = () => {
    setAiSuggestionState(null);
  };

  const handleStartEditSuggested = () => {
    setAiSuggestionState((prev) =>
      prev
        ? {
            ...prev,
            isEditingSuggestion: true,
            editSuggestionDraft: prev.suggestedContent ?? '',
          }
        : prev,
    );
  };

  const handleCancelEditSuggested = () => {
    setAiSuggestionState((prev) =>
      prev
        ? {
            ...prev,
            isEditingSuggestion: false,
            editSuggestionDraft: undefined,
          }
        : prev,
    );
  };

  const handleApplyEditSuggested = () => {
    setAiSuggestionState((prev) =>
      prev && prev.editSuggestionDraft !== undefined
        ? {
            ...prev,
            suggestedContent: prev.editSuggestionDraft,
            isEditingSuggestion: false,
            editSuggestionDraft: undefined,
          }
        : prev,
    );
  };

  const handleAiUserRequestChange = (value: string) => {
    setAiSuggestionState((prev) =>
      prev ? { ...prev, userRequest: value } : prev,
    );
  };

  const handleAiEditDraftChange = (value: string) => {
    setAiSuggestionState((prev) =>
      prev ? { ...prev, editSuggestionDraft: value } : prev,
    );
  };

  const handleAiSuggestedTitleChange = (value: string) => {
    setAiSuggestionState((prev) =>
      prev ? { ...prev, suggestedTitle: value } : prev,
    );
  };

  const handleAiSuggestedTagsChange = (value: string[]) => {
    setAiSuggestionState((prev) =>
      prev ? { ...prev, suggestedTags: value } : prev,
    );
  };

  const handleSubmit = async () => {
    try {
      const values = await form.validateFields();
      const trimmedContent = editorValue.trim();
      if (!trimmedContent) {
        message.warning('Content is required');
        return;
      }

      setSaving(true);
      const trimmedPolitic = values.politic?.trim();
      const payload = {
        title: values.title.trim(),
        // Send null (not undefined) so the backend clears the field when empty.
        politic: trimmedPolitic || null,
        content: editorValue,
        tags: values.tags?.map((tag) => tag.trim()).filter(Boolean),
      };

      if (activeDoc) {
        const res = await knowledgeApi.updateDoc(activeDoc.id, payload);
        setDocs((prev) =>
          prev.map((doc) => (doc.id === activeDoc.id ? res.data : doc)),
        );
        message.success('Knowledge updated');
      } else {
        const res = await knowledgeApi.createDoc(payload);
        setDocs((prev) => [res.data, ...prev]);
        message.success('Knowledge created');
      }

      handleCloseModal();
    } catch (err) {
      if (typeof err === 'object' && err !== null && 'errorFields' in err) {
        return;
      }
      const errorMessage = extractApiErrorMessage(
        err,
        'Failed to save knowledge',
      );
      message.error(errorMessage);
    } finally {
      setSaving(false);
    }
  };

  const handleAiSuggestionSubmit = async () => {
    if (!aiSuggestionState) return;
    const userRequest = aiSuggestionState.userRequest.trim();
    if (!userRequest) {
      message.warning('Enter a request for the AI suggestion');
      return;
    }

    setAiSuggestionState((prev) => (prev ? { ...prev, loading: true } : prev));

    try {
      const response = await knowledgeApi.suggestKnowledgeContent({
        userRequest,
        currentTitle: aiSuggestionState.currentTitle.trim()
          ? aiSuggestionState.currentTitle.trim()
          : undefined,
        currentContent: aiSuggestionState.currentContent.trim()
          ? aiSuggestionState.currentContent
          : undefined,
        currentTags:
          aiSuggestionState.currentTags.length > 0
            ? aiSuggestionState.currentTags
            : undefined,
        threadId: aiSuggestionState.threadId,
        model: aiSuggestionState.model,
      });

      setAiSuggestionState((prev) =>
        prev
          ? {
              ...prev,
              loading: false,
              suggestedTitle:
                response.data?.title ??
                prev.suggestedTitle ??
                prev.currentTitle,
              suggestedContent:
                response.data?.content ??
                prev.suggestedContent ??
                prev.currentContent,
              suggestedTags:
                response.data?.tags ?? prev.suggestedTags ?? prev.currentTags,
              threadId: response.data?.threadId ?? prev.threadId,
              userRequest: '',
            }
          : prev,
      );
    } catch (error) {
      setAiSuggestionState((prev) =>
        prev ? { ...prev, loading: false } : prev,
      );
      message.error(
        extractApiErrorMessage(error, 'Failed to fetch AI suggestion'),
      );
    }
  };

  const handleApplyAiSuggestion = () => {
    if (!aiSuggestionState) return;
    const nextTitle =
      aiSuggestionState.suggestedTitle ?? aiSuggestionState.currentTitle;
    const nextContent =
      aiSuggestionState.suggestedContent ?? aiSuggestionState.currentContent;
    const nextTags =
      aiSuggestionState.suggestedTags ?? aiSuggestionState.currentTags;

    form.setFieldsValue({
      title: nextTitle,
      tags: nextTags,
    });
    setEditorValue(nextContent);
    setAiSuggestionState(null);
  };

  const knowledgeModelOptions = useMemo(
    () =>
      liteLlmModels.map((model) => ({
        label: model.ownedBy ? `${model.id} (${model.ownedBy})` : model.id,
        value: model.id,
      })),
    [liteLlmModels],
  );

  useEffect(() => {
    if (!aiSuggestionState) return;
    if (liteLlmModels.length > 0) return;

    let isActive = true;

    const fetchLiteLlmModels = async () => {
      try {
        setLitellmModelsLoading(true);
        const response = await litellmApi.listModels();
        if (!isActive) return;
        setLiteLlmModels(response.data ?? []);
      } catch (error) {
        if (!isActive) return;
        console.error('Failed to load LiteLLM models:', error);
        message.error(
          extractApiErrorMessage(error, 'Failed to load LiteLLM models'),
        );
      } finally {
        if (isActive) {
          setLitellmModelsLoading(false);
        }
      }
    };

    fetchLiteLlmModels();

    return () => {
      isActive = false;
    };
  }, [aiSuggestionState, liteLlmModels.length]);

  const handleDelete = (doc: KnowledgeDocDto) => {
    Modal.confirm({
      title: 'Delete knowledge',
      content:
        'Are you sure you want to delete this knowledge document? This action cannot be undone.',
      okText: 'Delete',
      okButtonProps: { danger: true, loading: deletingId === doc.id },
      cancelText: 'Cancel',
      centered: true,
      onOk: async () => {
        setDeletingId(doc.id);
        try {
          await knowledgeApi.deleteDoc(doc.id);
          setDocs((prev) => prev.filter((item) => item.id !== doc.id));
          message.success('Knowledge deleted');
        } catch (err) {
          console.error('Error deleting knowledge:', err);
          message.error(
            extractApiErrorMessage(err, 'Failed to delete knowledge'),
          );
        } finally {
          setDeletingId(null);
        }
      },
    });
  };

  if (loading) {
    return (
      <div
        style={{
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          height: '50vh',
        }}>
        <Spin size="large" />
      </div>
    );
  }

  if (error) {
    return (
      <div style={{ padding: 24, textAlign: 'center' }}>
        <Text type="danger">{error}</Text>
      </div>
    );
  }

  const filteredEmpty =
    docs.length === 0 && (searchTerm.trim() || selectedTags.length > 0);
  const filteredEmptyLabel = searchTerm.trim()
    ? `No knowledge matches "${searchTerm.trim()}"`
    : selectedTags.length > 0
      ? 'No knowledge matches the selected tags'
      : 'No knowledge documents yet';
  const aiActionLabel = editorValue.trim()
    ? 'Improve with AI'
    : 'Generate with AI';

  return (
    <div style={{ minHeight: '100%' }}>
      <div style={{ background: 'white', padding: 24 }}>
        <div
          style={{
            display: 'flex',
            justifyContent: 'space-between',
            gap: 24,
            flexWrap: 'wrap',
          }}>
          <div>
            <Title level={2} style={{ marginBottom: 4 }}>
              Knowledge
            </Title>
            <Paragraph type="secondary" style={{ marginBottom: 0 }}>
              Manage your knowledge base and keep docs up to date
            </Paragraph>
          </div>
          <Button
            type="primary"
            icon={<PlusOutlined />}
            size="middle"
            onClick={handleOpenCreate}>
            New Knowledge
          </Button>
        </div>

        <div
          style={{
            marginTop: 20,
            display: 'flex',
            flexWrap: 'wrap',
            gap: 16,
            alignItems: 'center',
          }}>
          <Search
            placeholder="Search knowledge..."
            value={searchInput}
            onChange={(e) => setSearchInput(e.target.value)}
            allowClear
            size="large"
            style={{ width: 340, maxWidth: '100%' }}
          />
          <Select
            mode="multiple"
            allowClear
            placeholder="Filter by tags"
            value={selectedTags}
            onChange={setSelectedTags}
            options={tagOptions.map((tag) => ({ label: tag, value: tag }))}
            style={{ minWidth: 260, maxWidth: '100%' }}
          />
        </div>
      </div>

      {docs.length === 0 && !filteredEmpty ? (
        <Empty
          description="No knowledge documents yet"
          image={Empty.PRESENTED_IMAGE_SIMPLE}>
          <Button type="primary" onClick={handleOpenCreate}>
            Create your first knowledge doc
          </Button>
        </Empty>
      ) : sortedDocs.length === 0 ? (
        <div style={{ marginTop: 48 }}>
          <Empty
            description={filteredEmptyLabel}
            image={Empty.PRESENTED_IMAGE_SIMPLE}
          />
        </div>
      ) : (
        <div
          style={{
            display: 'flex',
            flexWrap: 'wrap',
            gap: 24,
            padding: 24,
          }}>
          {sortedDocs.map((doc) => {
            const updatedAt = new Date(
              doc.updatedAt || doc.createdAt || new Date().toISOString(),
            );
            const summary =
              doc.summary ||
              doc.content?.split('\n').find((line) => line.trim()) ||
              'No summary provided.';
            return (
              <Card
                key={doc.id}
                hoverable
                onClick={() => handleOpenView(doc)}
                style={{
                  borderRadius: 15,
                  border: '1px solid #e5e7eb',
                  backgroundColor: '#ffffff',
                  cursor: 'pointer',
                  flex: '0 0 clamp(300px, 30vw, 420px)',
                }}
                styles={{
                  body: {
                    padding: 16,
                    display: 'flex',
                    flexDirection: 'column',
                    gap: 12,
                    height: '100%',
                  },
                }}>
                <div>
                  <div
                    style={{
                      display: 'flex',
                      alignItems: 'flex-start',
                      justifyContent: 'space-between',
                      gap: 12,
                    }}>
                    <div
                      style={{
                        fontSize: 18,
                        fontWeight: 500,
                        color: '#111827',
                      }}>
                      {doc.title || 'Untitled'}
                    </div>
                    <Dropdown
                      trigger={['click']}
                      menu={{
                        items: [
                          {
                            key: 'show',
                            label: (
                              <div style={{ display: 'flex', gap: 8 }}>
                                <EyeOutlined />
                                Show
                              </div>
                            ),
                          },
                          {
                            key: 'update',
                            label: (
                              <div style={{ display: 'flex', gap: 8 }}>
                                <EditOutlined />
                                Update
                              </div>
                            ),
                          },
                          {
                            key: 'delete',
                            danger: true,
                            disabled: deletingId === doc.id,
                            label: (
                              <div style={{ display: 'flex', gap: 8 }}>
                                <DeleteOutlined />
                                Delete
                              </div>
                            ),
                          },
                        ],
                        onClick: ({ key, domEvent }) => {
                          domEvent.stopPropagation();
                          if (key === 'show') handleOpenView(doc);
                          if (key === 'update') handleOpenEdit(doc);
                          if (key === 'delete') handleDelete(doc);
                        },
                      }}>
                      <Button
                        type="text"
                        icon={<EllipsisOutlined />}
                        onClick={(event) => event.stopPropagation()}
                        style={{
                          border: 'none',
                          boxShadow: 'none',
                          color: '#6b7280',
                        }}
                      />
                    </Dropdown>
                  </div>
                  <Paragraph
                    style={{ color: '#4b5563', marginBottom: 8, fontSize: 13 }}
                    ellipsis={{ rows: 3 }}>
                    {summary}
                  </Paragraph>
                  <div style={{ display: 'flex', flexWrap: 'wrap', gap: 6 }}>
                    {(doc.tags || []).length > 0 ? (
                      doc.tags?.map((tag) => (
                        <Tag key={tag} style={{ margin: 0 }} color="processing">
                          {tag}
                        </Tag>
                      ))
                    ) : (
                      <Text type="secondary" style={{ fontSize: 12 }}>
                        No tags
                      </Text>
                    )}
                  </div>
                </div>

                <div
                  style={{
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between',
                    marginTop: 'auto',
                  }}>
                  <Text type="secondary" style={{ fontSize: 12 }}>
                    Updated{' '}
                    {formatDistanceToNow(updatedAt, { addSuffix: true })}
                  </Text>
                </div>
              </Card>
            );
          })}
        </div>
      )}

      <KnowledgeEditorModal
        open={modalOpen}
        activeDoc={activeDoc}
        saving={saving}
        form={form}
        editorValue={editorValue}
        onEditorChange={setEditorValue}
        tagOptions={tagOptions}
        onCancel={handleCloseModal}
        onSubmit={handleSubmit}
        onOpenAiSuggestion={handleOpenAiSuggestion}
        aiActionLabel={aiActionLabel}
      />

      <KnowledgeAiSuggestionModal
        open={Boolean(aiSuggestionState)}
        state={aiSuggestionState}
        models={knowledgeModelOptions}
        modelsLoading={litellmModelsLoading}
        onClose={handleCloseAiSuggestion}
        onUserRequestChange={handleAiUserRequestChange}
        onModelChange={(value) =>
          setAiSuggestionState((prev) =>
            prev ? { ...prev, model: value } : prev,
          )
        }
        onSubmit={handleAiSuggestionSubmit}
        onApplySuggestion={handleApplyAiSuggestion}
        onStartEditSuggested={handleStartEditSuggested}
        onCancelEditSuggested={handleCancelEditSuggested}
        onApplyEditSuggested={handleApplyEditSuggested}
        onEditDraftChange={handleAiEditDraftChange}
        onSuggestedTitleChange={handleAiSuggestedTitleChange}
        onSuggestedTagsChange={handleAiSuggestedTagsChange}
      />

      <Modal
        title="Knowledge details"
        open={viewOpen}
        onCancel={handleCloseView}
        footer={[
          <Button key="close" onClick={handleCloseView}>
            Close
          </Button>,
          <Button
            key="edit"
            type="primary"
            onClick={() => {
              if (viewDoc) {
                handleCloseView();
                handleOpenEdit(viewDoc);
              }
            }}>
            Edit
          </Button>,
        ]}
        width={900}>
        {viewDoc ? (
          <Space direction="vertical" size={12} style={{ width: '100%' }}>
            <Title level={4} style={{ margin: 0 }}>
              {viewDoc.title || 'Untitled'}
            </Title>
            <Text type="secondary">
              Updated{' '}
              {formatDistanceToNow(
                new Date(
                  viewDoc.updatedAt ||
                    viewDoc.createdAt ||
                    new Date().toISOString(),
                ),
                { addSuffix: true },
              )}
            </Text>
            <div style={{ display: 'flex', flexWrap: 'wrap', gap: 6 }}>
              {(viewDoc.tags || []).length > 0 ? (
                viewDoc.tags?.map((tag) => (
                  <Tag key={tag} style={{ margin: 0 }}>
                    {tag}
                  </Tag>
                ))
              ) : (
                <Text type="secondary" style={{ fontSize: 12 }}>
                  No tags
                </Text>
              )}
            </div>
            {viewDoc.politic && (
              <Paragraph type="secondary" style={{ marginBottom: 0 }}>
                {viewDoc.politic}
              </Paragraph>
            )}
            {viewDoc.summary && (
              <Paragraph type="secondary">{viewDoc.summary}</Paragraph>
            )}
            <div
              style={{
                border: '1px solid #f0f0f0',
                borderRadius: 10,
                padding: 16,
                maxHeight: 420,
                overflowY: 'auto',
              }}>
              <MarkdownContent content={viewDoc.content || ''} />
            </div>
          </Space>
        ) : null}
      </Modal>
    </div>
  );
};

export default KnowledgeListPage;
